




/*!
 * modernizr v3.6.0
 * Build https://modernizr.com/download?-objectfit-addtest-atrule-domprefixes-hasevent-mq-prefixed-prefixedcss-prefixedcssvalue-prefixes-setclasses-testallprops-testprop-teststyles-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/

;(function(window, document, undefined){
    var classes = [];
    
  
    var tests = [];
    
  
    /**
     *
     * ModernizrProto is the constructor for Modernizr
     *
     * @class
     * @access public
     */
  
    var ModernizrProto = {
      // The current version, dummy
      _version: '3.6.0',
  
      // Any settings that don't work as separate modules
      // can go in here as configuration.
      _config: {
        'classPrefix': '',
        'enableClasses': true,
        'enableJSClass': true,
        'usePrefixes': true
      },
  
      // Queue of tests
      _q: [],
  
      // Stub these for people who are listening
      on: function(test, cb) {
        // I don't really think people should do this, but we can
        // safe guard it a bit.
        // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
        // This is in case people listen to synchronous tests. I would leave it out,
        // but the code to *disallow* sync tests in the real version of this
        // function is actually larger than this.
        var self = this;
        setTimeout(function() {
          cb(self[test]);
        }, 0);
      },
  
      addTest: function(name, fn, options) {
        tests.push({name: name, fn: fn, options: options});
      },
  
      addAsyncTest: function(fn) {
        tests.push({name: null, fn: fn});
      }
    };
  
    
  
    // Fake some of Object.create so we can force non test results to be non "own" properties.
    var Modernizr = function() {};
    Modernizr.prototype = ModernizrProto;
  
    // Leak modernizr globally when you `require` it rather than force it here.
    // Overwrite name so constructor name is nicer :D
    Modernizr = new Modernizr();
  
    
  
    /**
     * List of property values to set for css tests. See ticket #21
     * http://git.io/vUGl4
     *
     * @memberof Modernizr
     * @name Modernizr._prefixes
     * @optionName Modernizr._prefixes
     * @optionProp prefixes
     * @access public
     * @example
     *
     * Modernizr._prefixes is the internal list of prefixes that we test against
     * inside of things like [prefixed](#modernizr-prefixed) and [prefixedCSS](#-code-modernizr-prefixedcss). It is simply
     * an array of kebab-case vendor prefixes you can use within your code.
     *
     * Some common use cases include
     *
     * Generating all possible prefixed version of a CSS property
     * ```js
     * var rule = Modernizr._prefixes.join('transform: rotate(20deg); ');
     *
     * rule === 'transform: rotate(20deg); webkit-transform: rotate(20deg); moz-transform: rotate(20deg); o-transform: rotate(20deg); ms-transform: rotate(20deg);'
     * ```
     *
     * Generating all possible prefixed version of a CSS value
     * ```js
     * rule = 'display:' +  Modernizr._prefixes.join('flex; display:') + 'flex';
     *
     * rule === 'display:flex; display:-webkit-flex; display:-moz-flex; display:-o-flex; display:-ms-flex; display:flex'
     * ```
     */
  
    // we use ['',''] rather than an empty array in order to allow a pattern of .`join()`ing prefixes to test
    // values in feature detects to continue to work
    var prefixes = (ModernizrProto._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : ['','']);
  
    // expose these for the plugin API. Look in the source for how to join() them against your input
    ModernizrProto._prefixes = prefixes;
  
    
  
    /**
     * If the browsers follow the spec, then they would expose vendor-specific styles as:
     *   elem.style.WebkitBorderRadius
     * instead of something like the following (which is technically incorrect):
     *   elem.style.webkitBorderRadius
  
     * WebKit ghosts their properties in lowercase but Opera & Moz do not.
     * Microsoft uses a lowercase `ms` instead of the correct `Ms` in IE8+
     *   erik.eae.net/archives/2008/03/10/21.48.10/
  
     * More here: github.com/Modernizr/Modernizr/issues/issue/21
     *
     * @access private
     * @returns {string} The string representing the vendor-specific style properties
     */
  
    var omPrefixes = 'Moz O ms Webkit';
    
  
    /**
     * List of JavaScript DOM values used for tests
     *
     * @memberof Modernizr
     * @name Modernizr._domPrefixes
     * @optionName Modernizr._domPrefixes
     * @optionProp domPrefixes
     * @access public
     * @example
     *
     * Modernizr._domPrefixes is exactly the same as [_prefixes](#modernizr-_prefixes), but rather
     * than kebab-case properties, all properties are their Capitalized variant
     *
     * ```js
     * Modernizr._domPrefixes === [ "Moz", "O", "ms", "Webkit" ];
     * ```
     */
  
    var domPrefixes = (ModernizrProto._config.usePrefixes ? omPrefixes.toLowerCase().split(' ') : []);
    ModernizrProto._domPrefixes = domPrefixes;
    
  
    /**
     * is returns a boolean if the typeof an obj is exactly type.
     *
     * @access private
     * @function is
     * @param {*} obj - A thing we want to check the type of
     * @param {string} type - A string to compare the typeof against
     * @returns {boolean}
     */
  
    function is(obj, type) {
      return typeof obj === type;
    }
    ;
  
    /**
     * Run through all tests and detect their support in the current UA.
     *
     * @access private
     */
  
    function testRunner() {
      var featureNames;
      var feature;
      var aliasIdx;
      var result;
      var nameIdx;
      var featureName;
      var featureNameSplit;
  
      for (var featureIdx in tests) {
        if (tests.hasOwnProperty(featureIdx)) {
          featureNames = [];
          feature = tests[featureIdx];
          // run the test, throw the return value into the Modernizr,
          // then based on that boolean, define an appropriate className
          // and push it into an array of classes we'll join later.
          //
          // If there is no name, it's an 'async' test that is run,
          // but not directly added to the object. That should
          // be done with a post-run addTest call.
          if (feature.name) {
            featureNames.push(feature.name.toLowerCase());
  
            if (feature.options && feature.options.aliases && feature.options.aliases.length) {
              // Add all the aliases into the names list
              for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
                featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
              }
            }
          }
  
          // Run the test, or use the raw value if it's not a function
          result = is(feature.fn, 'function') ? feature.fn() : feature.fn;
  
  
          // Set each of the names on the Modernizr object
          for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
            featureName = featureNames[nameIdx];
            // Support dot properties as sub tests. We don't do checking to make sure
            // that the implied parent tests have been added. You must call them in
            // order (either in the test, or make the parent test a dependency).
            //
            // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
            // hashtag famous last words
            featureNameSplit = featureName.split('.');
  
            if (featureNameSplit.length === 1) {
              Modernizr[featureNameSplit[0]] = result;
            } else {
              // cast to a Boolean, if not one already
              if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
                Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
              }
  
              Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
            }
  
            classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
          }
        }
      }
    }
    ;
  
    /**
     * docElement is a convenience wrapper to grab the root element of the document
     *
     * @access private
     * @returns {HTMLElement|SVGElement} The root element of the document
     */
  
    var docElement = document.documentElement;
    
  
    /**
     * A convenience helper to check if the document we are running in is an SVG document
     *
     * @access private
     * @returns {boolean}
     */
  
    var isSVG = docElement.nodeName.toLowerCase() === 'svg';
    
  
    /**
     * setClasses takes an array of class names and adds them to the root element
     *
     * @access private
     * @function setClasses
     * @param {string[]} classes - Array of class names
     */
  
    // Pass in an and array of class names, e.g.:
    //  ['no-webp', 'borderradius', ...]
    function setClasses(classes) {
      var className = docElement.className;
      var classPrefix = Modernizr._config.classPrefix || '';
  
      if (isSVG) {
        className = className.baseVal;
      }
  
      // Change `no-js` to `js` (independently of the `enableClasses` option)
      // Handle classPrefix on this too
      if (Modernizr._config.enableJSClass) {
        var reJS = new RegExp('(^|\\s)' + classPrefix + 'no-js(\\s|$)');
        className = className.replace(reJS, '$1' + classPrefix + 'js$2');
      }
  
      if (Modernizr._config.enableClasses) {
        // Add the new classes
        className += ' ' + classPrefix + classes.join(' ' + classPrefix);
        if (isSVG) {
          docElement.className.baseVal = className;
        } else {
          docElement.className = className;
        }
      }
  
    }
  
    ;
  
    /**
     * domToCSS takes a camelCase string and converts it to kebab-case
     * e.g. boxSizing -> box-sizing
     *
     * @access private
     * @function domToCSS
     * @param {string} name - String name of camelCase prop we want to convert
     * @returns {string} The kebab-case version of the supplied name
     */
  
    function domToCSS(name) {
      return name.replace(/([A-Z])/g, function(str, m1) {
        return '-' + m1.toLowerCase();
      }).replace(/^ms-/, '-ms-');
    }
    ;
  
    /**
     * hasOwnProp is a shim for hasOwnProperty that is needed for Safari 2.0 support
     *
     * @author kangax
     * @access private
     * @function hasOwnProp
     * @param {object} object - The object to check for a property
     * @param {string} property - The property to check for
     * @returns {boolean}
     */
  
    // hasOwnProperty shim by kangax needed for Safari 2.0 support
    var hasOwnProp;
  
    (function() {
      var _hasOwnProperty = ({}).hasOwnProperty;
      /* istanbul ignore else */
      /* we have no way of testing IE 5.5 or safari 2,
       * so just assume the else gets hit */
      if (!is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined')) {
        hasOwnProp = function(object, property) {
          return _hasOwnProperty.call(object, property);
        };
      }
      else {
        hasOwnProp = function(object, property) { /* yes, this can give false positives/negatives, but most of the time we don't care about those */
          return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
        };
      }
    })();
  
    
  
  
     // _l tracks listeners for async tests, as well as tests that execute after the initial run
    ModernizrProto._l = {};
  
    /**
     * Modernizr.on is a way to listen for the completion of async tests. Being
     * asynchronous, they may not finish before your scripts run. As a result you
     * will get a possibly false negative `undefined` value.
     *
     * @memberof Modernizr
     * @name Modernizr.on
     * @access public
     * @function on
     * @param {string} feature - String name of the feature detect
     * @param {function} cb - Callback function returning a Boolean - true if feature is supported, false if not
     * @example
     *
     * ```js
     * Modernizr.on('flash', function( result ) {
     *   if (result) {
     *    // the browser has flash
     *   } else {
     *     // the browser does not have flash
     *   }
     * });
     * ```
     */
  
    ModernizrProto.on = function(feature, cb) {
      // Create the list of listeners if it doesn't exist
      if (!this._l[feature]) {
        this._l[feature] = [];
      }
  
      // Push this test on to the listener list
      this._l[feature].push(cb);
  
      // If it's already been resolved, trigger it on next tick
      if (Modernizr.hasOwnProperty(feature)) {
        // Next Tick
        setTimeout(function() {
          Modernizr._trigger(feature, Modernizr[feature]);
        }, 0);
      }
    };
  
    /**
     * _trigger is the private function used to signal test completion and run any
     * callbacks registered through [Modernizr.on](#modernizr-on)
     *
     * @memberof Modernizr
     * @name Modernizr._trigger
     * @access private
     * @function _trigger
     * @param {string} feature - string name of the feature detect
     * @param {function|boolean} [res] - A feature detection function, or the boolean =
     * result of a feature detection function
     */
  
    ModernizrProto._trigger = function(feature, res) {
      if (!this._l[feature]) {
        return;
      }
  
      var cbs = this._l[feature];
  
      // Force async
      setTimeout(function() {
        var i, cb;
        for (i = 0; i < cbs.length; i++) {
          cb = cbs[i];
          cb(res);
        }
      }, 0);
  
      // Don't trigger these again
      delete this._l[feature];
    };
  
    /**
     * addTest allows you to define your own feature detects that are not currently
     * included in Modernizr (under the covers it's the exact same code Modernizr
     * uses for its own [feature detections](https://github.com/Modernizr/Modernizr/tree/master/feature-detects)). Just like the offical detects, the result
     * will be added onto the Modernizr object, as well as an appropriate className set on
     * the html element when configured to do so
     *
     * @memberof Modernizr
     * @name Modernizr.addTest
     * @optionName Modernizr.addTest()
     * @optionProp addTest
     * @access public
     * @function addTest
     * @param {string|object} feature - The string name of the feature detect, or an
     * object of feature detect names and test
     * @param {function|boolean} test - Function returning true if feature is supported,
     * false if not. Otherwise a boolean representing the results of a feature detection
     * @example
     *
     * The most common way of creating your own feature detects is by calling
     * `Modernizr.addTest` with a string (preferably just lowercase, without any
     * punctuation), and a function you want executed that will return a boolean result
     *
     * ```js
     * Modernizr.addTest('itsTuesday', function() {
     *  var d = new Date();
     *  return d.getDay() === 2;
     * });
     * ```
     *
     * When the above is run, it will set Modernizr.itstuesday to `true` when it is tuesday,
     * and to `false` every other day of the week. One thing to notice is that the names of
     * feature detect functions are always lowercased when added to the Modernizr object. That
     * means that `Modernizr.itsTuesday` will not exist, but `Modernizr.itstuesday` will.
     *
     *
     *  Since we only look at the returned value from any feature detection function,
     *  you do not need to actually use a function. For simple detections, just passing
     *  in a statement that will return a boolean value works just fine.
     *
     * ```js
     * Modernizr.addTest('hasJquery', 'jQuery' in window);
     * ```
     *
     * Just like before, when the above runs `Modernizr.hasjquery` will be true if
     * jQuery has been included on the page. Not using a function saves a small amount
     * of overhead for the browser, as well as making your code much more readable.
     *
     * Finally, you also have the ability to pass in an object of feature names and
     * their tests. This is handy if you want to add multiple detections in one go.
     * The keys should always be a string, and the value can be either a boolean or
     * function that returns a boolean.
     *
     * ```js
     * var detects = {
     *  'hasjquery': 'jQuery' in window,
     *  'itstuesday': function() {
     *    var d = new Date();
     *    return d.getDay() === 2;
     *  }
     * }
     *
     * Modernizr.addTest(detects);
     * ```
     *
     * There is really no difference between the first methods and this one, it is
     * just a convenience to let you write more readable code.
     */
  
    function addTest(feature, test) {
  
      if (typeof feature == 'object') {
        for (var key in feature) {
          if (hasOwnProp(feature, key)) {
            addTest(key, feature[ key ]);
          }
        }
      } else {
  
        feature = feature.toLowerCase();
        var featureNameSplit = feature.split('.');
        var last = Modernizr[featureNameSplit[0]];
  
        // Again, we don't check for parent test existence. Get that right, though.
        if (featureNameSplit.length == 2) {
          last = last[featureNameSplit[1]];
        }
  
        if (typeof last != 'undefined') {
          // we're going to quit if you're trying to overwrite an existing test
          // if we were to allow it, we'd do this:
          //   var re = new RegExp("\\b(no-)?" + feature + "\\b");
          //   docElement.className = docElement.className.replace( re, '' );
          // but, no rly, stuff 'em.
          return Modernizr;
        }
  
        test = typeof test == 'function' ? test() : test;
  
        // Set the value (this is the magic, right here).
        if (featureNameSplit.length == 1) {
          Modernizr[featureNameSplit[0]] = test;
        } else {
          // cast to a Boolean, if not one already
          if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
            Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
          }
  
          Modernizr[featureNameSplit[0]][featureNameSplit[1]] = test;
        }
  
        // Set a single class (either `feature` or `no-feature`)
        setClasses([(!!test && test != false ? '' : 'no-') + featureNameSplit.join('-')]);
  
        // Trigger the event
        Modernizr._trigger(feature, test);
      }
  
      return Modernizr; // allow chaining.
    }
  
    // After all the tests are run, add self to the Modernizr prototype
    Modernizr._q.push(function() {
      ModernizrProto.addTest = addTest;
    });
  
    
  
  
    var cssomPrefixes = (ModernizrProto._config.usePrefixes ? omPrefixes.split(' ') : []);
    ModernizrProto._cssomPrefixes = cssomPrefixes;
    
  
    /**
     * atRule returns a given CSS property at-rule (eg @keyframes), possibly in
     * some prefixed form, or false, in the case of an unsupported rule
     *
     * @memberof Modernizr
     * @name Modernizr.atRule
     * @optionName Modernizr.atRule()
     * @optionProp atRule
     * @access public
     * @function atRule
     * @param {string} prop - String name of the @-rule to test for
     * @returns {string|boolean} The string representing the (possibly prefixed)
     * valid version of the @-rule, or `false` when it is unsupported.
     * @example
     * ```js
     *  var keyframes = Modernizr.atRule('@keyframes');
     *
     *  if (keyframes) {
     *    // keyframes are supported
     *    // could be `@-webkit-keyframes` or `@keyframes`
     *  } else {
     *    // keyframes === `false`
     *  }
     * ```
     *
     */
  
    var atRule = function(prop) {
      var length = prefixes.length;
      var cssrule = window.CSSRule;
      var rule;
  
      if (typeof cssrule === 'undefined') {
        return undefined;
      }
  
      if (!prop) {
        return false;
      }
  
      // remove literal @ from beginning of provided property
      prop = prop.replace(/^@/, '');
  
      // CSSRules use underscores instead of dashes
      rule = prop.replace(/-/g, '_').toUpperCase() + '_RULE';
  
      if (rule in cssrule) {
        return '@' + prop;
      }
  
      for (var i = 0; i < length; i++) {
        // prefixes gives us something like -o-, and we want O_
        var prefix = prefixes[i];
        var thisRule = prefix.toUpperCase() + '_' + rule;
  
        if (thisRule in cssrule) {
          return '@-' + prefix.toLowerCase() + '-' + prop;
        }
      }
  
      return false;
    };
  
    ModernizrProto.atRule = atRule;
  
    
  
    /**
     * createElement is a convenience wrapper around document.createElement. Since we
     * use createElement all over the place, this allows for (slightly) smaller code
     * as well as abstracting away issues with creating elements in contexts other than
     * HTML documents (e.g. SVG documents).
     *
     * @access private
     * @function createElement
     * @returns {HTMLElement|SVGElement} An HTML or SVG element
     */
  
    function createElement() {
      if (typeof document.createElement !== 'function') {
        // This is the case in IE7, where the type of createElement is "object".
        // For this reason, we cannot call apply() as Object is not a Function.
        return document.createElement(arguments[0]);
      } else if (isSVG) {
        return document.createElementNS.call(document, 'http://www.w3.org/2000/svg', arguments[0]);
      } else {
        return document.createElement.apply(document, arguments);
      }
    }
  
    ;
  
    /**
     * Modernizr.hasEvent() detects support for a given event
     *
     * @memberof Modernizr
     * @name Modernizr.hasEvent
     * @optionName Modernizr.hasEvent()
     * @optionProp hasEvent
     * @access public
     * @function hasEvent
     * @param  {string|*} eventName - the name of an event to test for (e.g. "resize")
     * @param  {Element|string} [element=HTMLDivElement] - is the element|document|window|tagName to test on
     * @returns {boolean}
     * @example
     *  `Modernizr.hasEvent` lets you determine if the browser supports a supplied event.
     *  By default, it does this detection on a div element
     *
     * ```js
     *  hasEvent('blur') // true;
     * ```
     *
     * However, you are able to give an object as a second argument to hasEvent to
     * detect an event on something other than a div.
     *
     * ```js
     *  hasEvent('devicelight', window) // true;
     * ```
     *
     */
  
    var hasEvent = (function() {
  
      // Detect whether event support can be detected via `in`. Test on a DOM element
      // using the "blur" event b/c it should always exist. bit.ly/event-detection
      var needsFallback = !('onblur' in document.documentElement);
  
      function inner(eventName, element) {
  
        var isSupported;
        if (!eventName) { return false; }
        if (!element || typeof element === 'string') {
          element = createElement(element || 'div');
        }
  
        // Testing via the `in` operator is sufficient for modern browsers and IE.
        // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and
        // "resize", whereas `in` "catches" those.
        eventName = 'on' + eventName;
        isSupported = eventName in element;
  
        // Fallback technique for old Firefox - bit.ly/event-detection
        if (!isSupported && needsFallback) {
          if (!element.setAttribute) {
            // Switch to generic element if it lacks `setAttribute`.
            // It could be the `document`, `window`, or something else.
            element = createElement('div');
          }
  
          element.setAttribute(eventName, '');
          isSupported = typeof element[eventName] === 'function';
  
          if (element[eventName] !== undefined) {
            // If property was created, "remove it" by setting value to `undefined`.
            element[eventName] = undefined;
          }
          element.removeAttribute(eventName);
        }
  
        return isSupported;
      }
      return inner;
    })();
  
  
    ModernizrProto.hasEvent = hasEvent;
    
  
    /**
     * prefixedCSSValue is a way test for prefixed css properties (e.g. display: -webkit-flex)
     *
     * @memberof Modernizr
     * @name Modernizr.prefixedCSSValue
     * @optionName Modernizr.prefixedCSSValue()
     * @optionProp prefixedCSSValue
     * @access public
     * @function prefixedCSSValue
     * @param {string} prop - String name of the property to test for
     * @param {string} value - String value of the non prefixed version of the value you want to test for
     * @returns {string|false} The string representing the (possibly prefixed)
     * valid version of the property, or `false` when it is unsupported.
     * @example
     *
     * `Modernizr.prefixedCSSValue` is a way test for prefixed css properties (e.g. display: -webkit-flex)
     *
     * ```js
     * Modernizr.prefixedCSSValue('background', 'linear-gradient(left, red, red)')
     * ```
     *
     */
  
    var prefixedCSSValue = function(prop, value) {
      var result = false;
      var elem = createElement('div');
      var style = elem.style;
  
      if (prop in style) {
        var i = domPrefixes.length;
  
        style[prop] = value;
        result = style[prop];
  
        while (i-- && !result) {
          style[prop] = '-' + domPrefixes[i] + '-' + value;
          result = style[prop];
        }
      }
  
      if (result === '') {
        result = false;
      }
  
      return result;
    };
  
    ModernizrProto.prefixedCSSValue = prefixedCSSValue;
    
  
    /**
     * cssToDOM takes a kebab-case string and converts it to camelCase
     * e.g. box-sizing -> boxSizing
     *
     * @access private
     * @function cssToDOM
     * @param {string} name - String name of kebab-case prop we want to convert
     * @returns {string} The camelCase version of the supplied name
     */
  
    function cssToDOM(name) {
      return name.replace(/([a-z])-([a-z])/g, function(str, m1, m2) {
        return m1 + m2.toUpperCase();
      }).replace(/^-/, '');
    }
    ;
  
    /**
     * getBody returns the body of a document, or an element that can stand in for
     * the body if a real body does not exist
     *
     * @access private
     * @function getBody
     * @returns {HTMLElement|SVGElement} Returns the real body of a document, or an
     * artificially created element that stands in for the body
     */
  
    function getBody() {
      // After page load injecting a fake body doesn't work so check if body exists
      var body = document.body;
  
      if (!body) {
        // Can't use the real body create a fake one.
        body = createElement(isSVG ? 'svg' : 'body');
        body.fake = true;
      }
  
      return body;
    }
  
    ;
  
    /**
     * injectElementWithStyles injects an element with style element and some CSS rules
     *
     * @access private
     * @function injectElementWithStyles
     * @param {string} rule - String representing a css rule
     * @param {function} callback - A function that is used to test the injected element
     * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
     * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
     * @returns {boolean}
     */
  
    function injectElementWithStyles(rule, callback, nodes, testnames) {
      var mod = 'modernizr';
      var style;
      var ret;
      var node;
      var docOverflow;
      var div = createElement('div');
      var body = getBody();
  
      if (parseInt(nodes, 10)) {
        // In order not to give false positives we create a node for each test
        // This also allows the method to scale for unspecified uses
        while (nodes--) {
          node = createElement('div');
          node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
          div.appendChild(node);
        }
      }
  
      style = createElement('style');
      style.type = 'text/css';
      style.id = 's' + mod;
  
      // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
      // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
      (!body.fake ? div : body).appendChild(style);
      body.appendChild(div);
  
      if (style.styleSheet) {
        style.styleSheet.cssText = rule;
      } else {
        style.appendChild(document.createTextNode(rule));
      }
      div.id = mod;
  
      if (body.fake) {
        //avoid crashing IE8, if background image is used
        body.style.background = '';
        //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
        body.style.overflow = 'hidden';
        docOverflow = docElement.style.overflow;
        docElement.style.overflow = 'hidden';
        docElement.appendChild(body);
      }
  
      ret = callback(div, rule);
      // If this is done after page load we don't want to remove the body so check if body exists
      if (body.fake) {
        body.parentNode.removeChild(body);
        docElement.style.overflow = docOverflow;
        // Trigger layout so kinetic scrolling isn't disabled in iOS6+
        // eslint-disable-next-line
        docElement.offsetHeight;
      } else {
        div.parentNode.removeChild(div);
      }
  
      return !!ret;
  
    }
  
    ;
  
    /**
     * Modernizr.mq tests a given media query, live against the current state of the window
     * adapted from matchMedia polyfill by Scott Jehl and Paul Irish
     * gist.github.com/786768
     *
     * @memberof Modernizr
     * @name Modernizr.mq
     * @optionName Modernizr.mq()
     * @optionProp mq
     * @access public
     * @function mq
     * @param {string} mq - String of the media query we want to test
     * @returns {boolean}
     * @example
     * Modernizr.mq allows for you to programmatically check if the current browser
     * window state matches a media query.
     *
     * ```js
     *  var query = Modernizr.mq('(min-width: 900px)');
     *
     *  if (query) {
     *    // the browser window is larger than 900px
     *  }
     * ```
     *
     * Only valid media queries are supported, therefore you must always include values
     * with your media query
     *
     * ```js
     * // good
     *  Modernizr.mq('(min-width: 900px)');
     *
     * // bad
     *  Modernizr.mq('min-width');
     * ```
     *
     * If you would just like to test that media queries are supported in general, use
     *
     * ```js
     *  Modernizr.mq('only all'); // true if MQ are supported, false if not
     * ```
     *
     *
     * Note that if the browser does not support media queries (e.g. old IE) mq will
     * always return false.
     */
  
    var mq = (function() {
      var matchMedia = window.matchMedia || window.msMatchMedia;
      if (matchMedia) {
        return function(mq) {
          var mql = matchMedia(mq);
          return mql && mql.matches || false;
        };
      }
  
      return function(mq) {
        var bool = false;
  
        injectElementWithStyles('@media ' + mq + ' { #modernizr { position: absolute; } }', function(node) {
          bool = (window.getComputedStyle ?
                  window.getComputedStyle(node, null) :
                  node.currentStyle).position == 'absolute';
        });
  
        return bool;
      };
    })();
  
  
    ModernizrProto.mq = mq;
  
    
  
    /**
     * testStyles injects an element with style element and some CSS rules
     *
     * @memberof Modernizr
     * @name Modernizr.testStyles
     * @optionName Modernizr.testStyles()
     * @optionProp testStyles
     * @access public
     * @function testStyles
     * @param {string} rule - String representing a css rule
     * @param {function} callback - A function that is used to test the injected element
     * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
     * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
     * @returns {boolean}
     * @example
     *
     * `Modernizr.testStyles` takes a CSS rule and injects it onto the current page
     * along with (possibly multiple) DOM elements. This lets you check for features
     * that can not be detected by simply checking the [IDL](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Interface_development_guide/IDL_interface_rules).
     *
     * ```js
     * Modernizr.testStyles('#modernizr { width: 9px; color: papayawhip; }', function(elem, rule) {
     *   // elem is the first DOM node in the page (by default #modernizr)
     *   // rule is the first argument you supplied - the CSS rule in string form
     *
     *   addTest('widthworks', elem.style.width === '9px')
     * });
     * ```
     *
     * If your test requires multiple nodes, you can include a third argument
     * indicating how many additional div elements to include on the page. The
     * additional nodes are injected as children of the `elem` that is returned as
     * the first argument to the callback.
     *
     * ```js
     * Modernizr.testStyles('#modernizr {width: 1px}; #modernizr2 {width: 2px}', function(elem) {
     *   document.getElementById('modernizr').style.width === '1px'; // true
     *   document.getElementById('modernizr2').style.width === '2px'; // true
     *   elem.firstChild === document.getElementById('modernizr2'); // true
     * }, 1);
     * ```
     *
     * By default, all of the additional elements have an ID of `modernizr[n]`, where
     * `n` is its index (e.g. the first additional, second overall is `#modernizr2`,
     * the second additional is `#modernizr3`, etc.).
     * If you want to have more meaningful IDs for your function, you can provide
     * them as the fourth argument, as an array of strings
     *
     * ```js
     * Modernizr.testStyles('#foo {width: 10px}; #bar {height: 20px}', function(elem) {
     *   elem.firstChild === document.getElementById('foo'); // true
     *   elem.lastChild === document.getElementById('bar'); // true
     * }, 2, ['foo', 'bar']);
     * ```
     *
     */
  
    var testStyles = ModernizrProto.testStyles = injectElementWithStyles;
    
  
  
    /**
     * contains checks to see if a string contains another string
     *
     * @access private
     * @function contains
     * @param {string} str - The string we want to check for substrings
     * @param {string} substr - The substring we want to search the first string for
     * @returns {boolean}
     */
  
    function contains(str, substr) {
      return !!~('' + str).indexOf(substr);
    }
  
    ;
  
    /**
     * fnBind is a super small [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) polyfill.
     *
     * @access private
     * @function fnBind
     * @param {function} fn - a function you want to change `this` reference to
     * @param {object} that - the `this` you want to call the function with
     * @returns {function} The wrapped version of the supplied function
     */
  
    function fnBind(fn, that) {
      return function() {
        return fn.apply(that, arguments);
      };
    }
  
    ;
  
    /**
     * testDOMProps is a generic DOM property test; if a browser supports
     *   a certain property, it won't return undefined for it.
     *
     * @access private
     * @function testDOMProps
     * @param {array.<string>} props - An array of properties to test for
     * @param {object} obj - An object or Element you want to use to test the parameters again
     * @param {boolean|object} elem - An Element to bind the property lookup again. Use `false` to prevent the check
     * @returns {false|*} returns false if the prop is unsupported, otherwise the value that is supported
     */
    function testDOMProps(props, obj, elem) {
      var item;
  
      for (var i in props) {
        if (props[i] in obj) {
  
          // return the property name as a string
          if (elem === false) {
            return props[i];
          }
  
          item = obj[props[i]];
  
          // let's bind a function
          if (is(item, 'function')) {
            // bind to obj unless overriden
            return fnBind(item, elem || obj);
          }
  
          // return the unbound function or obj or value
          return item;
        }
      }
      return false;
    }
  
    ;
  
    /**
     * Create our "modernizr" element that we do most feature tests on.
     *
     * @access private
     */
  
    var modElem = {
      elem: createElement('modernizr')
    };
  
    // Clean up this element
    Modernizr._q.push(function() {
      delete modElem.elem;
    });
  
    
  
    var mStyle = {
      style: modElem.elem.style
    };
  
    // kill ref for gc, must happen before mod.elem is removed, so we unshift on to
    // the front of the queue.
    Modernizr._q.unshift(function() {
      delete mStyle.style;
    });
  
    
  
  
    /**
     * wrapper around getComputedStyle, to fix issues with Firefox returning null when
     * called inside of a hidden iframe
     *
     * @access private
     * @function computedStyle
     * @param {HTMLElement|SVGElement} - The element we want to find the computed styles of
     * @param {string|null} [pseudoSelector]- An optional pseudo element selector (e.g. :before), of null if none
     * @returns {CSSStyleDeclaration}
     */
  
    function computedStyle(elem, pseudo, prop) {
      var result;
  
      if ('getComputedStyle' in window) {
        result = getComputedStyle.call(window, elem, pseudo);
        var console = window.console;
  
        if (result !== null) {
          if (prop) {
            result = result.getPropertyValue(prop);
          }
        } else {
          if (console) {
            var method = console.error ? 'error' : 'log';
            console[method].call(console, 'getComputedStyle returning null, its possible modernizr test results are inaccurate');
          }
        }
      } else {
        result = !pseudo && elem.currentStyle && elem.currentStyle[prop];
      }
  
      return result;
    }
  
    ;
  
    /**
     * nativeTestProps allows for us to use native feature detection functionality if available.
     * some prefixed form, or false, in the case of an unsupported rule
     *
     * @access private
     * @function nativeTestProps
     * @param {array} props - An array of property names
     * @param {string} value - A string representing the value we want to check via @supports
     * @returns {boolean|undefined} A boolean when @supports exists, undefined otherwise
     */
  
    // Accepts a list of property names and a single value
    // Returns `undefined` if native detection not available
    function nativeTestProps(props, value) {
      var i = props.length;
      // Start with the JS API: http://www.w3.org/TR/css3-conditional/#the-css-interface
      if ('CSS' in window && 'supports' in window.CSS) {
        // Try every prefixed variant of the property
        while (i--) {
          if (window.CSS.supports(domToCSS(props[i]), value)) {
            return true;
          }
        }
        return false;
      }
      // Otherwise fall back to at-rule (for Opera 12.x)
      else if ('CSSSupportsRule' in window) {
        // Build a condition string for every prefixed variant
        var conditionText = [];
        while (i--) {
          conditionText.push('(' + domToCSS(props[i]) + ':' + value + ')');
        }
        conditionText = conditionText.join(' or ');
        return injectElementWithStyles('@supports (' + conditionText + ') { #modernizr { position: absolute; } }', function(node) {
          return computedStyle(node, null, 'position') == 'absolute';
        });
      }
      return undefined;
    }
    ;
  
    // testProps is a generic CSS / DOM property test.
  
    // In testing support for a given CSS property, it's legit to test:
    //    `elem.style[styleName] !== undefined`
    // If the property is supported it will return an empty string,
    // if unsupported it will return undefined.
  
    // We'll take advantage of this quick test and skip setting a style
    // on our modernizr element, but instead just testing undefined vs
    // empty string.
  
    // Property names can be provided in either camelCase or kebab-case.
  
    function testProps(props, prefixed, value, skipValueTest) {
      skipValueTest = is(skipValueTest, 'undefined') ? false : skipValueTest;
  
      // Try native detect first
      if (!is(value, 'undefined')) {
        var result = nativeTestProps(props, value);
        if (!is(result, 'undefined')) {
          return result;
        }
      }
  
      // Otherwise do it properly
      var afterInit, i, propsLength, prop, before;
  
      // If we don't have a style element, that means we're running async or after
      // the core tests, so we'll need to create our own elements to use
  
      // inside of an SVG element, in certain browsers, the `style` element is only
      // defined for valid tags. Therefore, if `modernizr` does not have one, we
      // fall back to a less used element and hope for the best.
      // for strict XHTML browsers the hardly used samp element is used
      var elems = ['modernizr', 'tspan', 'samp'];
      while (!mStyle.style && elems.length) {
        afterInit = true;
        mStyle.modElem = createElement(elems.shift());
        mStyle.style = mStyle.modElem.style;
      }
  
      // Delete the objects if we created them.
      function cleanElems() {
        if (afterInit) {
          delete mStyle.style;
          delete mStyle.modElem;
        }
      }
  
      propsLength = props.length;
      for (i = 0; i < propsLength; i++) {
        prop = props[i];
        before = mStyle.style[prop];
  
        if (contains(prop, '-')) {
          prop = cssToDOM(prop);
        }
  
        if (mStyle.style[prop] !== undefined) {
  
          // If value to test has been passed in, do a set-and-check test.
          // 0 (integer) is a valid property value, so check that `value` isn't
          // undefined, rather than just checking it's truthy.
          if (!skipValueTest && !is(value, 'undefined')) {
  
            // Needs a try catch block because of old IE. This is slow, but will
            // be avoided in most cases because `skipValueTest` will be used.
            try {
              mStyle.style[prop] = value;
            } catch (e) {}
  
            // If the property value has changed, we assume the value used is
            // supported. If `value` is empty string, it'll fail here (because
            // it hasn't changed), which matches how browsers have implemented
            // CSS.supports()
            if (mStyle.style[prop] != before) {
              cleanElems();
              return prefixed == 'pfx' ? prop : true;
            }
          }
          // Otherwise just return true, or the property name if this is a
          // `prefixed()` call
          else {
            cleanElems();
            return prefixed == 'pfx' ? prop : true;
          }
        }
      }
      cleanElems();
      return false;
    }
  
    ;
  
    /**
     * testProp() investigates whether a given style property is recognized
     * Property names can be provided in either camelCase or kebab-case.
     *
     * @memberof Modernizr
     * @name Modernizr.testProp
     * @access public
     * @optionName Modernizr.testProp()
     * @optionProp testProp
     * @function testProp
     * @param {string} prop - Name of the CSS property to check
     * @param {string} [value] - Name of the CSS value to check
     * @param {boolean} [useValue] - Whether or not to check the value if @supports isn't supported
     * @returns {boolean}
     * @example
     *
     * Just like [testAllProps](#modernizr-testallprops), only it does not check any vendor prefixed
     * version of the string.
     *
     * Note that the property name must be provided in camelCase (e.g. boxSizing not box-sizing)
     *
     * ```js
     * Modernizr.testProp('pointerEvents')  // true
     * ```
     *
     * You can also provide a value as an optional second argument to check if a
     * specific value is supported
     *
     * ```js
     * Modernizr.testProp('pointerEvents', 'none') // true
     * Modernizr.testProp('pointerEvents', 'penguin') // false
     * ```
     */
  
    var testProp = ModernizrProto.testProp = function(prop, value, useValue) {
      return testProps([prop], undefined, value, useValue);
    };
    
  
    /**
     * testPropsAll tests a list of DOM properties we want to check against.
     * We specify literally ALL possible (known and/or likely) properties on
     * the element including the non-vendor prefixed one, for forward-
     * compatibility.
     *
     * @access private
     * @function testPropsAll
     * @param {string} prop - A string of the property to test for
     * @param {string|object} [prefixed] - An object to check the prefixed properties on. Use a string to skip
     * @param {HTMLElement|SVGElement} [elem] - An element used to test the property and value against
     * @param {string} [value] - A string of a css value
     * @param {boolean} [skipValueTest] - An boolean representing if you want to test if value sticks when set
     * @returns {false|string} returns the string version of the property, or false if it is unsupported
     */
    function testPropsAll(prop, prefixed, elem, value, skipValueTest) {
  
      var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
        props = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');
  
      // did they call .prefixed('boxSizing') or are we just testing a prop?
      if (is(prefixed, 'string') || is(prefixed, 'undefined')) {
        return testProps(props, prefixed, value, skipValueTest);
  
        // otherwise, they called .prefixed('requestAnimationFrame', window[, elem])
      } else {
        props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
        return testDOMProps(props, prefixed, elem);
      }
    }
  
    // Modernizr.testAllProps() investigates whether a given style property,
    // or any of its vendor-prefixed variants, is recognized
    //
    // Note that the property names must be provided in the camelCase variant.
    // Modernizr.testAllProps('boxSizing')
    ModernizrProto.testAllProps = testPropsAll;
  
    
  
    /**
     * prefixed returns the prefixed or nonprefixed property name variant of your input
     *
     * @memberof Modernizr
     * @name Modernizr.prefixed
     * @optionName Modernizr.prefixed()
     * @optionProp prefixed
     * @access public
     * @function prefixed
     * @param {string} prop - String name of the property to test for
     * @param {object} [obj] - An object to test for the prefixed properties on
     * @param {HTMLElement} [elem] - An element used to test specific properties against
     * @returns {string|false} The string representing the (possibly prefixed) valid
     * version of the property, or `false` when it is unsupported.
     * @example
     *
     * Modernizr.prefixed takes a string css value in the DOM style camelCase (as
     * opposed to the css style kebab-case) form and returns the (possibly prefixed)
     * version of that property that the browser actually supports.
     *
     * For example, in older Firefox...
     * ```js
     * prefixed('boxSizing')
     * ```
     * returns 'MozBoxSizing'
     *
     * In newer Firefox, as well as any other browser that support the unprefixed
     * version would simply return `boxSizing`. Any browser that does not support
     * the property at all, it will return `false`.
     *
     * By default, prefixed is checked against a DOM element. If you want to check
     * for a property on another object, just pass it as a second argument
     *
     * ```js
     * var rAF = prefixed('requestAnimationFrame', window);
     *
     * raf(function() {
     *  renderFunction();
     * })
     * ```
     *
     * Note that this will return _the actual function_ - not the name of the function.
     * If you need the actual name of the property, pass in `false` as a third argument
     *
     * ```js
     * var rAFProp = prefixed('requestAnimationFrame', window, false);
     *
     * rafProp === 'WebkitRequestAnimationFrame' // in older webkit
     * ```
     *
     * One common use case for prefixed is if you're trying to determine which transition
     * end event to bind to, you might do something like...
     * ```js
     * var transEndEventNames = {
     *     'WebkitTransition' : 'webkitTransitionEnd', * Saf 6, Android Browser
     *     'MozTransition'    : 'transitionend',       * only for FF < 15
     *     'transition'       : 'transitionend'        * IE10, Opera, Chrome, FF 15+, Saf 7+
     * };
     *
     * var transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];
     * ```
     *
     * If you want a similar lookup, but in kebab-case, you can use [prefixedCSS](#modernizr-prefixedcss).
     */
  
    var prefixed = ModernizrProto.prefixed = function(prop, obj, elem) {
      if (prop.indexOf('@') === 0) {
        return atRule(prop);
      }
  
      if (prop.indexOf('-') != -1) {
        // Convert kebab-case to camelCase
        prop = cssToDOM(prop);
      }
      if (!obj) {
        return testPropsAll(prop, 'pfx');
      } else {
        // Testing DOM property e.g. Modernizr.prefixed('requestAnimationFrame', window) // 'mozRequestAnimationFrame'
        return testPropsAll(prop, obj, elem);
      }
    };
  
    
  
    /**
     * prefixedCSS is just like [prefixed](#modernizr-prefixed), but the returned values are in
     * kebab-case (e.g. `box-sizing`) rather than camelCase (boxSizing).
     *
     * @memberof Modernizr
     * @name Modernizr.prefixedCSS
     * @optionName Modernizr.prefixedCSS()
     * @optionProp prefixedCSS
     * @access public
     * @function prefixedCSS
     * @param {string} prop - String name of the property to test for
     * @returns {string|false} The string representing the (possibly prefixed)
     * valid version of the property, or `false` when it is unsupported.
     * @example
     *
     * `Modernizr.prefixedCSS` is like `Modernizr.prefixed`, but returns the result
     * in hyphenated form
     *
     * ```js
     * Modernizr.prefixedCSS('transition') // '-moz-transition' in old Firefox
     * ```
     *
     * Since it is only useful for CSS style properties, it can only be tested against
     * an HTMLElement.
     *
     * Properties can be passed as both the DOM style camelCase or CSS style kebab-case.
     */
  
    var prefixedCSS = ModernizrProto.prefixedCSS = function(prop) {
      var prefixedProp = prefixed(prop);
      return prefixedProp && domToCSS(prefixedProp);
    };
    
  
    /**
     * testAllProps determines whether a given CSS property is supported in the browser
     *
     * @memberof Modernizr
     * @name Modernizr.testAllProps
     * @optionName Modernizr.testAllProps()
     * @optionProp testAllProps
     * @access public
     * @function testAllProps
     * @param {string} prop - String naming the property to test (either camelCase or kebab-case)
     * @param {string} [value] - String of the value to test
     * @param {boolean} [skipValueTest=false] - Whether to skip testing that the value is supported when using non-native detection
     * @example
     *
     * testAllProps determines whether a given CSS property, in some prefixed form,
     * is supported by the browser.
     *
     * ```js
     * testAllProps('boxSizing')  // true
     * ```
     *
     * It can optionally be given a CSS value in string form to test if a property
     * value is valid
     *
     * ```js
     * testAllProps('display', 'block') // true
     * testAllProps('display', 'penguin') // false
     * ```
     *
     * A boolean can be passed as a third parameter to skip the value check when
     * native detection (@supports) isn't available.
     *
     * ```js
     * testAllProps('shapeOutside', 'content-box', true);
     * ```
     */
  
    function testAllProps(prop, value, skipValueTest) {
      return testPropsAll(prop, undefined, undefined, value, skipValueTest);
    }
    ModernizrProto.testAllProps = testAllProps;
    
  /*!
  {
    "name": "CSS Object Fit",
    "caniuse": "object-fit",
    "property": "objectfit",
    "tags": ["css"],
    "builderAliases": ["css_objectfit"],
    "notes": [{
      "name": "Opera Article on Object Fit",
      "href": "https://dev.opera.com/articles/css3-object-fit-object-position/"
    }]
  }
  !*/
  
    Modernizr.addTest('objectfit', !!prefixed('objectFit'), {aliases: ['object-fit']});
  
  
    // Run each test
    testRunner();
  
    // Remove the "no-js" class if it exists
    setClasses(classes);
  
    delete ModernizrProto.addTest;
    delete ModernizrProto.addAsyncTest;
  
    // Run the things that are supposed to run after the tests
    for (var i = 0; i < Modernizr._q.length; i++) {
      Modernizr._q[i]();
    }
  
    // Leak Modernizr namespace
    window.Modernizr = Modernizr;
  
  
  ;
  
  })(window, document);
(()=>{var l;(function(i){i[i.LESS_THAN=0]="LESS_THAN",i[i.LESS_OR_EQUAL=1]="LESS_OR_EQUAL",i[i.GREATER_THAN=2]="GREATER_THAN",i[i.GREATER_OR_EQUAL=3]="GREATER_OR_EQUAL"})(l||(l={}));var d;(function(i){i[i.SizeQuery=0]="SizeQuery",i[i.ContainerConditionConjunction=1]="ContainerConditionConjunction",i[i.ContainerConditionDisjunction=2]="ContainerConditionDisjunction",i[i.ContainerConditionNegation=3]="ContainerConditionNegation"})(d||(d={}));function E(){return Array.from({length:16},()=>Math.floor(Math.random()*256).toString(16)).join("")}function b(e){switch(e.toLowerCase()){case"inlinesize":return"inlineSize";case"blocksize":return"blockSize";case"width":return"inlineSize";case"height":return"blockSize";default:throw Error(`Unknown feature name ${e} in container query`)}}function U(e,n){let t=n[b(e.feature)];switch(e.comparator){case 3:return t>=e.threshold;case 2:return t>e.threshold;case 1:return t<=e.threshold;case 0:return t<e.threshold}}function h(e,n){switch(e.type){case 1:return h(e.left,n)&&h(e.right,n);case 2:return h(e.left,n)||h(e.right,n);case 3:return!h(e.right,n);case 0:return U(e,n);default:throw Error("wtf?")}}function j(e,n){let t;if("borderBoxSize"in n)t=n.borderBoxSize?.[0]??n.borderBoxSize;else{let r=getComputedStyle(n.target);t={blockSize:n.contentRect.height,inlineSize:n.contentRect.width},t.blockSize+=parseInt(r.paddingBlockStart.slice(0,-2))+parseInt(r.paddingBlockEnd.slice(0,-2)),t.inlineSize+=parseInt(r.paddingInlineStart.slice(0,-2))+parseInt(r.paddingInlineEnd.slice(0,-2))}return h(e,t)}function q(e,n){for(;e;)if(e=e.parentElement,!!m.has(e)&&!(n&&!m.get(e).includes(n)))return e;return null}var m=new WeakMap;function g(e,n){w.observe(e),m.has(e)||m.set(e,[]),m.get(e).push(n)}var A=[];function D(e){A.push(e)}var w=new ResizeObserver(e=>{let n=new Map(e.map(t=>[t.target,t]));for(let t of A)for(let{selector:r}of t.rules){let i=document.querySelectorAll(r);for(let a of i){let u=q(a,t.name);if(!u||!n.has(u))continue;let f=n.get(u);a.classList.toggle(t.className,j(t.condition,f))}}}),R=[],$=new MutationObserver(e=>{for(let n of e){for(let t of n.removedNodes)t instanceof HTMLElement&&w.unobserve(t);for(let t of n.addedNodes)if(t instanceof HTMLElement)for(let r of R){t.matches(r.selector)&&g(t,r.name);for(let i of t.querySelectorAll(r.selector))g(i,r.name)}}});$.observe(document.documentElement,{childList:!0,subtree:!0});function C(e,n){let t={sheetSrc:e,index:0,name:n};for(;t.index<t.sheetSrc.length&&(o(t),!(t.index>=t.sheetSrc.length));){if(c("/*",t)){for(;c("/*",t);)W(t),o(t);continue}if(c("@container",t)){let{query:r,startIndex:i,endIndex:a}=Y(t),u=Z(r);L(i,a,u,t),D(r)}else{let r=Q(t);if(!r)continue;G(r,t)}}return n&&(t.sheetSrc=t.sheetSrc.replace(/url\(["']*([^)"']+)["']*\)/g,(r,i)=>`url(${new URL(i,n)})`)),t.sheetSrc}function G(e,n){let t=e.block.contents.includes("container-"),r=e.block.contents.includes("container:");if(!t&&!r)return;let i,a;t&&(i=/container-name\s*:([^;}]+)/.exec(e.block.contents)?.[1].trim(),e.block.contents=e.block.contents.replace("container-type","contain")),r&&([a,i]=(/container\s*:([^;}]+)/.exec(e.block.contents)?.[1]).split("/").map(f=>f.trim()),e.block.contents=e.block.contents.replace(/container: ([^;}]+)/,`contain: ${a};`)),i||(i=E()),L(e.block.startIndex,e.block.endIndex,e.block.contents,n),R.push({name:i,selector:e.selector});for(let u of document.querySelectorAll(e.selector))g(u,i)}function L(e,n,t,r){if(r.sheetSrc=r.sheetSrc.slice(0,e)+t+r.sheetSrc.slice(n),r.index>=n){let i=r.index-n;r.index=e+t.length+i}}function W(e){s(e,"/*"),z("*/",e),s(e,"*/")}function k(e){if(e.index++,e.index>e.sheetSrc.length)throw S(e,"Advanced beyond the end")}function z(e,n){let t=n.index;for(;!c(e,n);)k(n);return n.sheetSrc.slice(t,n.index)}function c(e,n){return n.sheetSrc.substr(n.index,e.length)==e}function B(e){let n=e.index;if(z("{",e),n===e.index)throw Error("Empty selector");return e.sheetSrc.slice(n,e.index)}function Q(e){let n=e.index,t=B(e);if(!t)return;let r=K(e),i=e.index;return{selector:t,block:r,startIndex:n,endIndex:i}}function F(e){return e.name?e.name:"<anonymous file>"}function S(e,n){return Error(`(${F(e)}): ${n}`)}function s(e,n){if(e.sheetSrc.substr(e.index,n.length)!=n)throw S(e,`Did not find expected sequence ${n}`);e.index+=n.length}var P=/\s*/g;function o(e){P.lastIndex=e.index;let n=P.exec(e.sheetSrc);n&&(e.index+=n[0].length)}function N(e){return e.sheetSrc[e.index]}var I=/[\w\\\@_-]+/g;function y(e){I.lastIndex=e.index;let n=I.exec(e.sheetSrc);if(!n)throw S(e,"Expected an identifier");return e.index+=n[0].length,n[0]}function J(e){return y(e).toLowerCase()}var _=/[0-9.]*/g;function M(e){_.lastIndex=e.index;let n=_.exec(e.sheetSrc);if(!n)throw S(e,"Expected a number");e.index+=n[0].length,s(e,"px");let t=parseFloat(n[0]);if(Number.isNaN(t))throw S(e,`${n[0]} is not a valid number`);return t}function K(e){let n=e.index;s(e,"{");let t=1;for(;t!=0;)e.sheetSrc[e.index]==="{"?t++:e.sheetSrc[e.index]==="}"&&t--,k(e);let r=e.index,i=e.sheetSrc.slice(n,r);return{startIndex:n,endIndex:r,contents:i}}function V(e){let n=J(e);o(e),s(e,":"),o(e);let t=M(e);o(e),s(e,")"),o(e);let r;if(n.startsWith("min-"))r=3;else if(n.startsWith("max-"))r=1;else throw Error(`Unknown legacy container query ${n}`);return{type:0,feature:b(n.slice(4)),comparator:r,threshold:t}}function X(e){if(c(">=",e))return s(e,">="),3;if(c(">",e))return s(e,">"),2;if(c("<=",e))return s(e,"<="),1;if(c("<",e))return s(e,"<"),0;throw Error("Unknown comparator")}function O(e){if(s(e,"("),c("(",e)){let i=v(e);return s(e,")"),i}if(o(e),c("min-",e)||c("max-",e))return V(e);let n=y(e).toLowerCase();o(e);let t=X(e);o(e);let r=M(e);return o(e),s(e,")"),o(e),{type:0,feature:n,comparator:t,threshold:r}}function T(e){if(o(e),c("(",e))return O(e);if(c("size",e))return s(e,"size"),o(e),O(e);throw c("style",e)?Error("Style query not implement yet"):Error("Unknown container query type")}function x(e){return c("not",e)?(s(e,"not"),o(e),{type:3,right:T(e)}):T(e)}function v(e){let n=x(e);for(;;)if(c("and",e)){s(e,"and"),o(e);let t=x(e);o(e),n={type:1,left:n,right:t}}else if(c("or",e)){s(e,"or"),o(e);let t=x(e);o(e),n={type:2,left:n,right:t}}else break;return n}function Y(e){let n=e.index;s(e,"@container"),o(e);let t="";N(e)!=="("&&!c("size",e)&&!c("style",e)&&(t=y(e),o(e));let r=v(e);o(e),s(e,"{"),o(e);let i=[];for(;N(e)!=="}";)i.push(Q(e)),o(e);s(e,"}");let a=e.index;o(e);let u=`cq_${E()}`;return{query:{condition:r,className:u,name:t,rules:i},startIndex:n,endIndex:a}}function Z(e){return e.rules.map(n=>`:is(${n.selector}).${e.className} ${n.block.contents}`).join(`
`)}function p(){new MutationObserver(r=>{for(let i of r)for(let a of i.addedNodes)a instanceof HTMLStyleElement&&n(a),a instanceof HTMLLinkElement&&t(a)}).observe(document.documentElement,{childList:!0,subtree:!0});function n(r){if(r.innerHTML.trim().length===0)return;let i=C(r.innerHTML);r.innerHTML=i}async function t(r){if(r.rel!=="stylesheet")return;let i=new URL(r.href,document.baseURI);if(i.origin!==location.origin)return;let a=await fetch(i.toString()).then(H=>H.text()),u=C(a,i.toString()),f=new Blob([u],{type:"text/css"});r.href=URL.createObjectURL(f)}document.querySelectorAll("style").forEach(r=>n(r)),document.querySelectorAll("link").forEach(r=>t(r))}var ee="container"in document.documentElement.style;ee||p();})();
/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.6.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem && elem.namespaceURI,
		docElem = elem && ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						// Support: Chrome 86+
						// In Chrome, if an element having a focusout handler is blurred by
						// clicking outside of it, it invokes the handler synchronously. If
						// that handler calls `.remove()` on the element, the data is cleared,
						// leaving `result` undefined. We need to guard against this.
						return result && result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur as it's already being fired
		// in leverageNative.
		_default: function() {
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(t=t||self).barba=n()}(this,(function(){function t(t,n){for(var r=0;r<n.length;r++){var e=n[r];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(t,e.key,e)}}function n(n,r,e){return r&&t(n.prototype,r),e&&t(n,e),n}function r(){return(r=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e])}return t}).apply(this,arguments)}function e(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n}function i(t){return(i=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function o(t,n){return(o=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function u(t,n,r){return(u=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}()?Reflect.construct:function(t,n,r){var e=[null];e.push.apply(e,n);var i=new(Function.bind.apply(t,e));return r&&o(i,r.prototype),i}).apply(null,arguments)}function f(t){var n="function"==typeof Map?new Map:void 0;return(f=function(t){if(null===t||-1===Function.toString.call(t).indexOf("[native code]"))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(t))return n.get(t);n.set(t,r)}function r(){return u(t,arguments,i(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),o(r,t)})(t)}function s(t,n){try{var r=t()}catch(t){return n(t)}return r&&r.then?r.then(void 0,n):r}"undefined"!=typeof Symbol&&(Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator"))),"undefined"!=typeof Symbol&&(Symbol.asyncIterator||(Symbol.asyncIterator=Symbol("Symbol.asyncIterator")));var c,a="2.9.7",h=function(){};!function(t){t[t.off=0]="off",t[t.error=1]="error",t[t.warning=2]="warning",t[t.info=3]="info",t[t.debug=4]="debug"}(c||(c={}));var v=c.off,l=function(){function t(t){this.t=t}t.getLevel=function(){return v},t.setLevel=function(t){return v=c[t]};var n=t.prototype;return n.error=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.error,c.error,n)},n.warn=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.warn,c.warning,n)},n.info=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.info,c.info,n)},n.debug=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.log,c.debug,n)},n.i=function(n,r,e){r<=t.getLevel()&&n.apply(console,["["+this.t+"] "].concat(e))},t}(),d=O,m=E,p=g,w=x,b=T,y="/",P=new RegExp(["(\\\\.)","(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"),"g");function g(t,n){for(var r,e=[],i=0,o=0,u="",f=n&&n.delimiter||y,s=n&&n.whitelist||void 0,c=!1;null!==(r=P.exec(t));){var a=r[0],h=r[1],v=r.index;if(u+=t.slice(o,v),o=v+a.length,h)u+=h[1],c=!0;else{var l="",d=r[2],m=r[3],p=r[4],w=r[5];if(!c&&u.length){var b=u.length-1,g=u[b];(!s||s.indexOf(g)>-1)&&(l=g,u=u.slice(0,b))}u&&(e.push(u),u="",c=!1);var E=m||p,x=l||f;e.push({name:d||i++,prefix:l,delimiter:x,optional:"?"===w||"*"===w,repeat:"+"===w||"*"===w,pattern:E?A(E):"[^"+k(x===f?x:x+f)+"]+?"})}}return(u||o<t.length)&&e.push(u+t.substr(o)),e}function E(t,n){return function(r,e){var i=t.exec(r);if(!i)return!1;for(var o=i[0],u=i.index,f={},s=e&&e.decode||decodeURIComponent,c=1;c<i.length;c++)if(void 0!==i[c]){var a=n[c-1];f[a.name]=a.repeat?i[c].split(a.delimiter).map((function(t){return s(t,a)})):s(i[c],a)}return{path:o,index:u,params:f}}}function x(t,n){for(var r=new Array(t.length),e=0;e<t.length;e++)"object"==typeof t[e]&&(r[e]=new RegExp("^(?:"+t[e].pattern+")$",R(n)));return function(n,e){for(var i="",o=e&&e.encode||encodeURIComponent,u=!e||!1!==e.validate,f=0;f<t.length;f++){var s=t[f];if("string"!=typeof s){var c,a=n?n[s.name]:void 0;if(Array.isArray(a)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but got array');if(0===a.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var h=0;h<a.length;h++){if(c=o(a[h],s),u&&!r[f].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'"');i+=(0===h?s.prefix:s.delimiter)+c}}else if("string"!=typeof a&&"number"!=typeof a&&"boolean"!=typeof a){if(!s.optional)throw new TypeError('Expected "'+s.name+'" to be '+(s.repeat?"an array":"a string"))}else{if(c=o(String(a),s),u&&!r[f].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but got "'+c+'"');i+=s.prefix+c}}else i+=s}return i}}function k(t){return t.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}function A(t){return t.replace(/([=!:$/()])/g,"\\$1")}function R(t){return t&&t.sensitive?"":"i"}function T(t,n,r){for(var e=(r=r||{}).strict,i=!1!==r.start,o=!1!==r.end,u=r.delimiter||y,f=[].concat(r.endsWith||[]).map(k).concat("$").join("|"),s=i?"^":"",c=0;c<t.length;c++){var a=t[c];if("string"==typeof a)s+=k(a);else{var h=a.repeat?"(?:"+a.pattern+")(?:"+k(a.delimiter)+"(?:"+a.pattern+"))*":a.pattern;n&&n.push(a),s+=a.optional?a.prefix?"(?:"+k(a.prefix)+"("+h+"))?":"("+h+")?":k(a.prefix)+"("+h+")"}}if(o)e||(s+="(?:"+k(u)+")?"),s+="$"===f?"$":"(?="+f+")";else{var v=t[t.length-1],l="string"==typeof v?v[v.length-1]===u:void 0===v;e||(s+="(?:"+k(u)+"(?="+f+"))?"),l||(s+="(?="+k(u)+"|"+f+")")}return new RegExp(s,R(r))}function O(t,n,r){return t instanceof RegExp?function(t,n){if(!n)return t;var r=t.source.match(/\((?!\?)/g);if(r)for(var e=0;e<r.length;e++)n.push({name:e,prefix:null,delimiter:null,optional:!1,repeat:!1,pattern:null});return t}(t,n):Array.isArray(t)?function(t,n,r){for(var e=[],i=0;i<t.length;i++)e.push(O(t[i],n,r).source);return new RegExp("(?:"+e.join("|")+")",R(r))}(t,n,r):function(t,n,r){return T(g(t,r),n,r)}(t,n,r)}d.match=function(t,n){var r=[];return E(O(t,r,n),r)},d.regexpToFunction=m,d.parse=p,d.compile=function(t,n){return x(g(t,n),n)},d.tokensToFunction=w,d.tokensToRegExp=b;var S={container:"container",history:"history",namespace:"namespace",prefix:"data-barba",prevent:"prevent",wrapper:"wrapper"},j=new(function(){function t(){this.o=S,this.u=new DOMParser}var n=t.prototype;return n.toString=function(t){return t.outerHTML},n.toDocument=function(t){return this.u.parseFromString(t,"text/html")},n.toElement=function(t){var n=document.createElement("div");return n.innerHTML=t,n},n.getHtml=function(t){return void 0===t&&(t=document),this.toString(t.documentElement)},n.getWrapper=function(t){return void 0===t&&(t=document),t.querySelector("["+this.o.prefix+'="'+this.o.wrapper+'"]')},n.getContainer=function(t){return void 0===t&&(t=document),t.querySelector("["+this.o.prefix+'="'+this.o.container+'"]')},n.removeContainer=function(t){document.body.contains(t)&&t.parentNode.removeChild(t)},n.addContainer=function(t,n){var r=this.getContainer();r?this.s(t,r):n.appendChild(t)},n.getNamespace=function(t){void 0===t&&(t=document);var n=t.querySelector("["+this.o.prefix+"-"+this.o.namespace+"]");return n?n.getAttribute(this.o.prefix+"-"+this.o.namespace):null},n.getHref=function(t){if(t.tagName&&"a"===t.tagName.toLowerCase()){if("string"==typeof t.href)return t.href;var n=t.getAttribute("href")||t.getAttribute("xlink:href");if(n)return this.resolveUrl(n.baseVal||n)}return null},n.resolveUrl=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];var e=n.length;if(0===e)throw new Error("resolveUrl requires at least one argument; got none.");var i=document.createElement("base");if(i.href=arguments[0],1===e)return i.href;var o=document.getElementsByTagName("head")[0];o.insertBefore(i,o.firstChild);for(var u,f=document.createElement("a"),s=1;s<e;s++)f.href=arguments[s],i.href=u=f.href;return o.removeChild(i),u},n.s=function(t,n){n.parentNode.insertBefore(t,n.nextSibling)},t}()),M=new(function(){function t(){this.h=[],this.v=-1}var e=t.prototype;return e.init=function(t,n){this.l="barba";var r={ns:n,scroll:{x:window.scrollX,y:window.scrollY},url:t};this.h.push(r),this.v=0;var e={from:this.l,index:0,states:[].concat(this.h)};window.history&&window.history.replaceState(e,"",t)},e.change=function(t,n,r){if(r&&r.state){var e=r.state,i=e.index;n=this.m(this.v-i),this.replace(e.states),this.v=i}else this.add(t,n);return n},e.add=function(t,n){var r=this.size,e=this.p(n),i={ns:"tmp",scroll:{x:window.scrollX,y:window.scrollY},url:t};this.h.push(i),this.v=r;var o={from:this.l,index:r,states:[].concat(this.h)};switch(e){case"push":window.history&&window.history.pushState(o,"",t);break;case"replace":window.history&&window.history.replaceState(o,"",t)}},e.update=function(t,n){var e=n||this.v,i=r({},this.get(e),{},t);this.set(e,i)},e.remove=function(t){t?this.h.splice(t,1):this.h.pop(),this.v--},e.clear=function(){this.h=[],this.v=-1},e.replace=function(t){this.h=t},e.get=function(t){return this.h[t]},e.set=function(t,n){return this.h[t]=n},e.p=function(t){var n="push",r=t,e=S.prefix+"-"+S.history;return r.hasAttribute&&r.hasAttribute(e)&&(n=r.getAttribute(e)),n},e.m=function(t){return Math.abs(t)>1?t>0?"forward":"back":0===t?"popstate":t>0?"back":"forward"},n(t,[{key:"current",get:function(){return this.h[this.v]}},{key:"state",get:function(){return this.h[this.h.length-1]}},{key:"previous",get:function(){return this.v<1?null:this.h[this.v-1]}},{key:"size",get:function(){return this.h.length}}]),t}()),L=function(t,n){try{var r=function(){if(!n.next.html)return Promise.resolve(t).then((function(t){var r=n.next;if(t){var e=j.toElement(t);r.namespace=j.getNamespace(e),r.container=j.getContainer(e),r.html=t,M.update({ns:r.namespace});var i=j.toDocument(t);document.title=i.title}}))}();return Promise.resolve(r&&r.then?r.then((function(){})):void 0)}catch(t){return Promise.reject(t)}},$=d,_={__proto__:null,update:L,nextTick:function(){return new Promise((function(t){window.requestAnimationFrame(t)}))},pathToRegexp:$},q=function(){return window.location.origin},B=function(t){return void 0===t&&(t=window.location.href),U(t).port},U=function(t){var n,r=t.match(/:\d+/);if(null===r)/^http/.test(t)&&(n=80),/^https/.test(t)&&(n=443);else{var e=r[0].substring(1);n=parseInt(e,10)}var i,o=t.replace(q(),""),u={},f=o.indexOf("#");f>=0&&(i=o.slice(f+1),o=o.slice(0,f));var s=o.indexOf("?");return s>=0&&(u=D(o.slice(s+1)),o=o.slice(0,s)),{hash:i,path:o,port:n,query:u}},D=function(t){return t.split("&").reduce((function(t,n){var r=n.split("=");return t[r[0]]=r[1],t}),{})},F=function(t){return void 0===t&&(t=window.location.href),t.replace(/(\/#.*|\/|#.*)$/,"")},H={__proto__:null,getHref:function(){return window.location.href},getOrigin:q,getPort:B,getPath:function(t){return void 0===t&&(t=window.location.href),U(t).path},parse:U,parseQuery:D,clean:F};function I(t,n,r){return void 0===n&&(n=2e3),new Promise((function(e,i){var o=new XMLHttpRequest;o.onreadystatechange=function(){if(o.readyState===XMLHttpRequest.DONE)if(200===o.status)e(o.responseText);else if(o.status){var n={status:o.status,statusText:o.statusText};r(t,n),i(n)}},o.ontimeout=function(){var e=new Error("Timeout error ["+n+"]");r(t,e),i(e)},o.onerror=function(){var n=new Error("Fetch error");r(t,n),i(n)},o.open("GET",t),o.timeout=n,o.setRequestHeader("Accept","text/html,application/xhtml+xml,application/xml"),o.setRequestHeader("x-barba","yes"),o.send()}))}var C=function(t){return!!t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof t.then};function N(t,n){return void 0===n&&(n={}),function(){for(var r=arguments.length,e=new Array(r),i=0;i<r;i++)e[i]=arguments[i];var o=!1,u=new Promise((function(r,i){n.async=function(){return o=!0,function(t,n){t?i(t):r(n)}};var u=t.apply(n,e);o||(C(u)?u.then(r,i):r(u))}));return u}}var X=new(function(t){function n(){var n;return(n=t.call(this)||this).logger=new l("@barba/core"),n.all=["ready","page","reset","currentAdded","currentRemoved","nextAdded","nextRemoved","beforeOnce","once","afterOnce","before","beforeLeave","leave","afterLeave","beforeEnter","enter","afterEnter","after"],n.registered=new Map,n.init(),n}e(n,t);var r=n.prototype;return r.init=function(){var t=this;this.registered.clear(),this.all.forEach((function(n){t[n]||(t[n]=function(r,e){t.registered.has(n)||t.registered.set(n,new Set),t.registered.get(n).add({ctx:e||{},fn:r})})}))},r.do=function(t){for(var n=this,r=arguments.length,e=new Array(r>1?r-1:0),i=1;i<r;i++)e[i-1]=arguments[i];if(this.registered.has(t)){var o=Promise.resolve();return this.registered.get(t).forEach((function(t){o=o.then((function(){return N(t.fn,t.ctx).apply(void 0,e)}))})),o.catch((function(r){n.logger.debug("Hook error ["+t+"]"),n.logger.error(r)}))}return Promise.resolve()},r.clear=function(){var t=this;this.all.forEach((function(n){delete t[n]})),this.init()},r.help=function(){this.logger.info("Available hooks: "+this.all.join(","));var t=[];this.registered.forEach((function(n,r){return t.push(r)})),this.logger.info("Registered hooks: "+t.join(","))},n}(h)),z=function(){function t(t){if(this.P=[],"boolean"==typeof t)this.g=t;else{var n=Array.isArray(t)?t:[t];this.P=n.map((function(t){return $(t)}))}}return t.prototype.checkHref=function(t){if("boolean"==typeof this.g)return this.g;var n=U(t).path;return this.P.some((function(t){return null!==t.exec(n)}))},t}(),G=function(t){function n(n){var r;return(r=t.call(this,n)||this).k=new Map,r}e(n,t);var i=n.prototype;return i.set=function(t,n,r){return this.k.set(t,{action:r,request:n}),{action:r,request:n}},i.get=function(t){return this.k.get(t)},i.getRequest=function(t){return this.k.get(t).request},i.getAction=function(t){return this.k.get(t).action},i.has=function(t){return!this.checkHref(t)&&this.k.has(t)},i.delete=function(t){return this.k.delete(t)},i.update=function(t,n){var e=r({},this.k.get(t),{},n);return this.k.set(t,e),e},n}(z),Q=function(){return!window.history.pushState},W=function(t){return!t.el||!t.href},J=function(t){var n=t.event;return n.which>1||n.metaKey||n.ctrlKey||n.shiftKey||n.altKey},K=function(t){var n=t.el;return n.hasAttribute("target")&&"_blank"===n.target},V=function(t){var n=t.el;return void 0!==n.protocol&&window.location.protocol!==n.protocol||void 0!==n.hostname&&window.location.hostname!==n.hostname},Y=function(t){var n=t.el;return void 0!==n.port&&B()!==B(n.href)},Z=function(t){var n=t.el;return n.getAttribute&&"string"==typeof n.getAttribute("download")},tt=function(t){return t.el.hasAttribute(S.prefix+"-"+S.prevent)},nt=function(t){return Boolean(t.el.closest("["+S.prefix+"-"+S.prevent+'="all"]'))},rt=function(t){var n=t.href;return F(n)===F()&&B(n)===B()},et=function(t){function n(n){var r;return(r=t.call(this,n)||this).suite=[],r.tests=new Map,r.init(),r}e(n,t);var r=n.prototype;return r.init=function(){this.add("pushState",Q),this.add("exists",W),this.add("newTab",J),this.add("blank",K),this.add("corsDomain",V),this.add("corsPort",Y),this.add("download",Z),this.add("preventSelf",tt),this.add("preventAll",nt),this.add("sameUrl",rt,!1)},r.add=function(t,n,r){void 0===r&&(r=!0),this.tests.set(t,n),r&&this.suite.push(t)},r.run=function(t,n,r,e){return this.tests.get(t)({el:n,event:r,href:e})},r.checkLink=function(t,n,r){var e=this;return this.suite.some((function(i){return e.run(i,t,n,r)}))},n}(z),it=function(t){function n(r,e){var i;void 0===e&&(e="Barba error");for(var o=arguments.length,u=new Array(o>2?o-2:0),f=2;f<o;f++)u[f-2]=arguments[f];return(i=t.call.apply(t,[this].concat(u))||this).error=r,i.label=e,Error.captureStackTrace&&Error.captureStackTrace(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(i),n),i.name="BarbaError",i}return e(n,t),n}(f(Error)),ot=function(){function t(t){void 0===t&&(t=[]),this.logger=new l("@barba/core"),this.all=[],this.page=[],this.once=[],this.A=[{name:"namespace",type:"strings"},{name:"custom",type:"function"}],t&&(this.all=this.all.concat(t)),this.update()}var n=t.prototype;return n.add=function(t,n){switch(t){case"rule":this.A.splice(n.position||0,0,n.value);break;case"transition":default:this.all.push(n)}this.update()},n.resolve=function(t,n){var r=this;void 0===n&&(n={});var e=n.once?this.once:this.page;e=e.filter(n.self?function(t){return t.name&&"self"===t.name}:function(t){return!t.name||"self"!==t.name});var i=new Map,o=e.find((function(e){var o=!0,u={};return!(!n.self||"self"!==e.name)||(r.A.reverse().forEach((function(n){o&&(o=r.R(e,n,t,u),e.from&&e.to&&(o=r.R(e,n,t,u,"from")&&r.R(e,n,t,u,"to")),e.from&&!e.to&&(o=r.R(e,n,t,u,"from")),!e.from&&e.to&&(o=r.R(e,n,t,u,"to")))})),i.set(e,u),o)})),u=i.get(o),f=[];if(f.push(n.once?"once":"page"),n.self&&f.push("self"),u){var s,c=[o];Object.keys(u).length>0&&c.push(u),(s=this.logger).info.apply(s,["Transition found ["+f.join(",")+"]"].concat(c))}else this.logger.info("No transition found ["+f.join(",")+"]");return o},n.update=function(){var t=this;this.all=this.all.map((function(n){return t.T(n)})).sort((function(t,n){return t.priority-n.priority})).reverse().map((function(t){return delete t.priority,t})),this.page=this.all.filter((function(t){return void 0!==t.leave||void 0!==t.enter})),this.once=this.all.filter((function(t){return void 0!==t.once}))},n.R=function(t,n,r,e,i){var o=!0,u=!1,f=t,s=n.name,c=s,a=s,h=s,v=i?f[i]:f,l="to"===i?r.next:r.current;if(i?v&&v[s]:v[s]){switch(n.type){case"strings":default:var d=Array.isArray(v[c])?v[c]:[v[c]];l[c]&&-1!==d.indexOf(l[c])&&(u=!0),-1===d.indexOf(l[c])&&(o=!1);break;case"object":var m=Array.isArray(v[a])?v[a]:[v[a]];l[a]?(l[a].name&&-1!==m.indexOf(l[a].name)&&(u=!0),-1===m.indexOf(l[a].name)&&(o=!1)):o=!1;break;case"function":v[h](r)?u=!0:o=!1}u&&(i?(e[i]=e[i]||{},e[i][s]=f[i][s]):e[s]=f[s])}return o},n.O=function(t,n,r){var e=0;return(t[n]||t.from&&t.from[n]||t.to&&t.to[n])&&(e+=Math.pow(10,r),t.from&&t.from[n]&&(e+=1),t.to&&t.to[n]&&(e+=2)),e},n.T=function(t){var n=this;t.priority=0;var r=0;return this.A.forEach((function(e,i){r+=n.O(t,e.name,i+1)})),t.priority=r,t},t}(),ut=function(){function t(t){void 0===t&&(t=[]),this.logger=new l("@barba/core"),this.S=!1,this.store=new ot(t)}var r=t.prototype;return r.get=function(t,n){return this.store.resolve(t,n)},r.doOnce=function(t){var n=t.data,r=t.transition;try{var e=function(){i.S=!1},i=this,o=r||{};i.S=!0;var u=s((function(){return Promise.resolve(i.j("beforeOnce",n,o)).then((function(){return Promise.resolve(i.once(n,o)).then((function(){return Promise.resolve(i.j("afterOnce",n,o)).then((function(){}))}))}))}),(function(t){i.S=!1,i.logger.debug("Transition error [before/after/once]"),i.logger.error(t)}));return Promise.resolve(u&&u.then?u.then(e):e())}catch(t){return Promise.reject(t)}},r.doPage=function(t){var n=t.data,r=t.transition,e=t.page,i=t.wrapper;try{var o=function(t){if(u)return t;f.S=!1},u=!1,f=this,c=r||{},a=!0===c.sync||!1;f.S=!0;var h=s((function(){function t(){return Promise.resolve(f.j("before",n,c)).then((function(){var t=!1;function r(r){return t?r:Promise.resolve(f.remove(n)).then((function(){return Promise.resolve(f.j("after",n,c)).then((function(){}))}))}var o=function(){if(a)return s((function(){return Promise.resolve(f.add(n,i)).then((function(){return Promise.resolve(f.j("beforeLeave",n,c)).then((function(){return Promise.resolve(f.j("beforeEnter",n,c)).then((function(){return Promise.resolve(Promise.all([f.leave(n,c),f.enter(n,c)])).then((function(){return Promise.resolve(f.j("afterLeave",n,c)).then((function(){return Promise.resolve(f.j("afterEnter",n,c)).then((function(){}))}))}))}))}))}))}),(function(t){if(f.M(t))throw new it(t,"Transition error [sync]")}));var r=function(r){return t?r:s((function(){var t=function(){if(!1!==o)return Promise.resolve(f.add(n,i)).then((function(){return Promise.resolve(f.j("beforeEnter",n,c)).then((function(){return Promise.resolve(f.enter(n,c,o)).then((function(){return Promise.resolve(f.j("afterEnter",n,c)).then((function(){}))}))}))}))}();if(t&&t.then)return t.then((function(){}))}),(function(t){if(f.M(t))throw new it(t,"Transition error [before/after/enter]")}))},o=!1,u=s((function(){return Promise.resolve(f.j("beforeLeave",n,c)).then((function(){return Promise.resolve(Promise.all([f.leave(n,c),L(e,n)]).then((function(t){return t[0]}))).then((function(t){return o=t,Promise.resolve(f.j("afterLeave",n,c)).then((function(){}))}))}))}),(function(t){if(f.M(t))throw new it(t,"Transition error [before/after/leave]")}));return u&&u.then?u.then(r):r(u)}();return o&&o.then?o.then(r):r(o)}))}var r=function(){if(a)return Promise.resolve(L(e,n)).then((function(){}))}();return r&&r.then?r.then(t):t()}),(function(t){if(f.S=!1,t.name&&"BarbaError"===t.name)throw f.logger.debug(t.label),f.logger.error(t.error),t;throw f.logger.debug("Transition error [page]"),f.logger.error(t),t}));return Promise.resolve(h&&h.then?h.then(o):o(h))}catch(t){return Promise.reject(t)}},r.once=function(t,n){try{return Promise.resolve(X.do("once",t,n)).then((function(){return n.once?N(n.once,n)(t):Promise.resolve()}))}catch(t){return Promise.reject(t)}},r.leave=function(t,n){try{return Promise.resolve(X.do("leave",t,n)).then((function(){return n.leave?N(n.leave,n)(t):Promise.resolve()}))}catch(t){return Promise.reject(t)}},r.enter=function(t,n,r){try{return Promise.resolve(X.do("enter",t,n)).then((function(){return n.enter?N(n.enter,n)(t,r):Promise.resolve()}))}catch(t){return Promise.reject(t)}},r.add=function(t,n){try{return j.addContainer(t.next.container,n),X.do("nextAdded",t),Promise.resolve()}catch(t){return Promise.reject(t)}},r.remove=function(t){try{return j.removeContainer(t.current.container),X.do("currentRemoved",t),Promise.resolve()}catch(t){return Promise.reject(t)}},r.M=function(t){return t.message?!/Timeout error|Fetch error/.test(t.message):!t.status},r.j=function(t,n,r){try{return Promise.resolve(X.do(t,n,r)).then((function(){return r[t]?N(r[t],r)(n):Promise.resolve()}))}catch(t){return Promise.reject(t)}},n(t,[{key:"isRunning",get:function(){return this.S},set:function(t){this.S=t}},{key:"hasOnce",get:function(){return this.store.once.length>0}},{key:"hasSelf",get:function(){return this.store.all.some((function(t){return"self"===t.name}))}},{key:"shouldWait",get:function(){return this.store.all.some((function(t){return t.to&&!t.to.route||t.sync}))}}]),t}(),ft=function(){function t(t){var n=this;this.names=["beforeLeave","afterLeave","beforeEnter","afterEnter"],this.byNamespace=new Map,0!==t.length&&(t.forEach((function(t){n.byNamespace.set(t.namespace,t)})),this.names.forEach((function(t){X[t](n.L(t))})))}return t.prototype.L=function(t){var n=this;return function(r){var e=t.match(/enter/i)?r.next:r.current,i=n.byNamespace.get(e.namespace);return i&&i[t]?N(i[t],i)(r):Promise.resolve()}},t}();Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector),Element.prototype.closest||(Element.prototype.closest=function(t){var n=this;do{if(n.matches(t))return n;n=n.parentElement||n.parentNode}while(null!==n&&1===n.nodeType);return null});var st={container:null,html:"",namespace:"",url:{hash:"",href:"",path:"",port:null,query:{}}};return new(function(){function t(){this.version=a,this.schemaPage=st,this.Logger=l,this.logger=new l("@barba/core"),this.plugins=[],this.hooks=X,this.dom=j,this.helpers=_,this.history=M,this.request=I,this.url=H}var e=t.prototype;return e.use=function(t,n){var r=this.plugins;r.indexOf(t)>-1?this.logger.warn("Plugin ["+t.name+"] already installed."):"function"==typeof t.install?(t.install(this,n),r.push(t)):this.logger.warn("Plugin ["+t.name+'] has no "install" method.')},e.init=function(t){var n=void 0===t?{}:t,e=n.transitions,i=void 0===e?[]:e,o=n.views,u=void 0===o?[]:o,f=n.schema,s=void 0===f?S:f,c=n.requestError,a=n.timeout,h=void 0===a?2e3:a,v=n.cacheIgnore,d=void 0!==v&&v,m=n.prefetchIgnore,p=void 0!==m&&m,w=n.preventRunning,b=void 0!==w&&w,y=n.prevent,P=void 0===y?null:y,g=n.debug,E=n.logLevel;if(l.setLevel(!0===(void 0!==g&&g)?"debug":void 0===E?"off":E),this.logger.info(this.version),Object.keys(s).forEach((function(t){S[t]&&(S[t]=s[t])})),this.$=c,this.timeout=h,this.cacheIgnore=d,this.prefetchIgnore=p,this.preventRunning=b,this._=this.dom.getWrapper(),!this._)throw new Error("[@barba/core] No Barba wrapper found");this._.setAttribute("aria-live","polite"),this.q();var x=this.data.current;if(!x.container)throw new Error("[@barba/core] No Barba container found");if(this.cache=new G(d),this.prevent=new et(p),this.transitions=new ut(i),this.views=new ft(u),null!==P){if("function"!=typeof P)throw new Error("[@barba/core] Prevent should be a function");this.prevent.add("preventCustom",P)}this.history.init(x.url.href,x.namespace),this.B=this.B.bind(this),this.U=this.U.bind(this),this.D=this.D.bind(this),this.F(),this.plugins.forEach((function(t){return t.init()}));var k=this.data;k.trigger="barba",k.next=k.current,k.current=r({},this.schemaPage),this.hooks.do("ready",k),this.once(k),this.q()},e.destroy=function(){this.q(),this.H(),this.history.clear(),this.hooks.clear(),this.plugins=[]},e.force=function(t){window.location.assign(t)},e.go=function(t,n,r){var e;if(void 0===n&&(n="barba"),this.transitions.isRunning)this.force(t);else if(!(e="popstate"===n?this.history.current&&this.url.getPath(this.history.current.url)===this.url.getPath(t):this.prevent.run("sameUrl",null,null,t))||this.transitions.hasSelf)return n=this.history.change(t,n,r),r&&(r.stopPropagation(),r.preventDefault()),this.page(t,n,e)},e.once=function(t){try{var n=this;return Promise.resolve(n.hooks.do("beforeEnter",t)).then((function(){function r(){return Promise.resolve(n.hooks.do("afterEnter",t)).then((function(){}))}var e=function(){if(n.transitions.hasOnce){var r=n.transitions.get(t,{once:!0});return Promise.resolve(n.transitions.doOnce({transition:r,data:t})).then((function(){}))}}();return e&&e.then?e.then(r):r()}))}catch(t){return Promise.reject(t)}},e.page=function(t,n,e){try{var i=function(){var t=o.data;return Promise.resolve(o.hooks.do("page",t)).then((function(){var n=s((function(){var n=o.transitions.get(t,{once:!1,self:e});return Promise.resolve(o.transitions.doPage({data:t,page:u,transition:n,wrapper:o._})).then((function(){o.q()}))}),(function(){0===l.getLevel()&&o.force(t.current.url.href)}));if(n&&n.then)return n.then((function(){}))}))},o=this;o.data.next.url=r({href:t},o.url.parse(t)),o.data.trigger=n;var u=o.cache.has(t)?o.cache.update(t,{action:"click"}).request:o.cache.set(t,o.request(t,o.timeout,o.onRequestError.bind(o,n)),"click").request,f=function(){if(o.transitions.shouldWait)return Promise.resolve(L(u,o.data)).then((function(){}))}();return Promise.resolve(f&&f.then?f.then(i):i())}catch(t){return Promise.reject(t)}},e.onRequestError=function(t){this.transitions.isRunning=!1;for(var n=arguments.length,r=new Array(n>1?n-1:0),e=1;e<n;e++)r[e-1]=arguments[e];var i=r[0],o=r[1],u=this.cache.getAction(i);return this.cache.delete(i),!(this.$&&!1===this.$(t,u,i,o)||("click"===u&&this.force(i),1))},e.prefetch=function(t){var n=this;this.cache.has(t)||this.cache.set(t,this.request(t,this.timeout,this.onRequestError.bind(this,"barba")).catch((function(t){n.logger.error(t)})),"prefetch")},e.F=function(){!0!==this.prefetchIgnore&&(document.addEventListener("mouseover",this.B),document.addEventListener("touchstart",this.B)),document.addEventListener("click",this.U),window.addEventListener("popstate",this.D)},e.H=function(){!0!==this.prefetchIgnore&&(document.removeEventListener("mouseover",this.B),document.removeEventListener("touchstart",this.B)),document.removeEventListener("click",this.U),window.removeEventListener("popstate",this.D)},e.B=function(t){var n=this,r=this.I(t);if(r){var e=this.dom.getHref(r);this.prevent.checkHref(e)||this.cache.has(e)||this.cache.set(e,this.request(e,this.timeout,this.onRequestError.bind(this,r)).catch((function(t){n.logger.error(t)})),"enter")}},e.U=function(t){var n=this.I(t);if(n)return this.transitions.isRunning&&this.preventRunning?(t.preventDefault(),void t.stopPropagation()):void this.go(this.dom.getHref(n),n,t)},e.D=function(t){this.go(this.url.getHref(),"popstate",t)},e.I=function(t){for(var n=t.target;n&&!this.dom.getHref(n);)n=n.parentNode;if(n&&!this.prevent.checkLink(n,t,this.dom.getHref(n)))return n},e.q=function(){var t=this.url.getHref(),n={container:this.dom.getContainer(),html:this.dom.getHtml(),namespace:this.dom.getNamespace(),url:r({href:t},this.url.parse(t))};this.C={current:n,next:r({},this.schemaPage),trigger:void 0},this.hooks.do("reset",this.data)},n(t,[{key:"data",get:function(){return this.C}},{key:"wrapper",get:function(){return this._}}]),t}())}));
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.window = global.window || {}));
  }(this, (function (exports) { 'use strict';
  
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
  
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
  
      return self;
    }
  
    /*!
     * GSAP 3.7.1
     * https://greensock.com
     *
     * @license Copyright 2008-2021, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var _config = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    },
        _defaults = {
      duration: .5,
      overwrite: false,
      delay: 0
    },
        _suppressOverwrites,
        _bigNum = 1e8,
        _tinyNum = 1 / _bigNum,
        _2PI = Math.PI * 2,
        _HALF_PI = _2PI / 4,
        _gsID = 0,
        _sqrt = Math.sqrt,
        _cos = Math.cos,
        _sin = Math.sin,
        _isString = function _isString(value) {
      return typeof value === "string";
    },
        _isFunction = function _isFunction(value) {
      return typeof value === "function";
    },
        _isNumber = function _isNumber(value) {
      return typeof value === "number";
    },
        _isUndefined = function _isUndefined(value) {
      return typeof value === "undefined";
    },
        _isObject = function _isObject(value) {
      return typeof value === "object";
    },
        _isNotFalse = function _isNotFalse(value) {
      return value !== false;
    },
        _windowExists = function _windowExists() {
      return typeof window !== "undefined";
    },
        _isFuncOrString = function _isFuncOrString(value) {
      return _isFunction(value) || _isString(value);
    },
        _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
        _isArray = Array.isArray,
        _strictNumExp = /(?:-?\.?\d|\.)+/gi,
        _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        _relExp = /[+-]=-?[.\d]+/,
        _delimitedValueExp = /[^,'"\[\]\s]+/gi,
        _unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
        _globalTimeline,
        _win,
        _coreInitted,
        _doc,
        _globals = {},
        _installScope = {},
        _coreReady,
        _install = function _install(scope) {
      return (_installScope = _merge(scope, _globals)) && gsap;
    },
        _missingPlugin = function _missingPlugin(property, value) {
      return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
    },
        _warn = function _warn(message, suppress) {
      return !suppress && console.warn(message);
    },
        _addGlobal = function _addGlobal(name, obj) {
      return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
    },
        _emptyFunc = function _emptyFunc() {
      return 0;
    },
        _reservedProps = {},
        _lazyTweens = [],
        _lazyLookup = {},
        _lastRenderedFrame,
        _plugins = {},
        _effects = {},
        _nextGCFrame = 30,
        _harnessPlugins = [],
        _callbackNames = "",
        _harness = function _harness(targets) {
      var target = targets[0],
          harnessPlugin,
          i;
      _isObject(target) || _isFunction(target) || (targets = [targets]);
  
      if (!(harnessPlugin = (target._gsap || {}).harness)) {
        i = _harnessPlugins.length;
  
        while (i-- && !_harnessPlugins[i].targetTest(target)) {}
  
        harnessPlugin = _harnessPlugins[i];
      }
  
      i = targets.length;
  
      while (i--) {
        targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
      }
  
      return targets;
    },
        _getCache = function _getCache(target) {
      return target._gsap || _harness(toArray(target))[0]._gsap;
    },
        _getProperty = function _getProperty(target, property, v) {
      return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
    },
        _forEachName = function _forEachName(names, func) {
      return (names = names.split(",")).forEach(func) || names;
    },
        _round = function _round(value) {
      return Math.round(value * 100000) / 100000 || 0;
    },
        _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
      var l = toFind.length,
          i = 0;
  
      for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
  
      return i < l;
    },
        _lazyRender = function _lazyRender() {
      var l = _lazyTweens.length,
          a = _lazyTweens.slice(0),
          i,
          tween;
  
      _lazyLookup = {};
      _lazyTweens.length = 0;
  
      for (i = 0; i < l; i++) {
        tween = a[i];
        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
      }
    },
        _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
      _lazyTweens.length && _lazyRender();
      animation.render(time, suppressEvents, force);
      _lazyTweens.length && _lazyRender();
    },
        _numericIfPossible = function _numericIfPossible(value) {
      var n = parseFloat(value);
      return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
    },
        _passThrough = function _passThrough(p) {
      return p;
    },
        _setDefaults = function _setDefaults(obj, defaults) {
      for (var p in defaults) {
        p in obj || (obj[p] = defaults[p]);
      }
  
      return obj;
    },
        _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
      for (var p in defaults) {
        p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
      }
    },
        _merge = function _merge(base, toMerge) {
      for (var p in toMerge) {
        base[p] = toMerge[p];
      }
  
      return base;
    },
        _mergeDeep = function _mergeDeep(base, toMerge) {
      for (var p in toMerge) {
        p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
      }
  
      return base;
    },
        _copyExcluding = function _copyExcluding(obj, excluding) {
      var copy = {},
          p;
  
      for (p in obj) {
        p in excluding || (copy[p] = obj[p]);
      }
  
      return copy;
    },
        _inheritDefaults = function _inheritDefaults(vars) {
      var parent = vars.parent || _globalTimeline,
          func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;
  
      if (_isNotFalse(vars.inherit)) {
        while (parent) {
          func(vars, parent.vars.defaults);
          parent = parent.parent || parent._dp;
        }
      }
  
      return vars;
    },
        _arraysMatch = function _arraysMatch(a1, a2) {
      var i = a1.length,
          match = i === a2.length;
  
      while (match && i-- && a1[i] === a2[i]) {}
  
      return i < 0;
    },
        _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
  
      if (lastProp === void 0) {
        lastProp = "_last";
      }
  
      var prev = parent[lastProp],
          t;
  
      if (sortBy) {
        t = child[sortBy];
  
        while (prev && prev[sortBy] > t) {
          prev = prev._prev;
        }
      }
  
      if (prev) {
        child._next = prev._next;
        prev._next = child;
      } else {
        child._next = parent[firstProp];
        parent[firstProp] = child;
      }
  
      if (child._next) {
        child._next._prev = child;
      } else {
        parent[lastProp] = child;
      }
  
      child._prev = prev;
      child.parent = child._dp = parent;
      return child;
    },
        _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
  
      if (lastProp === void 0) {
        lastProp = "_last";
      }
  
      var prev = child._prev,
          next = child._next;
  
      if (prev) {
        prev._next = next;
      } else if (parent[firstProp] === child) {
        parent[firstProp] = next;
      }
  
      if (next) {
        next._prev = prev;
      } else if (parent[lastProp] === child) {
        parent[lastProp] = prev;
      }
  
      child._next = child._prev = child.parent = null;
    },
        _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
      child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
      child._act = 0;
    },
        _uncache = function _uncache(animation, child) {
      if (animation && (!child || child._end > animation._dur || child._start < 0)) {
        var a = animation;
  
        while (a) {
          a._dirty = 1;
          a = a.parent;
        }
      }
  
      return animation;
    },
        _recacheAncestors = function _recacheAncestors(animation) {
      var parent = animation.parent;
  
      while (parent && parent.parent) {
        parent._dirty = 1;
        parent.totalDuration();
        parent = parent.parent;
      }
  
      return animation;
    },
        _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
      return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
    },
        _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
      return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
    },
        _animationCycle = function _animationCycle(tTime, cycleDuration) {
      var whole = Math.floor(tTime /= cycleDuration);
      return tTime && whole === tTime ? whole - 1 : whole;
    },
        _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
      return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
    },
        _setEnd = function _setEnd(animation) {
      return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
    },
        _alignPlayhead = function _alignPlayhead(animation, totalTime) {
      var parent = animation._dp;
  
      if (parent && parent.smoothChildTiming && animation._ts) {
        animation._start = _round(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
  
        _setEnd(animation);
  
        parent._dirty || _uncache(parent, animation);
      }
  
      return animation;
    },
        _postAddChecks = function _postAddChecks(timeline, child) {
      var t;
  
      if (child._time || child._initted && !child._dur) {
        t = _parentToChildTotalTime(timeline.rawTime(), child);
  
        if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
          child.render(t, true);
        }
      }
  
      if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
        if (timeline._dur < timeline.duration()) {
          t = timeline;
  
          while (t._dp) {
            t.rawTime() >= 0 && t.totalTime(t._tTime);
            t = t._dp;
          }
        }
  
        timeline._zTime = -_tinyNum;
      }
    },
        _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
      child.parent && _removeFromParent(child);
      child._start = _round((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
      child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
  
      _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
  
      _isFromOrFromStart(child) || (timeline._recent = child);
      skipChecks || _postAddChecks(timeline, child);
      return timeline;
    },
        _scrollTrigger = function _scrollTrigger(animation, trigger) {
      return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
    },
        _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
      _initTween(tween, totalTime);
  
      if (!tween._initted) {
        return 1;
      }
  
      if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
        _lazyTweens.push(tween);
  
        tween._lazy = [totalTime, suppressEvents];
        return 1;
      }
    },
        _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
      var parent = _ref.parent;
      return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
    },
        _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
      var data = _ref2.data;
      return data === "isFromStart" || data === "isStart";
    },
        _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
      var prevRatio = tween.ratio,
          ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
          repeatDelay = tween._rDelay,
          tTime = 0,
          pt,
          iteration,
          prevIteration;
  
      if (repeatDelay && tween._repeat) {
        tTime = _clamp(0, tween._tDur, totalTime);
        iteration = _animationCycle(tTime, repeatDelay);
        prevIteration = _animationCycle(tween._tTime, repeatDelay);
        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
  
        if (iteration !== prevIteration) {
          prevRatio = 1 - ratio;
          tween.vars.repeatRefresh && tween._initted && tween.invalidate();
        }
      }
  
      if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
          return;
        }
  
        prevIteration = tween._zTime;
        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
        suppressEvents || (suppressEvents = totalTime && !prevIteration);
        tween.ratio = ratio;
        tween._from && (ratio = 1 - ratio);
        tween._time = 0;
        tween._tTime = tTime;
        pt = tween._pt;
  
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
  
        tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
        tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
        tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
  
        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
          ratio && _removeFromParent(tween, 1);
  
          if (!suppressEvents) {
            _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
  
            tween._prom && tween._prom();
          }
        }
      } else if (!tween._zTime) {
        tween._zTime = totalTime;
      }
    },
        _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
      var child;
  
      if (time > prevTime) {
        child = animation._first;
  
        while (child && child._start <= time) {
          if (!child._dur && child.data === "isPause" && child._start > prevTime) {
            return child;
          }
  
          child = child._next;
        }
      } else {
        child = animation._last;
  
        while (child && child._start >= time) {
          if (!child._dur && child.data === "isPause" && child._start < prevTime) {
            return child;
          }
  
          child = child._prev;
        }
      }
    },
        _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
      var repeat = animation._repeat,
          dur = _round(duration) || 0,
          totalProgress = animation._tTime / animation._tDur;
      totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
      animation._dur = dur;
      animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);
      totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
      skipUncache || _uncache(animation.parent, animation);
      return animation;
    },
        _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
      return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
    },
        _zeroPosition = {
      _start: 0,
      endTime: _emptyFunc,
      totalDuration: _emptyFunc
    },
        _parsePosition = function _parsePosition(animation, position, percentAnimation) {
      var labels = animation.labels,
          recent = animation._recent || _zeroPosition,
          clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
          i,
          offset,
          isPercent;
  
      if (_isString(position) && (isNaN(position) || position in labels)) {
        offset = position.charAt(0);
        isPercent = position.substr(-1) === "%";
        i = position.indexOf("=");
  
        if (offset === "<" || offset === ">") {
          i >= 0 && (position = position.replace(/=/, ""));
          return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
        }
  
        if (i < 0) {
          position in labels || (labels[position] = clippedDuration);
          return labels[position];
        }
  
        offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
  
        if (isPercent && percentAnimation) {
          offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
        }
  
        return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
      }
  
      return position == null ? clippedDuration : +position;
    },
        _createTweenType = function _createTweenType(type, params, timeline) {
      var isLegacy = _isNumber(params[1]),
          varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
          vars = params[varsIndex],
          irVars,
          parent;
  
      isLegacy && (vars.duration = params[1]);
      vars.parent = timeline;
  
      if (type) {
        irVars = vars;
        parent = timeline;
  
        while (parent && !("immediateRender" in irVars)) {
          irVars = parent.vars.defaults || {};
          parent = _isNotFalse(parent.vars.inherit) && parent.parent;
        }
  
        vars.immediateRender = _isNotFalse(irVars.immediateRender);
        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
      }
  
      return new Tween(params[0], vars, params[varsIndex + 1]);
    },
        _conditionalReturn = function _conditionalReturn(value, func) {
      return value || value === 0 ? func(value) : func;
    },
        _clamp = function _clamp(min, max, value) {
      return value < min ? min : value > max ? max : value;
    },
        getUnit = function getUnit(value) {
      if (typeof value !== "string") {
        return "";
      }
  
      var v = _unitExp.exec(value);
  
      return v ? value.substr(v.index + v[0].length) : "";
    },
        clamp = function clamp(min, max, value) {
      return _conditionalReturn(value, function (v) {
        return _clamp(min, max, v);
      });
    },
        _slice = [].slice,
        _isArrayLike = function _isArrayLike(value, nonEmpty) {
      return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
    },
        _flatten = function _flatten(ar, leaveStrings, accumulator) {
      if (accumulator === void 0) {
        accumulator = [];
      }
  
      return ar.forEach(function (value) {
        var _accumulator;
  
        return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
      }) || accumulator;
    },
        toArray = function toArray(value, scope, leaveStrings) {
      return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
    },
        selector = function selector(value) {
      value = toArray(value)[0] || _warn("Invalid scope") || {};
      return function (v) {
        var el = value.current || value.nativeElement || value;
        return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
      };
    },
        shuffle = function shuffle(a) {
      return a.sort(function () {
        return .5 - Math.random();
      });
    },
        distribute = function distribute(v) {
      if (_isFunction(v)) {
        return v;
      }
  
      var vars = _isObject(v) ? v : {
        each: v
      },
          ease = _parseEase(vars.ease),
          from = vars.from || 0,
          base = parseFloat(vars.base) || 0,
          cache = {},
          isDecimal = from > 0 && from < 1,
          ratios = isNaN(from) || isDecimal,
          axis = vars.axis,
          ratioX = from,
          ratioY = from;
  
      if (_isString(from)) {
        ratioX = ratioY = {
          center: .5,
          edges: .5,
          end: 1
        }[from] || 0;
      } else if (!isDecimal && ratios) {
        ratioX = from[0];
        ratioY = from[1];
      }
  
      return function (i, target, a) {
        var l = (a || vars).length,
            distances = cache[l],
            originX,
            originY,
            x,
            y,
            d,
            j,
            max,
            min,
            wrapAt;
  
        if (!distances) {
          wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
  
          if (!wrapAt) {
            max = -_bigNum;
  
            while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
  
            wrapAt--;
          }
  
          distances = cache[l] = [];
          originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
          originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
          max = 0;
          min = _bigNum;
  
          for (j = 0; j < l; j++) {
            x = j % wrapAt - originX;
            y = originY - (j / wrapAt | 0);
            distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
            d > max && (max = d);
            d < min && (min = d);
          }
  
          from === "random" && shuffle(distances);
          distances.max = max - min;
          distances.min = min;
          distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
          distances.b = l < 0 ? base - l : base;
          distances.u = getUnit(vars.amount || vars.each) || 0;
          ease = ease && l < 0 ? _invertEase(ease) : ease;
        }
  
        l = (distances[i] - distances.min) / distances.max || 0;
        return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
      };
    },
        _roundModifier = function _roundModifier(v) {
      var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1;
      return function (raw) {
        var n = Math.round(parseFloat(raw) / v) * v * p;
        return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
      };
    },
        snap = function snap(snapTo, value) {
      var isArray = _isArray(snapTo),
          radius,
          is2D;
  
      if (!isArray && _isObject(snapTo)) {
        radius = isArray = snapTo.radius || _bigNum;
  
        if (snapTo.values) {
          snapTo = toArray(snapTo.values);
  
          if (is2D = !_isNumber(snapTo[0])) {
            radius *= radius;
          }
        } else {
          snapTo = _roundModifier(snapTo.increment);
        }
      }
  
      return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
        is2D = snapTo(raw);
        return Math.abs(is2D - raw) <= radius ? is2D : raw;
      } : function (raw) {
        var x = parseFloat(is2D ? raw.x : raw),
            y = parseFloat(is2D ? raw.y : 0),
            min = _bigNum,
            closest = 0,
            i = snapTo.length,
            dx,
            dy;
  
        while (i--) {
          if (is2D) {
            dx = snapTo[i].x - x;
            dy = snapTo[i].y - y;
            dx = dx * dx + dy * dy;
          } else {
            dx = Math.abs(snapTo[i] - x);
          }
  
          if (dx < min) {
            min = dx;
            closest = i;
          }
        }
  
        closest = !radius || min <= radius ? snapTo[closest] : raw;
        return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
      });
    },
        random = function random(min, max, roundingIncrement, returnFunction) {
      return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
        return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
      });
    },
        pipe = function pipe() {
      for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
        functions[_key] = arguments[_key];
      }
  
      return function (value) {
        return functions.reduce(function (v, f) {
          return f(v);
        }, value);
      };
    },
        unitize = function unitize(func, unit) {
      return function (value) {
        return func(parseFloat(value)) + (unit || getUnit(value));
      };
    },
        normalize = function normalize(min, max, value) {
      return mapRange(min, max, 0, 1, value);
    },
        _wrapArray = function _wrapArray(a, wrapper, value) {
      return _conditionalReturn(value, function (index) {
        return a[~~wrapper(index)];
      });
    },
        wrap = function wrap(min, max, value) {
      var range = max - min;
      return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
        return (range + (value - min) % range) % range + min;
      });
    },
        wrapYoyo = function wrapYoyo(min, max, value) {
      var range = max - min,
          total = range * 2;
      return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
        value = (total + (value - min) % total) % total || 0;
        return min + (value > range ? total - value : value);
      });
    },
        _replaceRandom = function _replaceRandom(value) {
      var prev = 0,
          s = "",
          i,
          nums,
          end,
          isArray;
  
      while (~(i = value.indexOf("random(", prev))) {
        end = value.indexOf(")", i);
        isArray = value.charAt(i + 7) === "[";
        nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
        s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
        prev = end + 1;
      }
  
      return s + value.substr(prev, value.length - prev);
    },
        mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
      var inRange = inMax - inMin,
          outRange = outMax - outMin;
      return _conditionalReturn(value, function (value) {
        return outMin + ((value - inMin) / inRange * outRange || 0);
      });
    },
        interpolate = function interpolate(start, end, progress, mutate) {
      var func = isNaN(start + end) ? 0 : function (p) {
        return (1 - p) * start + p * end;
      };
  
      if (!func) {
        var isString = _isString(start),
            master = {},
            p,
            i,
            interpolators,
            l,
            il;
  
        progress === true && (mutate = 1) && (progress = null);
  
        if (isString) {
          start = {
            p: start
          };
          end = {
            p: end
          };
        } else if (_isArray(start) && !_isArray(end)) {
          interpolators = [];
          l = start.length;
          il = l - 2;
  
          for (i = 1; i < l; i++) {
            interpolators.push(interpolate(start[i - 1], start[i]));
          }
  
          l--;
  
          func = function func(p) {
            p *= l;
            var i = Math.min(il, ~~p);
            return interpolators[i](p - i);
          };
  
          progress = end;
        } else if (!mutate) {
          start = _merge(_isArray(start) ? [] : {}, start);
        }
  
        if (!interpolators) {
          for (p in end) {
            _addPropTween.call(master, start, p, "get", end[p]);
          }
  
          func = function func(p) {
            return _renderPropTweens(p, master) || (isString ? start.p : start);
          };
        }
      }
  
      return _conditionalReturn(progress, func);
    },
        _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
      var labels = timeline.labels,
          min = _bigNum,
          p,
          distance,
          label;
  
      for (p in labels) {
        distance = labels[p] - fromTime;
  
        if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
          label = p;
          min = distance;
        }
      }
  
      return label;
    },
        _callback = function _callback(animation, type, executeLazyFirst) {
      var v = animation.vars,
          callback = v[type],
          params,
          scope;
  
      if (!callback) {
        return;
      }
  
      params = v[type + "Params"];
      scope = v.callbackScope || animation;
      executeLazyFirst && _lazyTweens.length && _lazyRender();
      return params ? callback.apply(scope, params) : callback.call(scope);
    },
        _interrupt = function _interrupt(animation) {
      _removeFromParent(animation);
  
      animation.scrollTrigger && animation.scrollTrigger.kill(false);
      animation.progress() < 1 && _callback(animation, "onInterrupt");
      return animation;
    },
        _quickTween,
        _createPlugin = function _createPlugin(config) {
      config = !config.name && config["default"] || config;
  
      var name = config.name,
          isFunc = _isFunction(config),
          Plugin = name && !isFunc && config.init ? function () {
        this._props = [];
      } : config,
          instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      },
          statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
  
      _wake();
  
      if (config !== Plugin) {
        if (_plugins[name]) {
          return;
        }
  
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
  
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
  
        _plugins[Plugin.prop = name] = Plugin;
  
        if (config.targetTest) {
          _harnessPlugins.push(Plugin);
  
          _reservedProps[name] = 1;
        }
  
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
  
      _addGlobal(name, Plugin);
  
      config.register && config.register(gsap, Plugin, PropTween);
    },
        _255 = 255,
        _colorLookup = {
      aqua: [0, _255, _255],
      lime: [0, _255, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, _255],
      navy: [0, 0, 128],
      white: [_255, _255, _255],
      olive: [128, 128, 0],
      yellow: [_255, _255, 0],
      orange: [_255, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [_255, 0, 0],
      pink: [_255, 192, 203],
      cyan: [0, _255, _255],
      transparent: [_255, _255, _255, 0]
    },
        _hue = function _hue(h, m1, m2) {
      h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
      return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
    },
        splitColor = function splitColor(v, toHSL, forceAlpha) {
      var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
          r,
          g,
          b,
          h,
          s,
          l,
          max,
          min,
          d,
          wasHSL;
  
      if (!a) {
        if (v.substr(-1) === ",") {
          v = v.substr(0, v.length - 1);
        }
  
        if (_colorLookup[v]) {
          a = _colorLookup[v];
        } else if (v.charAt(0) === "#") {
          if (v.length < 6) {
            r = v.charAt(1);
            g = v.charAt(2);
            b = v.charAt(3);
            v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
          }
  
          if (v.length === 9) {
            a = parseInt(v.substr(1, 6), 16);
            return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
          }
  
          v = parseInt(v.substr(1), 16);
          a = [v >> 16, v >> 8 & _255, v & _255];
        } else if (v.substr(0, 3) === "hsl") {
          a = wasHSL = v.match(_strictNumExp);
  
          if (!toHSL) {
            h = +a[0] % 360 / 360;
            s = +a[1] / 100;
            l = +a[2] / 100;
            g = l <= .5 ? l * (s + 1) : l + s - l * s;
            r = l * 2 - g;
            a.length > 3 && (a[3] *= 1);
            a[0] = _hue(h + 1 / 3, r, g);
            a[1] = _hue(h, r, g);
            a[2] = _hue(h - 1 / 3, r, g);
          } else if (~v.indexOf("=")) {
            a = v.match(_numExp);
            forceAlpha && a.length < 4 && (a[3] = 1);
            return a;
          }
        } else {
          a = v.match(_strictNumExp) || _colorLookup.transparent;
        }
  
        a = a.map(Number);
      }
  
      if (toHSL && !wasHSL) {
        r = a[0] / _255;
        g = a[1] / _255;
        b = a[2] / _255;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        l = (max + min) / 2;
  
        if (max === min) {
          h = s = 0;
        } else {
          d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
          h *= 60;
        }
  
        a[0] = ~~(h + .5);
        a[1] = ~~(s * 100 + .5);
        a[2] = ~~(l * 100 + .5);
      }
  
      forceAlpha && a.length < 4 && (a[3] = 1);
      return a;
    },
        _colorOrderData = function _colorOrderData(v) {
      var values = [],
          c = [],
          i = -1;
      v.split(_colorExp).forEach(function (v) {
        var a = v.match(_numWithUnitExp) || [];
        values.push.apply(values, a);
        c.push(i += a.length + 1);
      });
      values.c = c;
      return values;
    },
        _formatColors = function _formatColors(s, toHSL, orderMatchData) {
      var result = "",
          colors = (s + result).match(_colorExp),
          type = toHSL ? "hsla(" : "rgba(",
          i = 0,
          c,
          shell,
          d,
          l;
  
      if (!colors) {
        return s;
      }
  
      colors = colors.map(function (color) {
        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
      });
  
      if (orderMatchData) {
        d = _colorOrderData(s);
        c = orderMatchData.c;
  
        if (c.join(result) !== d.c.join(result)) {
          shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
          l = shell.length - 1;
  
          for (; i < l; i++) {
            result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
          }
        }
      }
  
      if (!shell) {
        shell = s.split(_colorExp);
        l = shell.length - 1;
  
        for (; i < l; i++) {
          result += shell[i] + colors[i];
        }
      }
  
      return result + shell[l];
    },
        _colorExp = function () {
      var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
          p;
  
      for (p in _colorLookup) {
        s += "|" + p + "\\b";
      }
  
      return new RegExp(s + ")", "gi");
    }(),
        _hslExp = /hsl[a]?\(/,
        _colorStringFilter = function _colorStringFilter(a) {
      var combined = a.join(" "),
          toHSL;
      _colorExp.lastIndex = 0;
  
      if (_colorExp.test(combined)) {
        toHSL = _hslExp.test(combined);
        a[1] = _formatColors(a[1], toHSL);
        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
        return true;
      }
    },
        _tickerActive,
        _ticker = function () {
      var _getTime = Date.now,
          _lagThreshold = 500,
          _adjustedLag = 33,
          _startTime = _getTime(),
          _lastUpdate = _startTime,
          _gap = 1000 / 240,
          _nextTime = _gap,
          _listeners = [],
          _id,
          _req,
          _raf,
          _self,
          _delta,
          _i,
          _tick = function _tick(v) {
        var elapsed = _getTime() - _lastUpdate,
            manual = v === true,
            overlap,
            dispatch,
            time,
            frame;
  
        elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
        _lastUpdate += elapsed;
        time = _lastUpdate - _startTime;
        overlap = time - _nextTime;
  
        if (overlap > 0 || manual) {
          frame = ++_self.frame;
          _delta = time - _self.time * 1000;
          _self.time = time = time / 1000;
          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
          dispatch = 1;
        }
  
        manual || (_id = _req(_tick));
  
        if (dispatch) {
          for (_i = 0; _i < _listeners.length; _i++) {
            _listeners[_i](time, _delta, frame, v);
          }
        }
      };
  
      _self = {
        time: 0,
        frame: 0,
        tick: function tick() {
          _tick(true);
        },
        deltaRatio: function deltaRatio(fps) {
          return _delta / (1000 / (fps || 60));
        },
        wake: function wake() {
          if (_coreReady) {
            if (!_coreInitted && _windowExists()) {
              _win = _coreInitted = window;
              _doc = _win.document || {};
              _globals.gsap = gsap;
              (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
  
              _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
  
              _raf = _win.requestAnimationFrame;
            }
  
            _id && _self.sleep();
  
            _req = _raf || function (f) {
              return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
            };
  
            _tickerActive = 1;
  
            _tick(2);
          }
        },
        sleep: function sleep() {
          (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
          _tickerActive = 0;
          _req = _emptyFunc;
        },
        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
          _lagThreshold = threshold || 1 / _tinyNum;
          _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
        },
        fps: function fps(_fps) {
          _gap = 1000 / (_fps || 240);
          _nextTime = _self.time * 1000 + _gap;
        },
        add: function add(callback) {
          _listeners.indexOf(callback) < 0 && _listeners.push(callback);
  
          _wake();
        },
        remove: function remove(callback) {
          var i;
          ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
        },
        _listeners: _listeners
      };
      return _self;
    }(),
        _wake = function _wake() {
      return !_tickerActive && _ticker.wake();
    },
        _easeMap = {},
        _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
        _quotesExp = /["']/g,
        _parseObjectInString = function _parseObjectInString(value) {
      var obj = {},
          split = value.substr(1, value.length - 3).split(":"),
          key = split[0],
          i = 1,
          l = split.length,
          index,
          val,
          parsedVal;
  
      for (; i < l; i++) {
        val = split[i];
        index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
        parsedVal = val.substr(0, index);
        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
        key = val.substr(index + 1).trim();
      }
  
      return obj;
    },
        _valueInParentheses = function _valueInParentheses(value) {
      var open = value.indexOf("(") + 1,
          close = value.indexOf(")"),
          nested = value.indexOf("(", open);
      return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
    },
        _configEaseFromString = function _configEaseFromString(name) {
      var split = (name + "").split("("),
          ease = _easeMap[split[0]];
      return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
    },
        _invertEase = function _invertEase(ease) {
      return function (p) {
        return 1 - ease(1 - p);
      };
    },
        _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
      var child = timeline._first,
          ease;
  
      while (child) {
        if (child instanceof Timeline) {
          _propagateYoyoEase(child, isYoyo);
        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
          if (child.timeline) {
            _propagateYoyoEase(child.timeline, isYoyo);
          } else {
            ease = child._ease;
            child._ease = child._yEase;
            child._yEase = ease;
            child._yoyo = isYoyo;
          }
        }
  
        child = child._next;
      }
    },
        _parseEase = function _parseEase(ease, defaultEase) {
      return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
    },
        _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
      if (easeOut === void 0) {
        easeOut = function easeOut(p) {
          return 1 - easeIn(1 - p);
        };
      }
  
      if (easeInOut === void 0) {
        easeInOut = function easeInOut(p) {
          return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
        };
      }
  
      var ease = {
        easeIn: easeIn,
        easeOut: easeOut,
        easeInOut: easeInOut
      },
          lowercaseName;
  
      _forEachName(names, function (name) {
        _easeMap[name] = _globals[name] = ease;
        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
  
        for (var p in ease) {
          _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
        }
      });
  
      return ease;
    },
        _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
      return function (p) {
        return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
      };
    },
        _configElastic = function _configElastic(type, amplitude, period) {
      var p1 = amplitude >= 1 ? amplitude : 1,
          p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
          p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
          easeOut = function easeOut(p) {
        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
      },
          ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
  
      p2 = _2PI / p2;
  
      ease.config = function (amplitude, period) {
        return _configElastic(type, amplitude, period);
      };
  
      return ease;
    },
        _configBack = function _configBack(type, overshoot) {
      if (overshoot === void 0) {
        overshoot = 1.70158;
      }
  
      var easeOut = function easeOut(p) {
        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
      },
          ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
  
      ease.config = function (overshoot) {
        return _configBack(type, overshoot);
      };
  
      return ease;
    };
  
    _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
      var power = i < 5 ? i + 1 : i;
  
      _insertEase(name + ",Power" + (power - 1), i ? function (p) {
        return Math.pow(p, power);
      } : function (p) {
        return p;
      }, function (p) {
        return 1 - Math.pow(1 - p, power);
      }, function (p) {
        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
      });
    });
  
    _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  
    _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  
    (function (n, c) {
      var n1 = 1 / c,
          n2 = 2 * n1,
          n3 = 2.5 * n1,
          easeOut = function easeOut(p) {
        return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
      };
  
      _insertEase("Bounce", function (p) {
        return 1 - easeOut(1 - p);
      }, easeOut);
    })(7.5625, 2.75);
  
    _insertEase("Expo", function (p) {
      return p ? Math.pow(2, 10 * (p - 1)) : 0;
    });
  
    _insertEase("Circ", function (p) {
      return -(_sqrt(1 - p * p) - 1);
    });
  
    _insertEase("Sine", function (p) {
      return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
    });
  
    _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  
    _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
      config: function config(steps, immediateStart) {
        if (steps === void 0) {
          steps = 1;
        }
  
        var p1 = 1 / steps,
            p2 = steps + (immediateStart ? 0 : 1),
            p3 = immediateStart ? 1 : 0,
            max = 1 - _tinyNum;
        return function (p) {
          return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
        };
      }
    };
    _defaults.ease = _easeMap["quad.out"];
  
    _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
      return _callbackNames += name + "," + name + "Params,";
    });
  
    var GSCache = function GSCache(target, harness) {
      this.id = _gsID++;
      target._gsap = this;
      this.target = target;
      this.harness = harness;
      this.get = harness ? harness.get : _getProperty;
      this.set = harness ? harness.getSetter : _getSetter;
    };
    var Animation = function () {
      function Animation(vars) {
        this.vars = vars;
        this._delay = +vars.delay || 0;
  
        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
          this._rDelay = vars.repeatDelay || 0;
          this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
        }
  
        this._ts = 1;
  
        _setDuration(this, +vars.duration, 1, 1);
  
        this.data = vars.data;
        _tickerActive || _ticker.wake();
      }
  
      var _proto = Animation.prototype;
  
      _proto.delay = function delay(value) {
        if (value || value === 0) {
          this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
          this._delay = value;
          return this;
        }
  
        return this._delay;
      };
  
      _proto.duration = function duration(value) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
      };
  
      _proto.totalDuration = function totalDuration(value) {
        if (!arguments.length) {
          return this._tDur;
        }
  
        this._dirty = 0;
        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
      };
  
      _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
        _wake();
  
        if (!arguments.length) {
          return this._tTime;
        }
  
        var parent = this._dp;
  
        if (parent && parent.smoothChildTiming && this._ts) {
          _alignPlayhead(this, _totalTime);
  
          !parent._dp || parent.parent || _postAddChecks(parent, this);
  
          while (parent.parent) {
            if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
              parent.totalTime(parent._tTime, true);
            }
  
            parent = parent.parent;
          }
  
          if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
            _addToTimeline(this._dp, this, this._start - this._delay);
          }
        }
  
        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
          this._ts || (this._pTime = _totalTime);
  
          _lazySafeRender(this, _totalTime, suppressEvents);
        }
  
        return this;
      };
  
      _proto.time = function time(value, suppressEvents) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
      };
  
      _proto.totalProgress = function totalProgress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
      };
  
      _proto.progress = function progress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
      };
  
      _proto.iteration = function iteration(value, suppressEvents) {
        var cycleDuration = this.duration() + this._rDelay;
  
        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
      };
  
      _proto.timeScale = function timeScale(value) {
        if (!arguments.length) {
          return this._rts === -_tinyNum ? 0 : this._rts;
        }
  
        if (this._rts === value) {
          return this;
        }
  
        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
        this._rts = +value || 0;
        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
        return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
      };
  
      _proto.paused = function paused(value) {
        if (!arguments.length) {
          return this._ps;
        }
  
        if (this._ps !== value) {
          this._ps = value;
  
          if (value) {
            this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
            this._ts = this._act = 0;
          } else {
            _wake();
  
            this._ts = this._rts;
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
          }
        }
  
        return this;
      };
  
      _proto.startTime = function startTime(value) {
        if (arguments.length) {
          this._start = value;
          var parent = this.parent || this._dp;
          parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
          return this;
        }
  
        return this._start;
      };
  
      _proto.endTime = function endTime(includeRepeats) {
        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
      };
  
      _proto.rawTime = function rawTime(wrapRepeats) {
        var parent = this.parent || this._dp;
        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
      };
  
      _proto.globalTime = function globalTime(rawTime) {
        var animation = this,
            time = arguments.length ? rawTime : animation.rawTime();
  
        while (animation) {
          time = animation._start + time / (animation._ts || 1);
          animation = animation._dp;
        }
  
        return time;
      };
  
      _proto.repeat = function repeat(value) {
        if (arguments.length) {
          this._repeat = value === Infinity ? -2 : value;
          return _onUpdateTotalDuration(this);
        }
  
        return this._repeat === -2 ? Infinity : this._repeat;
      };
  
      _proto.repeatDelay = function repeatDelay(value) {
        if (arguments.length) {
          var time = this._time;
          this._rDelay = value;
  
          _onUpdateTotalDuration(this);
  
          return time ? this.time(time) : this;
        }
  
        return this._rDelay;
      };
  
      _proto.yoyo = function yoyo(value) {
        if (arguments.length) {
          this._yoyo = value;
          return this;
        }
  
        return this._yoyo;
      };
  
      _proto.seek = function seek(position, suppressEvents) {
        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
      };
  
      _proto.restart = function restart(includeDelay, suppressEvents) {
        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      };
  
      _proto.play = function play(from, suppressEvents) {
        from != null && this.seek(from, suppressEvents);
        return this.reversed(false).paused(false);
      };
  
      _proto.reverse = function reverse(from, suppressEvents) {
        from != null && this.seek(from || this.totalDuration(), suppressEvents);
        return this.reversed(true).paused(false);
      };
  
      _proto.pause = function pause(atTime, suppressEvents) {
        atTime != null && this.seek(atTime, suppressEvents);
        return this.paused(true);
      };
  
      _proto.resume = function resume() {
        return this.paused(false);
      };
  
      _proto.reversed = function reversed(value) {
        if (arguments.length) {
          !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
          return this;
        }
  
        return this._rts < 0;
      };
  
      _proto.invalidate = function invalidate() {
        this._initted = this._act = 0;
        this._zTime = -_tinyNum;
        return this;
      };
  
      _proto.isActive = function isActive() {
        var parent = this.parent || this._dp,
            start = this._start,
            rawTime;
        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
      };
  
      _proto.eventCallback = function eventCallback(type, callback, params) {
        var vars = this.vars;
  
        if (arguments.length > 1) {
          if (!callback) {
            delete vars[type];
          } else {
            vars[type] = callback;
            params && (vars[type + "Params"] = params);
            type === "onUpdate" && (this._onUpdate = callback);
          }
  
          return this;
        }
  
        return vars[type];
      };
  
      _proto.then = function then(onFulfilled) {
        var self = this;
        return new Promise(function (resolve) {
          var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
              _resolve = function _resolve() {
            var _then = self.then;
            self.then = null;
            _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
            resolve(f);
            self.then = _then;
          };
  
          if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
            _resolve();
          } else {
            self._prom = _resolve;
          }
        });
      };
  
      _proto.kill = function kill() {
        _interrupt(this);
      };
  
      return Animation;
    }();
  
    _setDefaults(Animation.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: false,
      parent: null,
      _initted: false,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -_tinyNum,
      _prom: 0,
      _ps: false,
      _rts: 1
    });
  
    var Timeline = function (_Animation) {
      _inheritsLoose(Timeline, _Animation);
  
      function Timeline(vars, position) {
        var _this;
  
        if (vars === void 0) {
          vars = {};
        }
  
        _this = _Animation.call(this, vars) || this;
        _this.labels = {};
        _this.smoothChildTiming = !!vars.smoothChildTiming;
        _this.autoRemoveChildren = !!vars.autoRemoveChildren;
        _this._sort = _isNotFalse(vars.sortChildren);
        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
        vars.reversed && _this.reverse();
        vars.paused && _this.paused(true);
        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
        return _this;
      }
  
      var _proto2 = Timeline.prototype;
  
      _proto2.to = function to(targets, vars, position) {
        _createTweenType(0, arguments, this);
  
        return this;
      };
  
      _proto2.from = function from(targets, vars, position) {
        _createTweenType(1, arguments, this);
  
        return this;
      };
  
      _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
        _createTweenType(2, arguments, this);
  
        return this;
      };
  
      _proto2.set = function set(targets, vars, position) {
        vars.duration = 0;
        vars.parent = this;
        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
        vars.immediateRender = !!vars.immediateRender;
        new Tween(targets, vars, _parsePosition(this, position), 1);
        return this;
      };
  
      _proto2.call = function call(callback, params, position) {
        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
      };
  
      _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.duration = duration;
        vars.stagger = vars.stagger || stagger;
        vars.onComplete = onCompleteAll;
        vars.onCompleteParams = onCompleteAllParams;
        vars.parent = this;
        new Tween(targets, vars, _parsePosition(this, position));
        return this;
      };
  
      _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.runBackwards = 1;
        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
  
      _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
        toVars.startAt = fromVars;
        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
  
      _proto2.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time,
            tDur = this._dirty ? this.totalDuration() : this._tDur,
            dur = this._dur,
            tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
            crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
            time,
            child,
            next,
            iteration,
            cycleDuration,
            prevPaused,
            pauseTween,
            timeScale,
            prevStart,
            prevIteration,
            yoyo,
            isYoyo;
  
        if (tTime !== this._tTime || force || crossingStart) {
          if (prevTime !== this._time && dur) {
            tTime += this._time - prevTime;
            totalTime += this._time - prevTime;
          }
  
          time = tTime;
          prevStart = this._start;
          timeScale = this._ts;
          prevPaused = !timeScale;
  
          if (crossingStart) {
            dur || (prevTime = this._zTime);
            (totalTime || !suppressEvents) && (this._zTime = totalTime);
          }
  
          if (this._repeat) {
            yoyo = this._yoyo;
            cycleDuration = dur + this._rDelay;
  
            if (this._repeat < -1 && totalTime < 0) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
  
            time = _round(tTime % cycleDuration);
  
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
  
              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }
  
              time > dur && (time = dur);
            }
  
            prevIteration = _animationCycle(this._tTime, cycleDuration);
            !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration);
  
            if (yoyo && iteration & 1) {
              time = dur - time;
              isYoyo = 1;
            }
  
            if (iteration !== prevIteration && !this._lock) {
              var rewinding = yoyo && prevIteration & 1,
                  doesWrap = rewinding === (yoyo && iteration & 1);
              iteration < prevIteration && (rewinding = !rewinding);
              prevTime = rewinding ? 0 : dur;
              this._lock = 1;
              this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
              this._tTime = tTime;
              !suppressEvents && this.parent && _callback(this, "onRepeat");
              this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
  
              if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                return this;
              }
  
              dur = this._dur;
              tDur = this._tDur;
  
              if (doesWrap) {
                this._lock = 2;
                prevTime = rewinding ? dur : -0.0001;
                this.render(prevTime, true);
                this.vars.repeatRefresh && !isYoyo && this.invalidate();
              }
  
              this._lock = 0;
  
              if (!this._ts && !prevPaused) {
                return this;
              }
  
              _propagateYoyoEase(this, isYoyo);
            }
          }
  
          if (this._hasPause && !this._forcing && this._lock < 2) {
            pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));
  
            if (pauseTween) {
              tTime -= time - (time = pauseTween._start);
            }
          }
  
          this._tTime = tTime;
          this._time = time;
          this._act = !timeScale;
  
          if (!this._initted) {
            this._onUpdate = this.vars.onUpdate;
            this._initted = 1;
            this._zTime = totalTime;
            prevTime = 0;
          }
  
          if (!prevTime && time && !suppressEvents) {
            _callback(this, "onStart");
  
            if (this._tTime !== tTime) {
              return this;
            }
          }
  
          if (time >= prevTime && totalTime >= 0) {
            child = this._first;
  
            while (child) {
              next = child._next;
  
              if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
  
                child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
  
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next && (tTime += this._zTime = -_tinyNum);
                  break;
                }
              }
  
              child = next;
            }
          } else {
            child = this._last;
            var adjustedTime = totalTime < 0 ? totalTime : time;
  
            while (child) {
              next = child._prev;
  
              if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
  
                child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);
  
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                  break;
                }
              }
  
              child = next;
            }
          }
  
          if (pauseTween && !suppressEvents) {
            this.pause();
            pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
  
            if (this._ts) {
              this._start = prevStart;
  
              _setEnd(this);
  
              return this.render(totalTime, suppressEvents, force);
            }
          }
  
          this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
          if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
            (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
  
            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
              _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
  
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
  
        return this;
      };
  
      _proto2.add = function add(child, position) {
        var _this2 = this;
  
        _isNumber(position) || (position = _parsePosition(this, position, child));
  
        if (!(child instanceof Animation)) {
          if (_isArray(child)) {
            child.forEach(function (obj) {
              return _this2.add(obj, position);
            });
            return this;
          }
  
          if (_isString(child)) {
            return this.addLabel(child, position);
          }
  
          if (_isFunction(child)) {
            child = Tween.delayedCall(0, child);
          } else {
            return this;
          }
        }
  
        return this !== child ? _addToTimeline(this, child, position) : this;
      };
  
      _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
        if (nested === void 0) {
          nested = true;
        }
  
        if (tweens === void 0) {
          tweens = true;
        }
  
        if (timelines === void 0) {
          timelines = true;
        }
  
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = -_bigNum;
        }
  
        var a = [],
            child = this._first;
  
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            if (child instanceof Tween) {
              tweens && a.push(child);
            } else {
              timelines && a.push(child);
              nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
            }
          }
  
          child = child._next;
        }
  
        return a;
      };
  
      _proto2.getById = function getById(id) {
        var animations = this.getChildren(1, 1, 1),
            i = animations.length;
  
        while (i--) {
          if (animations[i].vars.id === id) {
            return animations[i];
          }
        }
      };
  
      _proto2.remove = function remove(child) {
        if (_isString(child)) {
          return this.removeLabel(child);
        }
  
        if (_isFunction(child)) {
          return this.killTweensOf(child);
        }
  
        _removeLinkedListItem(this, child);
  
        if (child === this._recent) {
          this._recent = this._last;
        }
  
        return _uncache(this);
      };
  
      _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
        if (!arguments.length) {
          return this._tTime;
        }
  
        this._forcing = 1;
  
        if (!this._dp && this._ts) {
          this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
        }
  
        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
  
        this._forcing = 0;
        return this;
      };
  
      _proto2.addLabel = function addLabel(label, position) {
        this.labels[label] = _parsePosition(this, position);
        return this;
      };
  
      _proto2.removeLabel = function removeLabel(label) {
        delete this.labels[label];
        return this;
      };
  
      _proto2.addPause = function addPause(position, callback, params) {
        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
        t.data = "isPause";
        this._hasPause = 1;
        return _addToTimeline(this, t, _parsePosition(this, position));
      };
  
      _proto2.removePause = function removePause(position) {
        var child = this._first;
        position = _parsePosition(this, position);
  
        while (child) {
          if (child._start === position && child.data === "isPause") {
            _removeFromParent(child);
          }
  
          child = child._next;
        }
      };
  
      _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        var tweens = this.getTweensOf(targets, onlyActive),
            i = tweens.length;
  
        while (i--) {
          _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
        }
  
        return this;
      };
  
      _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
        var a = [],
            parsedTargets = toArray(targets),
            child = this._first,
            isGlobalTime = _isNumber(onlyActive),
            children;
  
        while (child) {
          if (child instanceof Tween) {
            if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
              a.push(child);
            }
          } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
            a.push.apply(a, children);
          }
  
          child = child._next;
        }
  
        return a;
      };
  
      _proto2.tweenTo = function tweenTo(position, vars) {
        vars = vars || {};
  
        var tl = this,
            endTime = _parsePosition(tl, position),
            _vars = vars,
            startAt = _vars.startAt,
            _onStart = _vars.onStart,
            onStartParams = _vars.onStartParams,
            immediateRender = _vars.immediateRender,
            initted,
            tween = Tween.to(tl, _setDefaults({
          ease: vars.ease || "none",
          lazy: false,
          immediateRender: false,
          time: endTime,
          overwrite: "auto",
          duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
          onStart: function onStart() {
            tl.pause();
  
            if (!initted) {
              var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
              tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
              initted = 1;
            }
  
            _onStart && _onStart.apply(tween, onStartParams || []);
          }
        }, vars));
  
        return immediateRender ? tween.render(0) : tween;
      };
  
      _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
        return this.tweenTo(toPosition, _setDefaults({
          startAt: {
            time: _parsePosition(this, fromPosition)
          }
        }, vars));
      };
  
      _proto2.recent = function recent() {
        return this._recent;
      };
  
      _proto2.nextLabel = function nextLabel(afterTime) {
        if (afterTime === void 0) {
          afterTime = this._time;
        }
  
        return _getLabelInDirection(this, _parsePosition(this, afterTime));
      };
  
      _proto2.previousLabel = function previousLabel(beforeTime) {
        if (beforeTime === void 0) {
          beforeTime = this._time;
        }
  
        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
      };
  
      _proto2.currentLabel = function currentLabel(value) {
        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
      };
  
      _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = 0;
        }
  
        var child = this._first,
            labels = this.labels,
            p;
  
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            child._start += amount;
            child._end += amount;
          }
  
          child = child._next;
        }
  
        if (adjustLabels) {
          for (p in labels) {
            if (labels[p] >= ignoreBeforeTime) {
              labels[p] += amount;
            }
          }
        }
  
        return _uncache(this);
      };
  
      _proto2.invalidate = function invalidate() {
        var child = this._first;
        this._lock = 0;
  
        while (child) {
          child.invalidate();
          child = child._next;
        }
  
        return _Animation.prototype.invalidate.call(this);
      };
  
      _proto2.clear = function clear(includeLabels) {
        if (includeLabels === void 0) {
          includeLabels = true;
        }
  
        var child = this._first,
            next;
  
        while (child) {
          next = child._next;
          this.remove(child);
          child = next;
        }
  
        this._dp && (this._time = this._tTime = this._pTime = 0);
        includeLabels && (this.labels = {});
        return _uncache(this);
      };
  
      _proto2.totalDuration = function totalDuration(value) {
        var max = 0,
            self = this,
            child = self._last,
            prevStart = _bigNum,
            prev,
            start,
            parent;
  
        if (arguments.length) {
          return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
        }
  
        if (self._dirty) {
          parent = self.parent;
  
          while (child) {
            prev = child._prev;
            child._dirty && child.totalDuration();
            start = child._start;
  
            if (start > prevStart && self._sort && child._ts && !self._lock) {
              self._lock = 1;
              _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
            } else {
              prevStart = start;
            }
  
            if (start < 0 && child._ts) {
              max -= start;
  
              if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                self._start += start / self._ts;
                self._time -= start;
                self._tTime -= start;
              }
  
              self.shiftChildren(-start, false, -1e999);
              prevStart = 0;
            }
  
            child._end > max && child._ts && (max = child._end);
            child = prev;
          }
  
          _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
  
          self._dirty = 0;
        }
  
        return self._tDur;
      };
  
      Timeline.updateRoot = function updateRoot(time) {
        if (_globalTimeline._ts) {
          _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
  
          _lastRenderedFrame = _ticker.frame;
        }
  
        if (_ticker.frame >= _nextGCFrame) {
          _nextGCFrame += _config.autoSleep || 120;
          var child = _globalTimeline._first;
          if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
  
            child || _ticker.sleep();
          }
        }
      };
  
      return Timeline;
    }(Animation);
  
    _setDefaults(Timeline.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
    });
  
    var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
      var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
          index = 0,
          matchIndex = 0,
          result,
          startNums,
          color,
          endNum,
          chunk,
          startNum,
          hasRandom,
          a;
      pt.b = start;
      pt.e = end;
      start += "";
      end += "";
  
      if (hasRandom = ~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
  
      if (stringFilter) {
        a = [start, end];
        stringFilter(a, target, prop);
        start = a[0];
        end = a[1];
      }
  
      startNums = start.match(_complexStringNumExp) || [];
  
      while (result = _complexStringNumExp.exec(end)) {
        endNum = result[0];
        chunk = end.substring(index, result.index);
  
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(") {
          color = 1;
        }
  
        if (endNum !== startNums[matchIndex++]) {
          startNum = parseFloat(startNums[matchIndex - 1]) || 0;
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            s: startNum,
            c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
            m: color && color < 4 ? Math.round : 0
          };
          index = _complexStringNumExp.lastIndex;
        }
      }
  
      pt.c = index < end.length ? end.substring(index, end.length) : "";
      pt.fp = funcParam;
  
      if (_relExp.test(end) || hasRandom) {
        pt.e = 0;
      }
  
      this._pt = pt;
      return pt;
    },
        _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
      _isFunction(end) && (end = end(index || 0, target, targets));
      var currentValue = target[prop],
          parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
          setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
          pt;
  
      if (_isString(end)) {
        if (~end.indexOf("random(")) {
          end = _replaceRandom(end);
        }
  
        if (end.charAt(1) === "=") {
          pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
  
          if (pt || pt === 0) {
            end = pt;
          }
        }
      }
  
      if (parsedStart !== end) {
        if (!isNaN(parsedStart * end) && end !== "") {
          pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
          funcParam && (pt.fp = funcParam);
          modifier && pt.modifier(modifier, this, target);
          return this._pt = pt;
        }
  
        !currentValue && !(prop in target) && _missingPlugin(prop, end);
        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
      }
    },
        _processVars = function _processVars(vars, index, target, targets, tween) {
      _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
  
      if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
        return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
      }
  
      var copy = {},
          p;
  
      for (p in vars) {
        copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
      }
  
      return copy;
    },
        _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
      var plugin, pt, ptLookup, i;
  
      if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
  
        if (tween !== _quickTween) {
          ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
          i = plugin._props.length;
  
          while (i--) {
            ptLookup[plugin._props[i]] = pt;
          }
        }
      }
  
      return plugin;
    },
        _overwritingTween,
        _initTween = function _initTween(tween, time) {
      var vars = tween.vars,
          ease = vars.ease,
          startAt = vars.startAt,
          immediateRender = vars.immediateRender,
          lazy = vars.lazy,
          onUpdate = vars.onUpdate,
          onUpdateParams = vars.onUpdateParams,
          callbackScope = vars.callbackScope,
          runBackwards = vars.runBackwards,
          yoyoEase = vars.yoyoEase,
          keyframes = vars.keyframes,
          autoRevert = vars.autoRevert,
          dur = tween._dur,
          prevStartAt = tween._startAt,
          targets = tween._targets,
          parent = tween.parent,
          fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
          autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
          tl = tween.timeline,
          cleanVars,
          i,
          p,
          pt,
          target,
          hasPriority,
          gsData,
          harness,
          plugin,
          ptLookup,
          index,
          harnessVars,
          overwritten;
      tl && (!keyframes || !ease) && (ease = "none");
      tween._ease = _parseEase(ease, _defaults.ease);
      tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
  
      if (yoyoEase && tween._yoyo && !tween._repeat) {
        yoyoEase = tween._yEase;
        tween._yEase = tween._ease;
        tween._ease = yoyoEase;
      }
  
      tween._from = !tl && !!vars.runBackwards;
  
      if (!tl) {
        harness = targets[0] ? _getCache(targets[0]).harness : 0;
        harnessVars = harness && vars[harness.prop];
        cleanVars = _copyExcluding(vars, _reservedProps);
        prevStartAt && prevStartAt.render(-1, true).kill();
  
        if (startAt) {
          _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
            data: "isStart",
            overwrite: false,
            parent: parent,
            immediateRender: true,
            lazy: _isNotFalse(lazy),
            startAt: null,
            delay: 0,
            onUpdate: onUpdate,
            onUpdateParams: onUpdateParams,
            callbackScope: callbackScope,
            stagger: 0
          }, startAt)));
  
          time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true);
  
          if (immediateRender) {
            time > 0 && !autoRevert && (tween._startAt = 0);
  
            if (dur && time <= 0) {
              time && (tween._zTime = time);
              return;
            }
          } else if (autoRevert === false) {
            tween._startAt = 0;
          }
        } else if (runBackwards && dur) {
          if (prevStartAt) {
            !autoRevert && (tween._startAt = 0);
          } else {
            time && (immediateRender = false);
            p = _setDefaults({
              overwrite: false,
              data: "isFromStart",
              lazy: immediateRender && _isNotFalse(lazy),
              immediateRender: immediateRender,
              stagger: 0,
              parent: parent
            }, cleanVars);
            harnessVars && (p[harness.prop] = harnessVars);
  
            _removeFromParent(tween._startAt = Tween.set(targets, p));
  
            time < 0 && tween._startAt.render(-1, true);
  
            if (!immediateRender) {
              _initTween(tween._startAt, _tinyNum);
            } else if (!time) {
              return;
            }
          }
        }
  
        tween._pt = 0;
        lazy = dur && _isNotFalse(lazy) || lazy && !dur;
  
        for (i = 0; i < targets.length; i++) {
          target = targets[i];
          gsData = target._gsap || _harness(targets)[i]._gsap;
          tween._ptLookup[i] = ptLookup = {};
          _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
          index = fullTargets === targets ? i : fullTargets.indexOf(target);
  
          if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
            tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
  
            plugin._props.forEach(function (name) {
              ptLookup[name] = pt;
            });
  
            plugin.priority && (hasPriority = 1);
          }
  
          if (!harness || harnessVars) {
            for (p in cleanVars) {
              if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
                plugin.priority && (hasPriority = 1);
              } else {
                ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
              }
            }
          }
  
          tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
  
          if (autoOverwrite && tween._pt) {
            _overwritingTween = tween;
  
            _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0));
  
            overwritten = !tween.parent;
            _overwritingTween = 0;
          }
  
          tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
        }
  
        hasPriority && _sortPropTweensByPriority(tween);
        tween._onInit && tween._onInit(tween);
      }
  
      tween._onUpdate = onUpdate;
      tween._initted = (!tween._op || tween._pt) && !overwritten;
    },
        _addAliasesToVars = function _addAliasesToVars(targets, vars) {
      var harness = targets[0] ? _getCache(targets[0]).harness : 0,
          propertyAliases = harness && harness.aliases,
          copy,
          p,
          i,
          aliases;
  
      if (!propertyAliases) {
        return vars;
      }
  
      copy = _merge({}, vars);
  
      for (p in propertyAliases) {
        if (p in copy) {
          aliases = propertyAliases[p].split(",");
          i = aliases.length;
  
          while (i--) {
            copy[aliases[i]] = copy[p];
          }
        }
      }
  
      return copy;
    },
        _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
      return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
    },
        _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
        _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
  
    var Tween = function (_Animation2) {
      _inheritsLoose(Tween, _Animation2);
  
      function Tween(targets, vars, position, skipInherit) {
        var _this3;
  
        if (typeof vars === "number") {
          position.duration = vars;
          vars = position;
          position = null;
        }
  
        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
        var _this3$vars = _this3.vars,
            duration = _this3$vars.duration,
            delay = _this3$vars.delay,
            immediateRender = _this3$vars.immediateRender,
            stagger = _this3$vars.stagger,
            overwrite = _this3$vars.overwrite,
            keyframes = _this3$vars.keyframes,
            defaults = _this3$vars.defaults,
            scrollTrigger = _this3$vars.scrollTrigger,
            yoyoEase = _this3$vars.yoyoEase,
            parent = vars.parent || _globalTimeline,
            parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
            tl,
            i,
            copy,
            l,
            p,
            curTarget,
            staggerFunc,
            staggerVarsToMerge;
        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
        _this3._ptLookup = [];
        _this3._overwrite = overwrite;
  
        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          vars = _this3.vars;
          tl = _this3.timeline = new Timeline({
            data: "nested",
            defaults: defaults || {}
          });
          tl.kill();
          tl.parent = tl._dp = _assertThisInitialized(_this3);
          tl._start = 0;
  
          if (keyframes) {
            _setDefaults(tl.vars.defaults, {
              ease: "none"
            });
  
            stagger ? parsedTargets.forEach(function (t, i) {
              return keyframes.forEach(function (frame, j) {
                return tl.to(t, frame, j ? ">" : i * stagger);
              });
            }) : keyframes.forEach(function (frame) {
              return tl.to(parsedTargets, frame, ">");
            });
          } else {
            l = parsedTargets.length;
            staggerFunc = stagger ? distribute(stagger) : _emptyFunc;
  
            if (_isObject(stagger)) {
              for (p in stagger) {
                if (~_staggerTweenProps.indexOf(p)) {
                  staggerVarsToMerge || (staggerVarsToMerge = {});
                  staggerVarsToMerge[p] = stagger[p];
                }
              }
            }
  
            for (i = 0; i < l; i++) {
              copy = {};
  
              for (p in vars) {
                if (_staggerPropsToSkip.indexOf(p) < 0) {
                  copy[p] = vars[p];
                }
              }
  
              copy.stagger = 0;
              yoyoEase && (copy.yoyoEase = yoyoEase);
              staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
              curTarget = parsedTargets[i];
              copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
              copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
  
              if (!stagger && l === 1 && copy.delay) {
                _this3._delay = delay = copy.delay;
                _this3._start += delay;
                copy.delay = 0;
              }
  
              tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
            }
  
            tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
          }
  
          duration || _this3.duration(duration = tl.duration());
        } else {
          _this3.timeline = 0;
        }
  
        if (overwrite === true && !_suppressOverwrites) {
          _overwritingTween = _assertThisInitialized(_this3);
  
          _globalTimeline.killTweensOf(parsedTargets);
  
          _overwritingTween = 0;
        }
  
        _addToTimeline(parent, _assertThisInitialized(_this3), position);
  
        vars.reversed && _this3.reverse();
        vars.paused && _this3.paused(true);
  
        if (immediateRender || !duration && !keyframes && _this3._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
          _this3._tTime = -_tinyNum;
  
          _this3.render(Math.max(0, -delay));
        }
  
        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
        return _this3;
      }
  
      var _proto3 = Tween.prototype;
  
      _proto3.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time,
            tDur = this._tDur,
            dur = this._dur,
            tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
            time,
            pt,
            iteration,
            cycleDuration,
            prevIteration,
            isYoyo,
            ratio,
            timeline,
            yoyoEase;
  
        if (!dur) {
          _renderZeroDurationTween(this, totalTime, suppressEvents, force);
        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
          time = tTime;
          timeline = this.timeline;
  
          if (this._repeat) {
            cycleDuration = dur + this._rDelay;
  
            if (this._repeat < -1 && totalTime < 0) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
  
            time = _round(tTime % cycleDuration);
  
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
  
              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }
  
              time > dur && (time = dur);
            }
  
            isYoyo = this._yoyo && iteration & 1;
  
            if (isYoyo) {
              yoyoEase = this._yEase;
              time = dur - time;
            }
  
            prevIteration = _animationCycle(this._tTime, cycleDuration);
  
            if (time === prevTime && !force && this._initted) {
              return this;
            }
  
            if (iteration !== prevIteration) {
              timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
  
              if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                this._lock = force = 1;
                this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;
              }
            }
          }
  
          if (!this._initted) {
            if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
              this._tTime = 0;
              return this;
            }
  
            if (dur !== this._dur) {
              return this.render(totalTime, suppressEvents, force);
            }
          }
  
          this._tTime = tTime;
          this._time = time;
  
          if (!this._act && this._ts) {
            this._act = 1;
            this._lazy = 0;
          }
  
          this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
  
          if (this._from) {
            this.ratio = ratio = 1 - ratio;
          }
  
          if (time && !prevTime && !suppressEvents) {
            _callback(this, "onStart");
  
            if (this._tTime !== tTime) {
              return this;
            }
          }
  
          pt = this._pt;
  
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
  
          timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);
  
          if (this._onUpdate && !suppressEvents) {
            totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force);
  
            _callback(this, "onUpdate");
          }
  
          this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
  
          if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
            totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
            (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
  
            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
              _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
  
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
  
        return this;
      };
  
      _proto3.targets = function targets() {
        return this._targets;
      };
  
      _proto3.invalidate = function invalidate() {
        this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
        this._ptLookup = [];
        this.timeline && this.timeline.invalidate();
        return _Animation2.prototype.invalidate.call(this);
      };
  
      _proto3.kill = function kill(targets, vars) {
        if (vars === void 0) {
          vars = "all";
        }
  
        if (!targets && (!vars || vars === "all")) {
          this._lazy = this._pt = 0;
          return this.parent ? _interrupt(this) : this;
        }
  
        if (this.timeline) {
          var tDur = this.timeline.totalDuration();
          this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
          this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
          return this;
        }
  
        var parsedTargets = this._targets,
            killingTargets = targets ? toArray(targets) : parsedTargets,
            propTweenLookup = this._ptLookup,
            firstPT = this._pt,
            overwrittenProps,
            curLookup,
            curOverwriteProps,
            props,
            p,
            pt,
            i;
  
        if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
          vars === "all" && (this._pt = 0);
          return _interrupt(this);
        }
  
        overwrittenProps = this._op = this._op || [];
  
        if (vars !== "all") {
          if (_isString(vars)) {
            p = {};
  
            _forEachName(vars, function (name) {
              return p[name] = 1;
            });
  
            vars = p;
          }
  
          vars = _addAliasesToVars(parsedTargets, vars);
        }
  
        i = parsedTargets.length;
  
        while (i--) {
          if (~killingTargets.indexOf(parsedTargets[i])) {
            curLookup = propTweenLookup[i];
  
            if (vars === "all") {
              overwrittenProps[i] = vars;
              props = curLookup;
              curOverwriteProps = {};
            } else {
              curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
              props = vars;
            }
  
            for (p in props) {
              pt = curLookup && curLookup[p];
  
              if (pt) {
                if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                  _removeLinkedListItem(this, pt, "_pt");
                }
  
                delete curLookup[p];
              }
  
              if (curOverwriteProps !== "all") {
                curOverwriteProps[p] = 1;
              }
            }
          }
        }
  
        this._initted && !this._pt && firstPT && _interrupt(this);
        return this;
      };
  
      Tween.to = function to(targets, vars) {
        return new Tween(targets, vars, arguments[2]);
      };
  
      Tween.from = function from(targets, vars) {
        return _createTweenType(1, arguments);
      };
  
      Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
        return new Tween(callback, 0, {
          immediateRender: false,
          lazy: false,
          overwrite: false,
          delay: delay,
          onComplete: callback,
          onReverseComplete: callback,
          onCompleteParams: params,
          onReverseCompleteParams: params,
          callbackScope: scope
        });
      };
  
      Tween.fromTo = function fromTo(targets, fromVars, toVars) {
        return _createTweenType(2, arguments);
      };
  
      Tween.set = function set(targets, vars) {
        vars.duration = 0;
        vars.repeatDelay || (vars.repeat = 0);
        return new Tween(targets, vars);
      };
  
      Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        return _globalTimeline.killTweensOf(targets, props, onlyActive);
      };
  
      return Tween;
    }(Animation);
  
    _setDefaults(Tween.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
    });
  
    _forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
      Tween[name] = function () {
        var tl = new Timeline(),
            params = _slice.call(arguments, 0);
  
        params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
        return tl[name].apply(tl, params);
      };
    });
  
    var _setterPlain = function _setterPlain(target, property, value) {
      return target[property] = value;
    },
        _setterFunc = function _setterFunc(target, property, value) {
      return target[property](value);
    },
        _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
      return target[property](data.fp, value);
    },
        _setterAttribute = function _setterAttribute(target, property, value) {
      return target.setAttribute(property, value);
    },
        _getSetter = function _getSetter(target, property) {
      return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
    },
        _renderPlain = function _renderPlain(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
    },
        _renderBoolean = function _renderBoolean(ratio, data) {
      return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
    },
        _renderComplexString = function _renderComplexString(ratio, data) {
      var pt = data._pt,
          s = "";
  
      if (!ratio && data.b) {
        s = data.b;
      } else if (ratio === 1 && data.e) {
        s = data.e;
      } else {
        while (pt) {
          s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s;
          pt = pt._next;
        }
  
        s += data.c;
      }
  
      data.set(data.t, data.p, s, data);
    },
        _renderPropTweens = function _renderPropTweens(ratio, data) {
      var pt = data._pt;
  
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    },
        _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
      var pt = this._pt,
          next;
  
      while (pt) {
        next = pt._next;
        pt.p === property && pt.modifier(modifier, tween, target);
        pt = next;
      }
    },
        _killPropTweensOf = function _killPropTweensOf(property) {
      var pt = this._pt,
          hasNonDependentRemaining,
          next;
  
      while (pt) {
        next = pt._next;
  
        if (pt.p === property && !pt.op || pt.op === property) {
          _removeLinkedListItem(this, pt, "_pt");
        } else if (!pt.dep) {
          hasNonDependentRemaining = 1;
        }
  
        pt = next;
      }
  
      return !hasNonDependentRemaining;
    },
        _setterWithModifier = function _setterWithModifier(target, property, value, data) {
      data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
    },
        _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
      var pt = parent._pt,
          next,
          pt2,
          first,
          last;
  
      while (pt) {
        next = pt._next;
        pt2 = first;
  
        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }
  
        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }
  
        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }
  
        pt = next;
      }
  
      parent._pt = first;
    };
  
    var PropTween = function () {
      function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
        this.t = target;
        this.s = start;
        this.c = change;
        this.p = prop;
        this.r = renderer || _renderPlain;
        this.d = data || this;
        this.set = setter || _setterPlain;
        this.pr = priority || 0;
        this._next = next;
  
        if (next) {
          next._prev = this;
        }
      }
  
      var _proto4 = PropTween.prototype;
  
      _proto4.modifier = function modifier(func, tween, target) {
        this.mSet = this.mSet || this.set;
        this.set = _setterWithModifier;
        this.m = func;
        this.mt = target;
        this.tween = tween;
      };
  
      return PropTween;
    }();
  
    _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
      return _reservedProps[name] = 1;
    });
  
    _globals.TweenMax = _globals.TweenLite = Tween;
    _globals.TimelineLite = _globals.TimelineMax = Timeline;
    _globalTimeline = new Timeline({
      sortChildren: false,
      defaults: _defaults,
      autoRemoveChildren: true,
      id: "root",
      smoothChildTiming: true
    });
    _config.stringFilter = _colorStringFilter;
    var _gsap = {
      registerPlugin: function registerPlugin() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
  
        args.forEach(function (config) {
          return _createPlugin(config);
        });
      },
      timeline: function timeline(vars) {
        return new Timeline(vars);
      },
      getTweensOf: function getTweensOf(targets, onlyActive) {
        return _globalTimeline.getTweensOf(targets, onlyActive);
      },
      getProperty: function getProperty(target, property, unit, uncache) {
        _isString(target) && (target = toArray(target)[0]);
  
        var getter = _getCache(target || {}).get,
            format = unit ? _passThrough : _numericIfPossible;
  
        unit === "native" && (unit = "");
        return !target ? target : !property ? function (property, unit, uncache) {
          return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      },
      quickSetter: function quickSetter(target, property, unit) {
        target = toArray(target);
  
        if (target.length > 1) {
          var setters = target.map(function (t) {
            return gsap.quickSetter(t, property, unit);
          }),
              l = setters.length;
          return function (value) {
            var i = l;
  
            while (i--) {
              setters[i](value);
            }
          };
        }
  
        target = target[0] || {};
  
        var Plugin = _plugins[property],
            cache = _getCache(target),
            p = cache.harness && (cache.harness.aliases || {})[property] || property,
            setter = Plugin ? function (value) {
          var p = new Plugin();
          _quickTween._pt = 0;
          p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
          p.render(1, p);
          _quickTween._pt && _renderPropTweens(1, _quickTween);
        } : cache.set(target, p);
  
        return Plugin ? setter : function (value) {
          return setter(target, p, unit ? value + unit : value, cache, 1);
        };
      },
      isTweening: function isTweening(targets) {
        return _globalTimeline.getTweensOf(targets, true).length > 0;
      },
      defaults: function defaults(value) {
        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
        return _mergeDeep(_defaults, value || {});
      },
      config: function config(value) {
        return _mergeDeep(_config, value || {});
      },
      registerEffect: function registerEffect(_ref3) {
        var name = _ref3.name,
            effect = _ref3.effect,
            plugins = _ref3.plugins,
            defaults = _ref3.defaults,
            extendTimeline = _ref3.extendTimeline;
        (plugins || "").split(",").forEach(function (pluginName) {
          return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
        });
  
        _effects[name] = function (targets, vars, tl) {
          return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
        };
  
        if (extendTimeline) {
          Timeline.prototype[name] = function (targets, vars, position) {
            return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
          };
        }
      },
      registerEase: function registerEase(name, ease) {
        _easeMap[name] = _parseEase(ease);
      },
      parseEase: function parseEase(ease, defaultEase) {
        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
      },
      getById: function getById(id) {
        return _globalTimeline.getById(id);
      },
      exportRoot: function exportRoot(vars, includeDelayedCalls) {
        if (vars === void 0) {
          vars = {};
        }
  
        var tl = new Timeline(vars),
            child,
            next;
        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
  
        _globalTimeline.remove(tl);
  
        tl._dp = 0;
        tl._time = tl._tTime = _globalTimeline._time;
        child = _globalTimeline._first;
  
        while (child) {
          next = child._next;
  
          if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
            _addToTimeline(tl, child, child._start - child._delay);
          }
  
          child = next;
        }
  
        _addToTimeline(_globalTimeline, tl, 0);
  
        return tl;
      },
      utils: {
        wrap: wrap,
        wrapYoyo: wrapYoyo,
        distribute: distribute,
        random: random,
        snap: snap,
        normalize: normalize,
        getUnit: getUnit,
        clamp: clamp,
        splitColor: splitColor,
        toArray: toArray,
        selector: selector,
        mapRange: mapRange,
        pipe: pipe,
        unitize: unitize,
        interpolate: interpolate,
        shuffle: shuffle
      },
      install: _install,
      effects: _effects,
      ticker: _ticker,
      updateRoot: Timeline.updateRoot,
      plugins: _plugins,
      globalTimeline: _globalTimeline,
      core: {
        PropTween: PropTween,
        globals: _addGlobal,
        Tween: Tween,
        Timeline: Timeline,
        Animation: Animation,
        getCache: _getCache,
        _removeLinkedListItem: _removeLinkedListItem,
        suppressOverwrites: function suppressOverwrites(value) {
          return _suppressOverwrites = value;
        }
      }
    };
  
    _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
      return _gsap[name] = Tween[name];
    });
  
    _ticker.add(Timeline.updateRoot);
  
    _quickTween = _gsap.to({}, {
      duration: 0
    });
  
    var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
      var pt = plugin._pt;
  
      while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
        pt = pt._next;
      }
  
      return pt;
    },
        _addModifiers = function _addModifiers(tween, modifiers) {
      var targets = tween._targets,
          p,
          i,
          pt;
  
      for (p in modifiers) {
        i = targets.length;
  
        while (i--) {
          pt = tween._ptLookup[i][p];
  
          if (pt && (pt = pt.d)) {
            if (pt._pt) {
              pt = _getPluginPropTween(pt, p);
            }
  
            pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
          }
        }
      }
    },
        _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
      return {
        name: name,
        rawVars: 1,
        init: function init(target, vars, tween) {
          tween._onInit = function (tween) {
            var temp, p;
  
            if (_isString(vars)) {
              temp = {};
  
              _forEachName(vars, function (name) {
                return temp[name] = 1;
              });
  
              vars = temp;
            }
  
            if (modifier) {
              temp = {};
  
              for (p in vars) {
                temp[p] = modifier(vars[p]);
              }
  
              vars = temp;
            }
  
            _addModifiers(tween, vars);
          };
        }
      };
    };
  
    var gsap = _gsap.registerPlugin({
      name: "attr",
      init: function init(target, vars, tween, index, targets) {
        var p, pt;
  
        for (p in vars) {
          pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
          pt && (pt.op = p);
  
          this._props.push(p);
        }
      }
    }, {
      name: "endArray",
      init: function init(target, value) {
        var i = value.length;
  
        while (i--) {
          this.add(target, i, target[i] || 0, value[i]);
        }
      }
    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
    Tween.version = Timeline.version = gsap.version = "3.7.1";
    _coreReady = 1;
    _windowExists() && _wake();
    var Power0 = _easeMap.Power0,
        Power1 = _easeMap.Power1,
        Power2 = _easeMap.Power2,
        Power3 = _easeMap.Power3,
        Power4 = _easeMap.Power4,
        Linear = _easeMap.Linear,
        Quad = _easeMap.Quad,
        Cubic = _easeMap.Cubic,
        Quart = _easeMap.Quart,
        Quint = _easeMap.Quint,
        Strong = _easeMap.Strong,
        Elastic = _easeMap.Elastic,
        Back = _easeMap.Back,
        SteppedEase = _easeMap.SteppedEase,
        Bounce = _easeMap.Bounce,
        Sine = _easeMap.Sine,
        Expo = _easeMap.Expo,
        Circ = _easeMap.Circ;
  
    var _win$1,
        _doc$1,
        _docElement,
        _pluginInitted,
        _tempDiv,
        _tempDivStyler,
        _recentSetterPlugin,
        _windowExists$1 = function _windowExists() {
      return typeof window !== "undefined";
    },
        _transformProps = {},
        _RAD2DEG = 180 / Math.PI,
        _DEG2RAD = Math.PI / 180,
        _atan2 = Math.atan2,
        _bigNum$1 = 1e8,
        _capsExp = /([A-Z])/g,
        _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
        _complexExp = /[\s,\(]\S/,
        _propertyAliases = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    },
        _renderCSSProp = function _renderCSSProp(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
    },
        _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
      return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
    },
        _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
      return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
    },
        _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
      var value = data.s + data.c * ratio;
      data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
    },
        _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
      return data.set(data.t, data.p, ratio ? data.e : data.b, data);
    },
        _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
      return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
    },
        _setterCSSStyle = function _setterCSSStyle(target, property, value) {
      return target.style[property] = value;
    },
        _setterCSSProp = function _setterCSSProp(target, property, value) {
      return target.style.setProperty(property, value);
    },
        _setterTransform = function _setterTransform(target, property, value) {
      return target._gsap[property] = value;
    },
        _setterScale = function _setterScale(target, property, value) {
      return target._gsap.scaleX = target._gsap.scaleY = value;
    },
        _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache.scaleX = cache.scaleY = value;
      cache.renderTransform(ratio, cache);
    },
        _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache[property] = value;
      cache.renderTransform(ratio, cache);
    },
        _transformProp = "transform",
        _transformOriginProp = _transformProp + "Origin",
        _supports3D,
        _createElement = function _createElement(type, ns) {
      var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$1.createElement(type);
      return e.style ? e : _doc$1.createElement(type);
    },
        _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
      var cs = getComputedStyle(target);
      return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || "";
    },
        _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
        _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
      var e = element || _tempDiv,
          s = e.style,
          i = 5;
  
      if (property in s && !preferPrefix) {
        return property;
      }
  
      property = property.charAt(0).toUpperCase() + property.substr(1);
  
      while (i-- && !(_prefixes[i] + property in s)) {}
  
      return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
    },
        _initCore = function _initCore() {
      if (_windowExists$1() && window.document) {
        _win$1 = window;
        _doc$1 = _win$1.document;
        _docElement = _doc$1.documentElement;
        _tempDiv = _createElement("div") || {
          style: {}
        };
        _tempDivStyler = _createElement("div");
        _transformProp = _checkPropPrefix(_transformProp);
        _transformOriginProp = _transformProp + "Origin";
        _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
        _supports3D = !!_checkPropPrefix("perspective");
        _pluginInitted = 1;
      }
    },
        _getBBoxHack = function _getBBoxHack(swapIfPossible) {
      var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
          oldParent = this.parentNode,
          oldSibling = this.nextSibling,
          oldCSS = this.style.cssText,
          bbox;
  
      _docElement.appendChild(svg);
  
      svg.appendChild(this);
      this.style.display = "block";
  
      if (swapIfPossible) {
        try {
          bbox = this.getBBox();
          this._gsapBBox = this.getBBox;
          this.getBBox = _getBBoxHack;
        } catch (e) {}
      } else if (this._gsapBBox) {
        bbox = this._gsapBBox();
      }
  
      if (oldParent) {
        if (oldSibling) {
          oldParent.insertBefore(this, oldSibling);
        } else {
          oldParent.appendChild(this);
        }
      }
  
      _docElement.removeChild(svg);
  
      this.style.cssText = oldCSS;
      return bbox;
    },
        _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
      var i = attributesArray.length;
  
      while (i--) {
        if (target.hasAttribute(attributesArray[i])) {
          return target.getAttribute(attributesArray[i]);
        }
      }
    },
        _getBBox = function _getBBox(target) {
      var bounds;
  
      try {
        bounds = target.getBBox();
      } catch (error) {
        bounds = _getBBoxHack.call(target, true);
      }
  
      bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
      return bounds && !bounds.width && !bounds.x && !bounds.y ? {
        x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
        y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
      } : bounds;
    },
        _isSVG = function _isSVG(e) {
      return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
    },
        _removeProperty = function _removeProperty(target, property) {
      if (property) {
        var style = target.style;
  
        if (property in _transformProps && property !== _transformOriginProp) {
          property = _transformProp;
        }
  
        if (style.removeProperty) {
          if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
            property = "-" + property;
          }
  
          style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
        } else {
          style.removeAttribute(property);
        }
      }
    },
        _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
      var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
      plugin._pt = pt;
      pt.b = beginning;
      pt.e = end;
  
      plugin._props.push(property);
  
      return pt;
    },
        _nonConvertibleUnits = {
      deg: 1,
      rad: 1,
      turn: 1
    },
        _convertToUnit = function _convertToUnit(target, property, value, unit) {
      var curValue = parseFloat(value) || 0,
          curUnit = (value + "").trim().substr((curValue + "").length) || "px",
          style = _tempDiv.style,
          horizontal = _horizontalExp.test(property),
          isRootSVG = target.tagName.toLowerCase() === "svg",
          measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
          amount = 100,
          toPixels = unit === "px",
          toPercent = unit === "%",
          px,
          parent,
          cache,
          isSVG;
  
      if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
        return curValue;
      }
  
      curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
      isSVG = target.getCTM && _isSVG(target);
  
      if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
        px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
        return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
      }
  
      style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
      parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
  
      if (isSVG) {
        parent = (target.ownerSVGElement || {}).parentNode;
      }
  
      if (!parent || parent === _doc$1 || !parent.appendChild) {
        parent = _doc$1.body;
      }
  
      cache = parent._gsap;
  
      if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {
        return _round(curValue / cache.width * amount);
      } else {
        (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static");
        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
  
        if (horizontal && toPercent) {
          cache = _getCache(parent);
          cache.time = _ticker.time;
          cache.width = parent[measureProperty];
        }
      }
  
      return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
    },
        _get = function _get(target, property, unit, uncache) {
      var value;
      _pluginInitted || _initCore();
  
      if (property in _propertyAliases && property !== "transform") {
        property = _propertyAliases[property];
  
        if (~property.indexOf(",")) {
          property = property.split(",")[0];
        }
      }
  
      if (_transformProps[property] && property !== "transform") {
        value = _parseTransform(target, uncache);
        value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
      } else {
        value = target.style[property];
  
        if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
          value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
        }
      }
  
      return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
    },
        _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
      if (!start || start === "none") {
        var p = _checkPropPrefix(prop, target, 1),
            s = p && _getComputedProperty(target, p, 1);
  
        if (s && s !== start) {
          prop = p;
          start = s;
        } else if (prop === "borderColor") {
          start = _getComputedProperty(target, "borderTopColor");
        }
      }
  
      var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
          index = 0,
          matchIndex = 0,
          a,
          result,
          startValues,
          startNum,
          color,
          startValue,
          endValue,
          endNum,
          chunk,
          endUnit,
          startUnit,
          relative,
          endValues;
      pt.b = start;
      pt.e = end;
      start += "";
      end += "";
  
      if (end === "auto") {
        target.style[prop] = end;
        end = _getComputedProperty(target, prop) || end;
        target.style[prop] = start;
      }
  
      a = [start, end];
  
      _colorStringFilter(a);
  
      start = a[0];
      end = a[1];
      startValues = start.match(_numWithUnitExp) || [];
      endValues = end.match(_numWithUnitExp) || [];
  
      if (endValues.length) {
        while (result = _numWithUnitExp.exec(end)) {
          endValue = result[0];
          chunk = end.substring(index, result.index);
  
          if (color) {
            color = (color + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
            color = 1;
          }
  
          if (endValue !== (startValue = startValues[matchIndex++] || "")) {
            startNum = parseFloat(startValue) || 0;
            startUnit = startValue.substr((startNum + "").length);
            relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
  
            if (relative) {
              endValue = endValue.substr(2);
            }
  
            endNum = parseFloat(endValue);
            endUnit = endValue.substr((endNum + "").length);
            index = _numWithUnitExp.lastIndex - endUnit.length;
  
            if (!endUnit) {
              endUnit = endUnit || _config.units[prop] || startUnit;
  
              if (index === end.length) {
                end += endUnit;
                pt.e += endUnit;
              }
            }
  
            if (startUnit !== endUnit) {
              startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
            }
  
            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              s: startNum,
              c: relative ? relative * endNum : endNum - startNum,
              m: color && color < 4 || prop === "zIndex" ? Math.round : 0
            };
          }
        }
  
        pt.c = index < end.length ? end.substring(index, end.length) : "";
      } else {
        pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
      }
  
      _relExp.test(end) && (pt.e = 0);
      this._pt = pt;
      return pt;
    },
        _keywordToPercent = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    },
        _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
      var split = value.split(" "),
          x = split[0],
          y = split[1] || "50%";
  
      if (x === "top" || x === "bottom" || y === "left" || y === "right") {
        value = x;
        x = y;
        y = value;
      }
  
      split[0] = _keywordToPercent[x] || x;
      split[1] = _keywordToPercent[y] || y;
      return split.join(" ");
    },
        _renderClearProps = function _renderClearProps(ratio, data) {
      if (data.tween && data.tween._time === data.tween._dur) {
        var target = data.t,
            style = target.style,
            props = data.u,
            cache = target._gsap,
            prop,
            clearTransforms,
            i;
  
        if (props === "all" || props === true) {
          style.cssText = "";
          clearTransforms = 1;
        } else {
          props = props.split(",");
          i = props.length;
  
          while (--i > -1) {
            prop = props[i];
  
            if (_transformProps[prop]) {
              clearTransforms = 1;
              prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
            }
  
            _removeProperty(target, prop);
          }
        }
  
        if (clearTransforms) {
          _removeProperty(target, _transformProp);
  
          if (cache) {
            cache.svg && target.removeAttribute("transform");
  
            _parseTransform(target, 1);
  
            cache.uncache = 1;
          }
        }
      }
    },
        _specialProps = {
      clearProps: function clearProps(plugin, target, property, endValue, tween) {
        if (tween.data !== "isFromStart") {
          var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
          pt.u = endValue;
          pt.pr = -10;
          pt.tween = tween;
  
          plugin._props.push(property);
  
          return 1;
        }
      }
    },
        _identity2DMatrix = [1, 0, 0, 1, 0, 0],
        _rotationalProperties = {},
        _isNullTransform = function _isNullTransform(value) {
      return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
    },
        _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
      var matrixString = _getComputedProperty(target, _transformProp);
  
      return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
    },
        _getMatrix = function _getMatrix(target, force2D) {
      var cache = target._gsap || _getCache(target),
          style = target.style,
          matrix = _getComputedTransformMatrixAsArray(target),
          parent,
          nextSibling,
          temp,
          addedToDOM;
  
      if (cache.svg && target.getAttribute("transform")) {
        temp = target.transform.baseVal.consolidate().matrix;
        matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
        return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
      } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
        temp = style.display;
        style.display = "block";
        parent = target.parentNode;
  
        if (!parent || !target.offsetParent) {
          addedToDOM = 1;
          nextSibling = target.nextSibling;
  
          _docElement.appendChild(target);
        }
  
        matrix = _getComputedTransformMatrixAsArray(target);
        temp ? style.display = temp : _removeProperty(target, "display");
  
        if (addedToDOM) {
          nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
        }
      }
  
      return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
    },
        _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
      var cache = target._gsap,
          matrix = matrixArray || _getMatrix(target, true),
          xOriginOld = cache.xOrigin || 0,
          yOriginOld = cache.yOrigin || 0,
          xOffsetOld = cache.xOffset || 0,
          yOffsetOld = cache.yOffset || 0,
          a = matrix[0],
          b = matrix[1],
          c = matrix[2],
          d = matrix[3],
          tx = matrix[4],
          ty = matrix[5],
          originSplit = origin.split(" "),
          xOrigin = parseFloat(originSplit[0]) || 0,
          yOrigin = parseFloat(originSplit[1]) || 0,
          bounds,
          determinant,
          x,
          y;
  
      if (!originIsAbsolute) {
        bounds = _getBBox(target);
        xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
      } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
        xOrigin = x;
        yOrigin = y;
      }
  
      if (smooth || smooth !== false && cache.smooth) {
        tx = xOrigin - xOriginOld;
        ty = yOrigin - yOriginOld;
        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
      } else {
        cache.xOffset = cache.yOffset = 0;
      }
  
      cache.xOrigin = xOrigin;
      cache.yOrigin = yOrigin;
      cache.smooth = !!smooth;
      cache.origin = origin;
      cache.originIsAbsolute = !!originIsAbsolute;
      target.style[_transformOriginProp] = "0px 0px";
  
      if (pluginToAddPropTweensTo) {
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
  
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
  
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
  
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
      }
  
      target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
    },
        _parseTransform = function _parseTransform(target, uncache) {
      var cache = target._gsap || new GSCache(target);
  
      if ("x" in cache && !uncache && !cache.uncache) {
        return cache;
      }
  
      var style = target.style,
          invertedScaleX = cache.scaleX < 0,
          px = "px",
          deg = "deg",
          origin = _getComputedProperty(target, _transformOriginProp) || "0",
          x,
          y,
          z,
          scaleX,
          scaleY,
          rotation,
          rotationX,
          rotationY,
          skewX,
          skewY,
          perspective,
          xOrigin,
          yOrigin,
          matrix,
          angle,
          cos,
          sin,
          a,
          b,
          c,
          d,
          a12,
          a22,
          t1,
          t2,
          t3,
          a13,
          a23,
          a33,
          a42,
          a43,
          a32;
      x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
      scaleX = scaleY = 1;
      cache.svg = !!(target.getCTM && _isSVG(target));
      matrix = _getMatrix(target, cache.svg);
  
      if (cache.svg) {
        t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin");
  
        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
      }
  
      xOrigin = cache.xOrigin || 0;
      yOrigin = cache.yOrigin || 0;
  
      if (matrix !== _identity2DMatrix) {
        a = matrix[0];
        b = matrix[1];
        c = matrix[2];
        d = matrix[3];
        x = a12 = matrix[4];
        y = a22 = matrix[5];
  
        if (matrix.length === 6) {
          scaleX = Math.sqrt(a * a + b * b);
          scaleY = Math.sqrt(d * d + c * c);
          rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
          skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
          skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
  
          if (cache.svg) {
            x -= xOrigin - (xOrigin * a + yOrigin * c);
            y -= yOrigin - (xOrigin * b + yOrigin * d);
          }
        } else {
          a32 = matrix[6];
          a42 = matrix[7];
          a13 = matrix[8];
          a23 = matrix[9];
          a33 = matrix[10];
          a43 = matrix[11];
          x = matrix[12];
          y = matrix[13];
          z = matrix[14];
          angle = _atan2(a32, a33);
          rotationX = angle * _RAD2DEG;
  
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a12 * cos + a13 * sin;
            t2 = a22 * cos + a23 * sin;
            t3 = a32 * cos + a33 * sin;
            a13 = a12 * -sin + a13 * cos;
            a23 = a22 * -sin + a23 * cos;
            a33 = a32 * -sin + a33 * cos;
            a43 = a42 * -sin + a43 * cos;
            a12 = t1;
            a22 = t2;
            a32 = t3;
          }
  
          angle = _atan2(-c, a33);
          rotationY = angle * _RAD2DEG;
  
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a * cos - a13 * sin;
            t2 = b * cos - a23 * sin;
            t3 = c * cos - a33 * sin;
            a43 = d * sin + a43 * cos;
            a = t1;
            b = t2;
            c = t3;
          }
  
          angle = _atan2(b, a);
          rotation = angle * _RAD2DEG;
  
          if (angle) {
            cos = Math.cos(angle);
            sin = Math.sin(angle);
            t1 = a * cos + b * sin;
            t2 = a12 * cos + a22 * sin;
            b = b * cos - a * sin;
            a22 = a22 * cos - a12 * sin;
            a = t1;
            a12 = t2;
          }
  
          if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
            rotationX = rotation = 0;
            rotationY = 180 - rotationY;
          }
  
          scaleX = _round(Math.sqrt(a * a + b * b + c * c));
          scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
          angle = _atan2(a12, a22);
          skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
          perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
        }
  
        if (cache.svg) {
          t1 = target.getAttribute("transform");
          cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
          t1 && target.setAttribute("transform", t1);
        }
      }
  
      if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
        if (invertedScaleX) {
          scaleX *= -1;
          skewX += rotation <= 0 ? 180 : -180;
          rotation += rotation <= 0 ? 180 : -180;
        } else {
          scaleY *= -1;
          skewX += skewX <= 0 ? 180 : -180;
        }
      }
  
      cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
      cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
      cache.z = z + px;
      cache.scaleX = _round(scaleX);
      cache.scaleY = _round(scaleY);
      cache.rotation = _round(rotation) + deg;
      cache.rotationX = _round(rotationX) + deg;
      cache.rotationY = _round(rotationY) + deg;
      cache.skewX = skewX + deg;
      cache.skewY = skewY + deg;
      cache.transformPerspective = perspective + px;
  
      if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
        style[_transformOriginProp] = _firstTwoOnly(origin);
      }
  
      cache.xOffset = cache.yOffset = 0;
      cache.force3D = _config.force3D;
      cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
      cache.uncache = 0;
      return cache;
    },
        _firstTwoOnly = function _firstTwoOnly(value) {
      return (value = value.split(" "))[0] + " " + value[1];
    },
        _addPxTranslate = function _addPxTranslate(target, start, value) {
      var unit = getUnit(start);
      return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
    },
        _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
      cache.z = "0px";
      cache.rotationY = cache.rotationX = "0deg";
      cache.force3D = 0;
  
      _renderCSSTransforms(ratio, cache);
    },
        _zeroDeg = "0deg",
        _zeroPx = "0px",
        _endParenthesis = ") ",
        _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
      var _ref = cache || this,
          xPercent = _ref.xPercent,
          yPercent = _ref.yPercent,
          x = _ref.x,
          y = _ref.y,
          z = _ref.z,
          rotation = _ref.rotation,
          rotationY = _ref.rotationY,
          rotationX = _ref.rotationX,
          skewX = _ref.skewX,
          skewY = _ref.skewY,
          scaleX = _ref.scaleX,
          scaleY = _ref.scaleY,
          transformPerspective = _ref.transformPerspective,
          force3D = _ref.force3D,
          target = _ref.target,
          zOrigin = _ref.zOrigin,
          transforms = "",
          use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
  
      if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
        var angle = parseFloat(rotationY) * _DEG2RAD,
            a13 = Math.sin(angle),
            a33 = Math.cos(angle),
            cos;
  
        angle = parseFloat(rotationX) * _DEG2RAD;
        cos = Math.cos(angle);
        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
      }
  
      if (transformPerspective !== _zeroPx) {
        transforms += "perspective(" + transformPerspective + _endParenthesis;
      }
  
      if (xPercent || yPercent) {
        transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
      }
  
      if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
        transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
      }
  
      if (rotation !== _zeroDeg) {
        transforms += "rotate(" + rotation + _endParenthesis;
      }
  
      if (rotationY !== _zeroDeg) {
        transforms += "rotateY(" + rotationY + _endParenthesis;
      }
  
      if (rotationX !== _zeroDeg) {
        transforms += "rotateX(" + rotationX + _endParenthesis;
      }
  
      if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
        transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
      }
  
      if (scaleX !== 1 || scaleY !== 1) {
        transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
      }
  
      target.style[_transformProp] = transforms || "translate(0, 0)";
    },
        _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
      var _ref2 = cache || this,
          xPercent = _ref2.xPercent,
          yPercent = _ref2.yPercent,
          x = _ref2.x,
          y = _ref2.y,
          rotation = _ref2.rotation,
          skewX = _ref2.skewX,
          skewY = _ref2.skewY,
          scaleX = _ref2.scaleX,
          scaleY = _ref2.scaleY,
          target = _ref2.target,
          xOrigin = _ref2.xOrigin,
          yOrigin = _ref2.yOrigin,
          xOffset = _ref2.xOffset,
          yOffset = _ref2.yOffset,
          forceCSS = _ref2.forceCSS,
          tx = parseFloat(x),
          ty = parseFloat(y),
          a11,
          a21,
          a12,
          a22,
          temp;
  
      rotation = parseFloat(rotation);
      skewX = parseFloat(skewX);
      skewY = parseFloat(skewY);
  
      if (skewY) {
        skewY = parseFloat(skewY);
        skewX += skewY;
        rotation += skewY;
      }
  
      if (rotation || skewX) {
        rotation *= _DEG2RAD;
        skewX *= _DEG2RAD;
        a11 = Math.cos(rotation) * scaleX;
        a21 = Math.sin(rotation) * scaleX;
        a12 = Math.sin(rotation - skewX) * -scaleY;
        a22 = Math.cos(rotation - skewX) * scaleY;
  
        if (skewX) {
          skewY *= _DEG2RAD;
          temp = Math.tan(skewX - skewY);
          temp = Math.sqrt(1 + temp * temp);
          a12 *= temp;
          a22 *= temp;
  
          if (skewY) {
            temp = Math.tan(skewY);
            temp = Math.sqrt(1 + temp * temp);
            a11 *= temp;
            a21 *= temp;
          }
        }
  
        a11 = _round(a11);
        a21 = _round(a21);
        a12 = _round(a12);
        a22 = _round(a22);
      } else {
        a11 = scaleX;
        a22 = scaleY;
        a21 = a12 = 0;
      }
  
      if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
        tx = _convertToUnit(target, "x", x, "px");
        ty = _convertToUnit(target, "y", y, "px");
      }
  
      if (xOrigin || yOrigin || xOffset || yOffset) {
        tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
        ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
      }
  
      if (xPercent || yPercent) {
        temp = target.getBBox();
        tx = _round(tx + xPercent / 100 * temp.width);
        ty = _round(ty + yPercent / 100 * temp.height);
      }
  
      temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
      target.setAttribute("transform", temp);
      forceCSS && (target.style[_transformProp] = temp);
    },
        _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
      var cap = 360,
          isString = _isString(endValue),
          endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
          change = relative ? endNum * relative : endNum - startNum,
          finalValue = startNum + change + "deg",
          direction,
          pt;
  
      if (isString) {
        direction = endValue.split("_")[1];
  
        if (direction === "short") {
          change %= cap;
  
          if (change !== change % (cap / 2)) {
            change += change < 0 ? cap : -cap;
          }
        }
  
        if (direction === "cw" && change < 0) {
          change = (change + cap * _bigNum$1) % cap - ~~(change / cap) * cap;
        } else if (direction === "ccw" && change > 0) {
          change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap;
        }
      }
  
      plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
      pt.e = finalValue;
      pt.u = "deg";
  
      plugin._props.push(property);
  
      return pt;
    },
        _assign = function _assign(target, source) {
      for (var p in source) {
        target[p] = source[p];
      }
  
      return target;
    },
        _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
      var startCache = _assign({}, target._gsap),
          exclude = "perspective,force3D,transformOrigin,svgOrigin",
          style = target.style,
          endCache,
          p,
          startValue,
          endValue,
          startNum,
          endNum,
          startUnit,
          endUnit;
  
      if (startCache.svg) {
        startValue = target.getAttribute("transform");
        target.setAttribute("transform", "");
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
  
        _removeProperty(target, _transformProp);
  
        target.setAttribute("transform", startValue);
      } else {
        startValue = getComputedStyle(target)[_transformProp];
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
        style[_transformProp] = startValue;
      }
  
      for (p in _transformProps) {
        startValue = startCache[p];
        endValue = endCache[p];
  
        if (startValue !== endValue && exclude.indexOf(p) < 0) {
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
          startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
          endNum = parseFloat(endValue);
          plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
          plugin._pt.u = endUnit || 0;
  
          plugin._props.push(p);
        }
      }
  
      _assign(endCache, startCache);
    };
  
    _forEachName("padding,margin,Width,Radius", function (name, index) {
      var t = "Top",
          r = "Right",
          b = "Bottom",
          l = "Left",
          props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
        return index < 2 ? name + side : "border" + side + name;
      });
  
      _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
        var a, vars;
  
        if (arguments.length < 4) {
          a = props.map(function (prop) {
            return _get(plugin, prop, property);
          });
          vars = a.join(" ");
          return vars.split(a[0]).length === 5 ? a[0] : vars;
        }
  
        a = (endValue + "").split(" ");
        vars = {};
        props.forEach(function (prop, i) {
          return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
        });
        plugin.init(target, vars, tween);
      };
    });
  
    var CSSPlugin = {
      name: "css",
      register: _initCore,
      targetTest: function targetTest(target) {
        return target.style && target.nodeType;
      },
      init: function init(target, vars, tween, index, targets) {
        var props = this._props,
            style = target.style,
            startAt = tween.vars.startAt,
            startValue,
            endValue,
            endNum,
            startNum,
            type,
            specialProp,
            p,
            startUnit,
            endUnit,
            relative,
            isTransformRelated,
            transformPropTween,
            cache,
            smooth,
            hasPriority;
        _pluginInitted || _initCore();
  
        for (p in vars) {
          if (p === "autoRound") {
            continue;
          }
  
          endValue = vars[p];
  
          if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
            continue;
          }
  
          type = typeof endValue;
          specialProp = _specialProps[p];
  
          if (type === "function") {
            endValue = endValue.call(tween, index, target, targets);
            type = typeof endValue;
          }
  
          if (type === "string" && ~endValue.indexOf("random(")) {
            endValue = _replaceRandom(endValue);
          }
  
          if (specialProp) {
            specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
          } else if (p.substr(0, 2) === "--") {
            startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
            endValue += "";
            _colorExp.lastIndex = 0;
  
            if (!_colorExp.test(startValue)) {
              startUnit = getUnit(startValue);
              endUnit = getUnit(endValue);
            }
  
            endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
            this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
            props.push(p);
          } else if (type !== "undefined") {
            if (startAt && p in startAt) {
              startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
              p in _config.units && !getUnit(startValue) && (startValue += _config.units[p]);
              (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
            } else {
              startValue = _get(target, p);
            }
  
            startNum = parseFloat(startValue);
            relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
            relative && (endValue = endValue.substr(2));
            endNum = parseFloat(endValue);
  
            if (p in _propertyAliases) {
              if (p === "autoAlpha") {
                if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                  startNum = 0;
                }
  
                _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
              }
  
              if (p !== "scale" && p !== "transform") {
                p = _propertyAliases[p];
                ~p.indexOf(",") && (p = p.split(",")[0]);
              }
            }
  
            isTransformRelated = p in _transformProps;
  
            if (isTransformRelated) {
              if (!transformPropTween) {
                cache = target._gsap;
                cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                smooth = vars.smoothOrigin !== false && cache.smooth;
                transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                transformPropTween.dep = 1;
              }
  
              if (p === "scale") {
                this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
                props.push("scaleY", p);
                p += "X";
              } else if (p === "transformOrigin") {
                endValue = _convertKeywordsToPercentages(endValue);
  
                if (cache.svg) {
                  _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                } else {
                  endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                  endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
  
                  _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                }
  
                continue;
              } else if (p === "svgOrigin") {
                _applySVGOrigin(target, endValue, 1, smooth, 0, this);
  
                continue;
              } else if (p in _rotationalProperties) {
                _addRotationalPropTween(this, cache, p, startNum, endValue, relative);
  
                continue;
              } else if (p === "smoothOrigin") {
                _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
  
                continue;
              } else if (p === "force3D") {
                cache[p] = endValue;
                continue;
              } else if (p === "transform") {
                _addRawTransformPTs(this, endValue, target);
  
                continue;
              }
            } else if (!(p in style)) {
              p = _checkPropPrefix(p) || p;
            }
  
            if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
              startUnit = (startValue + "").substr((startNum + "").length);
              endNum || (endNum = 0);
              endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
              startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
              this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
              this._pt.u = endUnit || 0;
  
              if (startUnit !== endUnit) {
                this._pt.b = startValue;
                this._pt.r = _renderCSSPropWithBeginning;
              }
            } else if (!(p in style)) {
              if (p in target) {
                this.add(target, p, startValue || target[p], endValue, index, targets);
              } else {
                _missingPlugin(p, endValue);
  
                continue;
              }
            } else {
              _tweenComplexCSSString.call(this, target, p, startValue, endValue);
            }
  
            props.push(p);
          }
        }
  
        hasPriority && _sortPropTweensByPriority(this);
      },
      get: _get,
      aliases: _propertyAliases,
      getSetter: function getSetter(target, property, plugin) {
        var p = _propertyAliases[property];
        p && p.indexOf(",") < 0 && (property = p);
        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
      },
      core: {
        _removeProperty: _removeProperty,
        _getMatrix: _getMatrix
      }
    };
    gsap.utils.checkPrefix = _checkPropPrefix;
  
    (function (positionAndScale, rotation, others, aliases) {
      var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
        _transformProps[name] = 1;
      });
  
      _forEachName(rotation, function (name) {
        _config.units[name] = "deg";
        _rotationalProperties[name] = 1;
      });
  
      _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  
      _forEachName(aliases, function (name) {
        var split = name.split(":");
        _propertyAliases[split[1]] = all[split[0]];
      });
    })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  
    _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
      _config.units[name] = "px";
    });
  
    gsap.registerPlugin(CSSPlugin);
  
    var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,
        TweenMaxWithCSS = gsapWithCSS.core.Tween;
  
    exports.Back = Back;
    exports.Bounce = Bounce;
    exports.CSSPlugin = CSSPlugin;
    exports.Circ = Circ;
    exports.Cubic = Cubic;
    exports.Elastic = Elastic;
    exports.Expo = Expo;
    exports.Linear = Linear;
    exports.Power0 = Power0;
    exports.Power1 = Power1;
    exports.Power2 = Power2;
    exports.Power3 = Power3;
    exports.Power4 = Power4;
    exports.Quad = Quad;
    exports.Quart = Quart;
    exports.Quint = Quint;
    exports.Sine = Sine;
    exports.SteppedEase = SteppedEase;
    exports.Strong = Strong;
    exports.TimelineLite = Timeline;
    exports.TimelineMax = Timeline;
    exports.TweenLite = Tween;
    exports.TweenMax = TweenMaxWithCSS;
    exports.default = gsapWithCSS;
    exports.gsap = gsapWithCSS;
  
    if (typeof(window) === 'undefined' || window !== exports) {Object.defineProperty(exports, '__esModule', { value: true });} else {delete window.default;}
  
  })));
  
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

	/*!
	 * ScrollTrigger 3.7.1
	 * https://greensock.com
	 *
	 * @license Copyright 2008-2021, GreenSock. All rights reserved.
	 * Subject to the terms at https://greensock.com/standard-license or for
	 * Club GreenSock members, the agreement issued with that membership.
	 * @author: Jack Doyle, jack@greensock.com
	*/
	var gsap,
	    _coreInitted,
	    _win,
	    _doc,
	    _docEl,
	    _body,
	    _root,
	    _resizeDelay,
	    _raf,
	    _request,
	    _toArray,
	    _clamp,
	    _time2,
	    _syncInterval,
	    _refreshing,
	    _pointerIsDown,
	    _transformProp,
	    _i,
	    _prevWidth,
	    _prevHeight,
	    _autoRefresh,
	    _sort,
	    _suppressOverwrites,
	    _ignoreResize,
	    _limitCallbacks,
	    _startup = 1,
	    _proxies = [],
	    _scrollers = [],
	    _getTime = Date.now,
	    _time1 = _getTime(),
	    _lastScrollTime = 0,
	    _enabled = 1,
	    _passThrough = function _passThrough(v) {
	  return v;
	},
	    _round = function _round(value) {
	  return Math.round(value * 100000) / 100000 || 0;
	},
	    _windowExists = function _windowExists() {
	  return typeof window !== "undefined";
	},
	    _getGSAP = function _getGSAP() {
	  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
	},
	    _isViewport = function _isViewport(e) {
	  return !!~_root.indexOf(e);
	},
	    _getProxyProp = function _getProxyProp(element, property) {
	  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
	},
	    _getScrollFunc = function _getScrollFunc(element, _ref) {
	  var s = _ref.s,
	      sc = _ref.sc;

	  var i = _scrollers.indexOf(element),
	      offset = sc === _vertical.sc ? 1 : 2;

	  !~i && (i = _scrollers.push(element) - 1);
	  return _scrollers[i + offset] || (_scrollers[i + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc : function (value) {
	    return arguments.length ? element[s] = value : element[s];
	  }));
	},
	    _getBoundsFunc = function _getBoundsFunc(element) {
	  return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
	    _winOffsets.width = _win.innerWidth;
	    _winOffsets.height = _win.innerHeight;
	    return _winOffsets;
	  } : function () {
	    return _getBounds(element);
	  });
	},
	    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref2) {
	  var d = _ref2.d,
	      d2 = _ref2.d2,
	      a = _ref2.a;
	  return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
	    return a()[d];
	  } : function () {
	    return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;
	  };
	},
	    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
	  return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
	    return _winOffsets;
	  };
	},
	    _maxScroll = function _maxScroll(element, _ref3) {
	  var s = _ref3.s,
	      d2 = _ref3.d2,
	      d = _ref3.d,
	      a = _ref3.a;
	  return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];
	},
	    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
	  for (var i = 0; i < _autoRefresh.length; i += 3) {
	    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
	  }
	},
	    _isString = function _isString(value) {
	  return typeof value === "string";
	},
	    _isFunction = function _isFunction(value) {
	  return typeof value === "function";
	},
	    _isNumber = function _isNumber(value) {
	  return typeof value === "number";
	},
	    _isObject = function _isObject(value) {
	  return typeof value === "object";
	},
	    _callIfFunc = function _callIfFunc(value) {
	  return _isFunction(value) && value();
	},
	    _combineFunc = function _combineFunc(f1, f2) {
	  return function () {
	    var result1 = _callIfFunc(f1),
	        result2 = _callIfFunc(f2);

	    return function () {
	      _callIfFunc(result1);

	      _callIfFunc(result2);
	    };
	  };
	},
	    _abs = Math.abs,
	    _scrollLeft = "scrollLeft",
	    _scrollTop = "scrollTop",
	    _left = "left",
	    _top = "top",
	    _right = "right",
	    _bottom = "bottom",
	    _width = "width",
	    _height = "height",
	    _Right = "Right",
	    _Left = "Left",
	    _Top = "Top",
	    _Bottom = "Bottom",
	    _padding = "padding",
	    _margin = "margin",
	    _Width = "Width",
	    _Height = "Height",
	    _px = "px",
	    _horizontal = {
	  s: _scrollLeft,
	  p: _left,
	  p2: _Left,
	  os: _right,
	  os2: _Right,
	  d: _width,
	  d2: _Width,
	  a: "x",
	  sc: function sc(value) {
	    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
	  }
	},
	    _vertical = {
	  s: _scrollTop,
	  p: _top,
	  p2: _Top,
	  os: _bottom,
	  os2: _Bottom,
	  d: _height,
	  d2: _Height,
	  a: "y",
	  op: _horizontal,
	  sc: function sc(value) {
	    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
	  }
	},
	    _getComputedStyle = function _getComputedStyle(element) {
	  return _win.getComputedStyle(element);
	},
	    _makePositionable = function _makePositionable(element) {
	  var position = _getComputedStyle(element).position;

	  element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
	},
	    _setDefaults = function _setDefaults(obj, defaults) {
	  for (var p in defaults) {
	    p in obj || (obj[p] = defaults[p]);
	  }

	  return obj;
	},
	    _getBounds = function _getBounds(element, withoutTransforms) {
	  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
	    x: 0,
	    y: 0,
	    xPercent: 0,
	    yPercent: 0,
	    rotation: 0,
	    rotationX: 0,
	    rotationY: 0,
	    scale: 1,
	    skewX: 0,
	    skewY: 0
	  }).progress(1),
	      bounds = element.getBoundingClientRect();
	  tween && tween.progress(0).kill();
	  return bounds;
	},
	    _getSize = function _getSize(element, _ref4) {
	  var d2 = _ref4.d2;
	  return element["offset" + d2] || element["client" + d2] || 0;
	},
	    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
	  var a = [],
	      labels = timeline.labels,
	      duration = timeline.duration(),
	      p;

	  for (p in labels) {
	    a.push(labels[p] / duration);
	  }

	  return a;
	},
	    _getClosestLabel = function _getClosestLabel(animation) {
	  return function (value) {
	    return gsap.utils.snap(_getLabelRatioArray(animation), value);
	  };
	},
	    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
	  return function (value, st) {
	    var a = _getLabelRatioArray(timeline),
	        i;

	    a.sort(function (a, b) {
	      return a - b;
	    });

	    if (st.direction > 0) {
	      value -= 1e-4;

	      for (i = 0; i < a.length; i++) {
	        if (a[i] >= value) {
	          return a[i];
	        }
	      }

	      return a.pop();
	    } else {
	      i = a.length;
	      value += 1e-4;

	      while (i--) {
	        if (a[i] <= value) {
	          return a[i];
	        }
	      }
	    }

	    return a[0];
	  };
	},
	    _multiListener = function _multiListener(func, element, types, callback) {
	  return types.split(",").forEach(function (type) {
	    return func(element, type, callback);
	  });
	},
	    _addListener = function _addListener(element, type, func) {
	  return element.addEventListener(type, func, {
	    passive: true
	  });
	},
	    _removeListener = function _removeListener(element, type, func) {
	  return element.removeEventListener(type, func);
	},
	    _markerDefaults = {
	  startColor: "green",
	  endColor: "red",
	  indent: 0,
	  fontSize: "16px",
	  fontWeight: "normal"
	},
	    _defaults = {
	  toggleActions: "play",
	  anticipatePin: 0
	},
	    _keywords = {
	  top: 0,
	  left: 0,
	  center: 0.5,
	  bottom: 1,
	  right: 1
	},
	    _offsetToPx = function _offsetToPx(value, size) {
	  if (_isString(value)) {
	    var eqIndex = value.indexOf("="),
	        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

	    if (~eqIndex) {
	      value.indexOf("%") > eqIndex && (relative *= size / 100);
	      value = value.substr(0, eqIndex - 1);
	    }

	    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
	  }

	  return value;
	},
	    _createMarker = function _createMarker(type, name, container, direction, _ref5, offset, matchWidthEl) {
	  var startColor = _ref5.startColor,
	      endColor = _ref5.endColor,
	      fontSize = _ref5.fontSize,
	      indent = _ref5.indent,
	      fontWeight = _ref5.fontWeight;

	  var e = _doc.createElement("div"),
	      useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
	      isScroller = type.indexOf("scroller") !== -1,
	      parent = useFixedPosition ? _body : container,
	      isStart = type.indexOf("start") !== -1,
	      color = isStart ? startColor : endColor,
	      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

	  css += "position:" + (isScroller && useFixedPosition ? "fixed;" : "absolute;");
	  (isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
	  matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
	  e._isStart = isStart;
	  e.setAttribute("class", "gsap-marker-" + type);
	  e.style.cssText = css;
	  e.innerText = name || name === 0 ? type + "-" + name : type;
	  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
	  e._offset = e["offset" + direction.op.d2];

	  _positionMarker(e, 0, direction, isStart);

	  return e;
	},
	    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
	  var vars = {
	    display: "block"
	  },
	      side = direction[flipped ? "os2" : "p2"],
	      oppositeSide = direction[flipped ? "p2" : "os2"];
	  marker._isFlipped = flipped;
	  vars[direction.a + "Percent"] = flipped ? -100 : 0;
	  vars[direction.a] = flipped ? "1px" : 0;
	  vars["border" + side + _Width] = 1;
	  vars["border" + oppositeSide + _Width] = 0;
	  vars[direction.p] = start + "px";
	  gsap.set(marker, vars);
	},
	    _triggers = [],
	    _ids = {},
	    _sync = function _sync() {
	  return _request || (_request = _raf(_updateAll));
	},
	    _onScroll = function _onScroll() {
	  if (!_request) {
	    _request = _raf(_updateAll);
	    _lastScrollTime || _dispatch("scrollStart");
	    _lastScrollTime = _getTime();
	  }
	},
	    _onResize = function _onResize() {
	  return !_refreshing && !_ignoreResize && !_doc.fullscreenElement && _resizeDelay.restart(true);
	},
	    _listeners = {},
	    _emptyArray = [],
	    _media = [],
	    _creatingMedia,
	    _lastMediaTick,
	    _onMediaChange = function _onMediaChange(e) {
	  var tick = gsap.ticker.frame,
	      matches = [],
	      i = 0,
	      index;

	  if (_lastMediaTick !== tick || _startup) {
	    _revertAll();

	    for (; i < _media.length; i += 4) {
	      index = _win.matchMedia(_media[i]).matches;

	      if (index !== _media[i + 3]) {
	        _media[i + 3] = index;
	        index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2]();
	      }
	    }

	    _revertRecorded();

	    for (i = 0; i < matches.length; i++) {
	      index = matches[i];
	      _creatingMedia = _media[index];
	      _media[index + 2] = _media[index + 1](e);
	    }

	    _creatingMedia = 0;
	    _coreInitted && _refreshAll(0, 1);
	    _lastMediaTick = tick;

	    _dispatch("matchMedia");
	  }
	},
	    _softRefresh = function _softRefresh() {
	  return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
	},
	    _dispatch = function _dispatch(type) {
	  return _listeners[type] && _listeners[type].map(function (f) {
	    return f();
	  }) || _emptyArray;
	},
	    _savedStyles = [],
	    _revertRecorded = function _revertRecorded(media) {
	  for (var i = 0; i < _savedStyles.length; i += 5) {
	    if (!media || _savedStyles[i + 4] === media) {
	      _savedStyles[i].style.cssText = _savedStyles[i + 1];
	      _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
	      _savedStyles[i + 3].uncache = 1;
	    }
	  }
	},
	    _revertAll = function _revertAll(kill, media) {
	  var trigger;

	  for (_i = 0; _i < _triggers.length; _i++) {
	    trigger = _triggers[_i];

	    if (!media || trigger.media === media) {
	      if (kill) {
	        trigger.kill(1);
	      } else {
	        trigger.revert();
	      }
	    }
	  }

	  media && _revertRecorded(media);
	  media || _dispatch("revert");
	},
	    _refreshingAll,
	    _refreshAll = function _refreshAll(force, skipRevert) {
	  if (_lastScrollTime && !force) {
	    _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

	    return;
	  }

	  _refreshingAll = true;

	  var refreshInits = _dispatch("refreshInit");

	  _sort && ScrollTrigger.sort();
	  skipRevert || _revertAll();

	  _triggers.forEach(function (t) {
	    return t.refresh();
	  });

	  refreshInits.forEach(function (result) {
	    return result && result.render && result.render(-1);
	  });

	  _scrollers.forEach(function (obj) {
	    return typeof obj === "function" && (obj.rec = 0);
	  });

	  _resizeDelay.pause();

	  _refreshingAll = false;

	  _dispatch("refresh");
	},
	    _lastScroll = 0,
	    _direction = 1,
	    _updateAll = function _updateAll() {
	  if (!_refreshingAll) {
	    var l = _triggers.length,
	        time = _getTime(),
	        recordVelocity = time - _time1 >= 50,
	        scroll = l && _triggers[0].scroll();

	    _direction = _lastScroll > scroll ? -1 : 1;
	    _lastScroll = scroll;

	    if (recordVelocity) {
	      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
	        _lastScrollTime = 0;

	        _dispatch("scrollEnd");
	      }

	      _time2 = _time1;
	      _time1 = time;
	    }

	    if (_direction < 0) {
	      _i = l;

	      while (_i-- > 0) {
	        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
	      }

	      _direction = 1;
	    } else {
	      for (_i = 0; _i < l; _i++) {
	        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
	      }
	    }

	    _request = 0;
	  }
	},
	    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end", "grid-area", "justify-self", "align-self", "place-self"],
	    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
	    _swapPinOut = function _swapPinOut(pin, spacer, state) {
	  _setState(state);

	  if (pin.parentNode === spacer) {
	    var parent = spacer.parentNode;

	    if (parent) {
	      parent.insertBefore(pin, spacer);
	      parent.removeChild(spacer);
	    }
	  }
	},
	    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
	  if (pin.parentNode !== spacer) {
	    var i = _propNamesToCopy.length,
	        spacerStyle = spacer.style,
	        pinStyle = pin.style,
	        p;

	    while (i--) {
	      p = _propNamesToCopy[i];
	      spacerStyle[p] = cs[p];
	    }

	    spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
	    cs.display === "inline" && (spacerStyle.display = "inline-block");
	    pinStyle[_bottom] = pinStyle[_right] = "auto";
	    spacerStyle.overflow = "visible";
	    spacerStyle.boxSizing = "border-box";
	    spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
	    spacerStyle[_height] = _getSize(pin, _vertical) + _px;
	    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

	    _setState(spacerState);

	    pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
	    pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
	    pinStyle[_padding] = cs[_padding];
	    pin.parentNode.insertBefore(spacer, pin);
	    spacer.appendChild(pin);
	  }
	},
	    _capsExp = /([A-Z])/g,
	    _setState = function _setState(state) {
	  if (state) {
	    var style = state.t.style,
	        l = state.length,
	        i = 0,
	        p,
	        value;
	    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1;

	    for (; i < l; i += 2) {
	      value = state[i + 1];
	      p = state[i];

	      if (value) {
	        style[p] = value;
	      } else if (style[p]) {
	        style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
	      }
	    }
	  }
	},
	    _getState = function _getState(element) {
	  var l = _stateProps.length,
	      style = element.style,
	      state = [],
	      i = 0;

	  for (; i < l; i++) {
	    state.push(_stateProps[i], style[_stateProps[i]]);
	  }

	  state.t = element;
	  return state;
	},
	    _copyState = function _copyState(state, override, omitOffsets) {
	  var result = [],
	      l = state.length,
	      i = omitOffsets ? 8 : 0,
	      p;

	  for (; i < l; i += 2) {
	    p = state[i];
	    result.push(p, p in override ? override[p] : state[i + 1]);
	  }

	  result.t = state.t;
	  return result;
	},
	    _winOffsets = {
	  left: 0,
	  top: 0
	},
	    _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) {
	  _isFunction(value) && (value = value(self));

	  if (_isString(value) && value.substr(0, 3) === "max") {
	    value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
	  }

	  if (!_isNumber(value)) {
	    _isFunction(trigger) && (trigger = trigger(self));

	    var element = _toArray(trigger)[0] || _body,
	        bounds = _getBounds(element) || {},
	        offsets = value.split(" "),
	        localOffset,
	        globalOffset,
	        display;

	    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
	      display = element.style.display;
	      element.style.display = "block";
	      bounds = _getBounds(element);
	      display ? element.style.display = display : element.style.removeProperty("display");
	    }

	    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
	    globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
	    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
	    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
	    scrollerSize -= scrollerSize - globalOffset;
	  } else if (markerScroller) {
	    _positionMarker(markerScroller, scrollerSize, direction, true);
	  }

	  if (marker) {
	    var position = value + scrollerSize,
	        isStart = marker._isStart;
	    scrollerMax = "scroll" + direction.d2;

	    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1);

	    if (useFixedPosition) {
	      scrollerBounds = _getBounds(markerScroller);
	      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
	    }
	  }

	  return Math.round(value);
	},
	    _prefixExp = /(?:webkit|moz|length|cssText|inset)/i,
	    _reparent = function _reparent(element, parent, top, left) {
	  if (element.parentNode !== parent) {
	    var style = element.style,
	        p,
	        cs;

	    if (parent === _body) {
	      element._stOrig = style.cssText;
	      cs = _getComputedStyle(element);

	      for (p in cs) {
	        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
	          style[p] = cs[p];
	        }
	      }

	      style.top = top;
	      style.left = left;
	    } else {
	      style.cssText = element._stOrig;
	    }

	    gsap.core.getCache(element).uncache = 1;
	    parent.appendChild(element);
	  }
	},
	    _getTweenCreator = function _getTweenCreator(scroller, direction) {
	  var getScroll = _getScrollFunc(scroller, direction),
	      prop = "_scroll" + direction.p2,
	      lastScroll1,
	      lastScroll2,
	      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
	    var tween = getTween.tween,
	        onComplete = vars.onComplete,
	        modifiers = {};
	    tween && tween.kill();
	    lastScroll1 = Math.round(initialValue);
	    vars[prop] = scrollTo;
	    vars.modifiers = modifiers;

	    modifiers[prop] = function (value) {
	      value = _round(getScroll());

	      if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2) {
	        tween.kill();
	        getTween.tween = 0;
	      } else {
	        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
	      }

	      lastScroll2 = lastScroll1;
	      return lastScroll1 = _round(value);
	    };

	    vars.onComplete = function () {
	      getTween.tween = 0;
	      onComplete && onComplete.call(tween);
	    };

	    tween = getTween.tween = gsap.to(scroller, vars);
	    return tween;
	  };

	  scroller[prop] = getScroll;
	  scroller.addEventListener("wheel", function () {
	    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
	  }, {
	    passive: true
	  });
	  return getTween;
	};

	_horizontal.op = _vertical;
	var ScrollTrigger = function () {
	  function ScrollTrigger(vars, animation) {
	    _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
	    this.init(vars, animation);
	  }

	  var _proto = ScrollTrigger.prototype;

	  _proto.init = function init(vars, animation) {
	    this.progress = this.start = 0;
	    this.vars && this.kill(1);

	    if (!_enabled) {
	      this.update = this.refresh = this.kill = _passThrough;
	      return;
	    }

	    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
	      trigger: vars
	    } : vars, _defaults);

	    var direction = vars.horizontal ? _horizontal : _vertical,
	        _vars = vars,
	        onUpdate = _vars.onUpdate,
	        toggleClass = _vars.toggleClass,
	        id = _vars.id,
	        onToggle = _vars.onToggle,
	        onRefresh = _vars.onRefresh,
	        scrub = _vars.scrub,
	        trigger = _vars.trigger,
	        pin = _vars.pin,
	        pinSpacing = _vars.pinSpacing,
	        invalidateOnRefresh = _vars.invalidateOnRefresh,
	        anticipatePin = _vars.anticipatePin,
	        onScrubComplete = _vars.onScrubComplete,
	        onSnapComplete = _vars.onSnapComplete,
	        once = _vars.once,
	        snap = _vars.snap,
	        pinReparent = _vars.pinReparent,
	        isToggle = !scrub && scrub !== 0,
	        scroller = _toArray(vars.scroller || _win)[0],
	        scrollerCache = gsap.core.getCache(scroller),
	        isViewport = _isViewport(scroller),
	        useFixedPosition = "pinType" in vars ? vars.pinType === "fixed" : isViewport || _getProxyProp(scroller, "pinType") === "fixed",
	        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
	        toggleActions = isToggle && vars.toggleActions.split(" "),
	        markers = "markers" in vars ? vars.markers : _defaults.markers,
	        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
	        self = this,
	        onRefreshInit = vars.onRefreshInit && function () {
	      return vars.onRefreshInit(self);
	    },
	        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
	        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
	        lastSnap = 0,
	        tweenTo,
	        pinCache,
	        snapFunc,
	        scroll1,
	        scroll2,
	        start,
	        end,
	        markerStart,
	        markerEnd,
	        markerStartTrigger,
	        markerEndTrigger,
	        markerVars,
	        change,
	        pinOriginalState,
	        pinActiveState,
	        pinState,
	        spacer,
	        offset,
	        pinGetter,
	        pinSetter,
	        pinStart,
	        pinChange,
	        spacingStart,
	        spacerState,
	        markerStartSetter,
	        markerEndSetter,
	        cs,
	        snap1,
	        snap2,
	        scrubTween,
	        scrubSmooth,
	        snapDurClamp,
	        snapDelayedCall,
	        prevProgress,
	        prevScroll,
	        prevAnimProgress;

	    self.media = _creatingMedia;
	    anticipatePin *= 45;
	    self.scroller = scroller;
	    self.scroll = _getScrollFunc(scroller, direction);
	    scroll1 = self.scroll();
	    self.vars = vars;
	    animation = animation || vars.animation;
	    "refreshPriority" in vars && (_sort = 1);
	    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
	      top: _getTweenCreator(scroller, _vertical),
	      left: _getTweenCreator(scroller, _horizontal)
	    };
	    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

	    if (animation) {
	      animation.vars.lazy = false;
	      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
	      self.animation = animation.pause();
	      animation.scrollTrigger = self;
	      scrubSmooth = _isNumber(scrub) && scrub;
	      scrubSmooth && (scrubTween = gsap.to(animation, {
	        ease: "power3",
	        duration: scrubSmooth,
	        onComplete: function onComplete() {
	          return onScrubComplete && onScrubComplete(self);
	        }
	      }));
	      snap1 = 0;
	      id || (id = animation.vars.id);
	    }

	    _triggers.push(self);

	    if (snap) {
	      if (!_isObject(snap) || snap.push) {
	        snap = {
	          snapTo: snap
	        };
	      }

	      "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
	        scrollBehavior: "auto"
	      });
	      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : gsap.utils.snap(snap.snapTo);
	      snapDurClamp = snap.duration || {
	        min: 0.1,
	        max: 2
	      };
	      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
	      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
	        if (Math.abs(self.getVelocity()) < 10 && !_pointerIsDown && lastSnap !== self.scroll()) {
	          var totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,
	              velocity = (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
	              change1 = gsap.utils.clamp(-self.progress, 1 - self.progress, _abs(velocity / 2) * velocity / 0.185),
	              naturalEnd = self.progress + (snap.inertia === false ? 0 : change1),
	              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
	              scroll = self.scroll(),
	              endScroll = Math.round(start + endValue * change),
	              _snap = snap,
	              onStart = _snap.onStart,
	              _onInterrupt = _snap.onInterrupt,
	              _onComplete = _snap.onComplete,
	              tween = tweenTo.tween;

	          if (scroll <= end && scroll >= start && endScroll !== scroll) {
	            if (tween && !tween._initted && tween.data <= Math.abs(endScroll - scroll)) {
	              return;
	            }

	            if (snap.inertia === false) {
	              change1 = endValue - self.progress;
	            }

	            tweenTo(endScroll, {
	              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
	              ease: snap.ease || "power3",
	              data: Math.abs(endScroll - scroll),
	              onInterrupt: function onInterrupt() {
	                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
	              },
	              onComplete: function onComplete() {
	                lastSnap = self.scroll();
	                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
	                onSnapComplete && onSnapComplete(self);
	                _onComplete && _onComplete(self);
	              }
	            }, scroll, change1 * change, endScroll - scroll - change1 * change);
	            onStart && onStart(self, tweenTo.tween);
	          }
	        } else if (self.isActive) {
	          snapDelayedCall.restart(true);
	        }
	      }).pause();
	    }

	    id && (_ids[id] = self);
	    trigger = self.trigger = _toArray(trigger || pin)[0];
	    pin = pin === true ? trigger : _toArray(pin)[0];
	    _isString(toggleClass) && (toggleClass = {
	      targets: trigger,
	      className: toggleClass
	    });

	    if (pin) {
	      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
	      self.pin = pin;
	      vars.force3D !== false && gsap.set(pin, {
	        force3D: true
	      });
	      pinCache = gsap.core.getCache(pin);

	      if (!pinCache.spacer) {
	        pinCache.spacer = spacer = _doc.createElement("div");
	        spacer.setAttribute("class", "pin-spacer" + (id ? " pin-spacer-" + id : ""));
	        pinCache.pinState = pinOriginalState = _getState(pin);
	      } else {
	        pinOriginalState = pinCache.pinState;
	      }

	      self.spacer = spacer = pinCache.spacer;
	      cs = _getComputedStyle(pin);
	      spacingStart = cs[pinSpacing + direction.os2];
	      pinGetter = gsap.getProperty(pin);
	      pinSetter = gsap.quickSetter(pin, direction.a, _px);

	      _swapPinIn(pin, spacer, cs);

	      pinState = _getState(pin);
	    }

	    if (markers) {
	      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
	      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
	      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
	      offset = markerStartTrigger["offset" + direction.op.d2];
	      markerStart = _createMarker("start", id, scroller, direction, markerVars, offset);
	      markerEnd = _createMarker("end", id, scroller, direction, markerVars, offset);

	      if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
	        _makePositionable(isViewport ? _body : scroller);

	        gsap.set([markerStartTrigger, markerEndTrigger], {
	          force3D: true
	        });
	        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
	        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
	      }
	    }

	    self.revert = function (revert) {
	      var r = revert !== false || !self.enabled,
	          prevRefreshing = _refreshing;

	      if (r !== self.isReverted) {
	        if (r) {
	          self.scroll.rec || (self.scroll.rec = self.scroll());
	          prevScroll = Math.max(self.scroll(), self.scroll.rec || 0);
	          prevProgress = self.progress;
	          prevAnimProgress = animation && animation.progress();
	        }

	        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
	          return m.style.display = r ? "none" : "block";
	        });
	        r && (_refreshing = 1);
	        self.update(r);
	        _refreshing = prevRefreshing;
	        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
	        self.isReverted = r;
	      }
	    };

	    self.refresh = function (soft, force) {
	      if ((_refreshing || !self.enabled) && !force) {
	        return;
	      }

	      if (pin && soft && _lastScrollTime) {
	        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

	        return;
	      }

	      _refreshing = 1;
	      scrubTween && scrubTween.pause();
	      invalidateOnRefresh && animation && animation.progress(0).invalidate();
	      self.isReverted || self.revert();

	      var size = getScrollerSize(),
	          scrollerBounds = getScrollerOffsets(),
	          max = _maxScroll(scroller, direction),
	          offset = 0,
	          otherPinOffset = 0,
	          parsedEnd = vars.end,
	          parsedEndTrigger = vars.endTrigger || trigger,
	          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
	          pinnedContainer = vars.pinnedContainer && _toArray(vars.pinnedContainer)[0],
	          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
	          i = triggerIndex,
	          cs,
	          bounds,
	          scroll,
	          isVertical,
	          override,
	          curTrigger,
	          curPin,
	          oppositeScroll,
	          initted,
	          revertedPins;

	      while (i--) {
	        curTrigger = _triggers[i];
	        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1);
	        curPin = curTrigger.pin;

	        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
	          revertedPins || (revertedPins = []);
	          revertedPins.unshift(curTrigger);
	          curTrigger.revert();
	        }
	      }

	      start = _parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);
	      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));

	      if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
	        if (~parsedEnd.indexOf(" ")) {
	          parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
	        } else {
	          offset = _offsetToPx(parsedEnd.substr(2), size);
	          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset;
	          parsedEndTrigger = trigger;
	        }
	      }

	      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;
	      change = end - start || (start -= 0.01) && 0.001;
	      offset = 0;
	      i = triggerIndex;

	      while (i--) {
	        curTrigger = _triggers[i];
	        curPin = curTrigger.pin;

	        if (curPin && curTrigger.start - curTrigger._pinPush < start) {
	          cs = curTrigger.end - curTrigger.start;
	          (curPin === trigger || curPin === pinnedContainer) && (offset += cs);
	          curPin === pin && (otherPinOffset += cs);
	        }
	      }

	      start += offset;
	      end += offset;
	      self._pinPush = otherPinOffset;

	      if (markerStart && offset) {
	        cs = {};
	        cs[direction.a] = "+=" + offset;
	        pinnedContainer && (cs[direction.p] = "-=" + self.scroll());
	        gsap.set([markerStart, markerEnd], cs);
	      }

	      if (pin) {
	        cs = _getComputedStyle(pin);
	        isVertical = direction === _vertical;
	        scroll = self.scroll();
	        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
	        !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll");

	        _swapPinIn(pin, spacer, cs);

	        pinState = _getState(pin);
	        bounds = _getBounds(pin, true);
	        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();

	        if (pinSpacing) {
	          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
	          spacerState.t = spacer;
	          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
	          i && spacerState.push(direction.d, i + _px);

	          _setState(spacerState);

	          useFixedPosition && self.scroll(prevScroll);
	        }

	        if (useFixedPosition) {
	          override = {
	            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
	            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
	            boxSizing: "border-box",
	            position: "fixed"
	          };
	          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
	          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
	          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
	          override[_padding] = cs[_padding];
	          override[_padding + _Top] = cs[_padding + _Top];
	          override[_padding + _Right] = cs[_padding + _Right];
	          override[_padding + _Bottom] = cs[_padding + _Bottom];
	          override[_padding + _Left] = cs[_padding + _Left];
	          pinActiveState = _copyState(pinOriginalState, override, pinReparent);
	        }

	        if (animation) {
	          initted = animation._initted;

	          _suppressOverwrites(1);

	          animation.render(animation.duration(), true, true);
	          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
	          change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2);
	          animation.render(0, true, true);
	          initted || animation.invalidate();

	          _suppressOverwrites(0);
	        } else {
	          pinChange = change;
	        }
	      } else if (trigger && self.scroll()) {
	        bounds = trigger.parentNode;

	        while (bounds && bounds !== _body) {
	          if (bounds._pinOffset) {
	            start -= bounds._pinOffset;
	            end -= bounds._pinOffset;
	          }

	          bounds = bounds.parentNode;
	        }
	      }

	      revertedPins && revertedPins.forEach(function (t) {
	        return t.revert(false);
	      });
	      self.start = start;
	      self.end = end;
	      scroll1 = scroll2 = self.scroll();
	      scroll1 < prevScroll && self.scroll(prevScroll);
	      self.revert(false);
	      _refreshing = 0;
	      animation && isToggle && animation._initted && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true);

	      if (prevProgress !== self.progress) {
	        scrubTween && animation.totalProgress(prevProgress, true);
	        self.progress = prevProgress;
	        self.update();
	      }

	      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
	      onRefresh && onRefresh(self);
	    };

	    self.getVelocity = function () {
	      return (self.scroll() - scroll2) / (_getTime() - _time2) * 1000 || 0;
	    };

	    self.update = function (reset, recordVelocity) {
	      var scroll = self.scroll(),
	          p = reset ? 0 : (scroll - start) / change,
	          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
	          prevProgress = self.progress,
	          isActive,
	          wasActive,
	          toggleState,
	          action,
	          stateChanged,
	          toggled;

	      if (recordVelocity) {
	        scroll2 = scroll1;
	        scroll1 = scroll;

	        if (snap) {
	          snap2 = snap1;
	          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
	        }
	      }

	      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);

	      if (clipped !== prevProgress && self.enabled) {
	        isActive = self.isActive = !!clipped && clipped < 1;
	        wasActive = !!prevProgress && prevProgress < 1;
	        toggled = isActive !== wasActive;
	        stateChanged = toggled || !!clipped !== !!prevProgress;
	        self.direction = clipped > prevProgress ? 1 : -1;
	        self.progress = clipped;

	        if (!isToggle) {
	          if (scrubTween && !_refreshing && !_startup) {
	            scrubTween.vars.totalProgress = clipped;
	            scrubTween.invalidate().restart();
	          } else if (animation) {
	            animation.totalProgress(clipped, !!_refreshing);
	          }
	        }

	        if (pin) {
	          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

	          if (!useFixedPosition) {
	            pinSetter(pinStart + pinChange * clipped);
	          } else if (stateChanged) {
	            action = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);

	            if (pinReparent) {
	              if (!reset && (isActive || action)) {
	                var bounds = _getBounds(pin, true),
	                    _offset = scroll - start;

	                _reparent(pin, _body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
	              } else {
	                _reparent(pin, spacer);
	              }
	            }

	            _setState(isActive || action ? pinActiveState : pinState);

	            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));
	          }
	        }

	        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
	        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
	          return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
	        });
	        onUpdate && !isToggle && !reset && onUpdate(self);

	        if (stateChanged && !_refreshing) {
	          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3;

	          if (isToggle) {
	            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];

	            if (animation && (action === "complete" || action === "reset" || action in animation)) {
	              if (action === "complete") {
	                animation.pause().totalProgress(1);
	              } else if (action === "reset") {
	                animation.restart(true).pause();
	              } else if (action === "restart") {
	                animation.restart(true);
	              } else {
	                animation[action]();
	              }
	            }

	            onUpdate && onUpdate(self);
	          }

	          if (toggled || !_limitCallbacks) {
	            onToggle && toggled && onToggle(self);
	            callbacks[toggleState] && callbacks[toggleState](self);
	            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);

	            if (!toggled) {
	              toggleState = clipped === 1 ? 1 : 3;
	              callbacks[toggleState] && callbacks[toggleState](self);
	            }
	          }
	        } else if (isToggle && onUpdate && !_refreshing) {
	          onUpdate(self);
	        }
	      }

	      if (markerEndSetter) {
	        markerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));
	        markerEndSetter(scroll);
	      }
	    };

	    self.enable = function (reset, refresh) {
	      if (!self.enabled) {
	        self.enabled = true;

	        _addListener(scroller, "resize", _onResize);

	        _addListener(scroller, "scroll", _onScroll);

	        onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);

	        if (reset !== false) {
	          self.progress = prevProgress = 0;
	          scroll1 = scroll2 = lastSnap = self.scroll();
	        }

	        refresh !== false && self.refresh();
	      }
	    };

	    self.getTween = function (snap) {
	      return snap && tweenTo ? tweenTo.tween : scrubTween;
	    };

	    self.disable = function (reset, allowAnimation) {
	      if (self.enabled) {
	        reset !== false && self.revert();
	        self.enabled = self.isActive = false;
	        allowAnimation || scrubTween && scrubTween.pause();
	        prevScroll = 0;
	        pinCache && (pinCache.uncache = 1);
	        onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

	        if (snapDelayedCall) {
	          snapDelayedCall.pause();
	          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
	        }

	        if (!isViewport) {
	          var i = _triggers.length;

	          while (i--) {
	            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
	              return;
	            }
	          }

	          _removeListener(scroller, "resize", _onResize);

	          _removeListener(scroller, "scroll", _onScroll);
	        }
	      }
	    };

	    self.kill = function (revert, allowAnimation) {
	      self.disable(revert, allowAnimation);
	      id && delete _ids[id];

	      var i = _triggers.indexOf(self);

	      _triggers.splice(i, 1);

	      i === _i && _direction > 0 && _i--;
	      i = 0;

	      _triggers.forEach(function (t) {
	        return t.scroller === self.scroller && (i = 1);
	      });

	      i || (self.scroll.rec = 0);

	      if (animation) {
	        animation.scrollTrigger = null;
	        revert && animation.render(-1);
	        allowAnimation || animation.kill();
	      }

	      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
	        return m.parentNode && m.parentNode.removeChild(m);
	      });

	      if (pin) {
	        pinCache && (pinCache.uncache = 1);
	        i = 0;

	        _triggers.forEach(function (t) {
	          return t.pin === pin && i++;
	        });

	        i || (pinCache.spacer = 0);
	      }
	    };

	    self.enable(false, false);
	    !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {
	      return start || end || self.refresh();
	    }) && (change = 0.01) && (start = end = 0);
	  };

	  ScrollTrigger.register = function register(core) {
	    if (!_coreInitted) {
	      gsap = core || _getGSAP();

	      if (_windowExists() && window.document) {
	        _win = window;
	        _doc = document;
	        _docEl = _doc.documentElement;
	        _body = _doc.body;
	      }

	      if (gsap) {
	        _toArray = gsap.utils.toArray;
	        _clamp = gsap.utils.clamp;
	        _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
	        gsap.core.globals("ScrollTrigger", ScrollTrigger);

	        if (_body) {
	          _raf = _win.requestAnimationFrame || function (f) {
	            return setTimeout(f, 16);
	          };

	          _addListener(_win, "wheel", _onScroll);

	          _root = [_win, _doc, _docEl, _body];

	          _addListener(_doc, "scroll", _onScroll);

	          var bodyStyle = _body.style,
	              border = bodyStyle.borderTop,
	              bounds;
	          bodyStyle.borderTop = "1px solid #000";
	          bounds = _getBounds(_body);
	          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
	          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
	          border ? bodyStyle.borderTop = border : bodyStyle.removeProperty("border-top");
	          _syncInterval = setInterval(_sync, 200);
	          gsap.delayedCall(0.5, function () {
	            return _startup = 0;
	          });

	          _addListener(_doc, "touchcancel", _passThrough);

	          _addListener(_body, "touchstart", _passThrough);

	          _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", function () {
	            return _pointerIsDown = 1;
	          });

	          _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", function () {
	            return _pointerIsDown = 0;
	          });

	          _transformProp = gsap.utils.checkPrefix("transform");

	          _stateProps.push(_transformProp);

	          _coreInitted = _getTime();
	          _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
	          _autoRefresh = [_doc, "visibilitychange", function () {
	            var w = _win.innerWidth,
	                h = _win.innerHeight;

	            if (_doc.hidden) {
	              _prevWidth = w;
	              _prevHeight = h;
	            } else if (_prevWidth !== w || _prevHeight !== h) {
	              _onResize();
	            }
	          }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", function () {
	            return _lastScrollTime || _refreshAll();
	          }, _win, "resize", _onResize];

	          _iterateAutoRefresh(_addListener);
	        }
	      }
	    }

	    return _coreInitted;
	  };

	  ScrollTrigger.defaults = function defaults(config) {
	    for (var p in config) {
	      _defaults[p] = config[p];
	    }
	  };

	  ScrollTrigger.kill = function kill() {
	    _enabled = 0;

	    _triggers.slice(0).forEach(function (trigger) {
	      return trigger.kill(1);
	    });
	  };

	  ScrollTrigger.config = function config(vars) {
	    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
	    var ms = vars.syncInterval;
	    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);

	    if ("autoRefreshEvents" in vars) {
	      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
	      _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
	    }
	  };

	  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
	    var t = _toArray(target)[0],
	        i = _scrollers.indexOf(t),
	        isViewport = _isViewport(t);

	    if (~i) {
	      _scrollers.splice(i, isViewport ? 6 : 2);
	    }

	    isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);
	  };

	  ScrollTrigger.matchMedia = function matchMedia(vars) {
	    var mq, p, i, func, result;

	    for (p in vars) {
	      i = _media.indexOf(p);
	      func = vars[p];
	      _creatingMedia = p;

	      if (p === "all") {
	        func();
	      } else {
	        mq = _win.matchMedia(p);

	        if (mq) {
	          mq.matches && (result = func());

	          if (~i) {
	            _media[i + 1] = _combineFunc(_media[i + 1], func);
	            _media[i + 2] = _combineFunc(_media[i + 2], result);
	          } else {
	            i = _media.length;

	            _media.push(p, func, result);

	            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
	          }

	          _media[i + 3] = mq.matches;
	        }
	      }

	      _creatingMedia = 0;
	    }

	    return _media;
	  };

	  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
	    query || (_media.length = 0);
	    query = _media.indexOf(query);
	    query >= 0 && _media.splice(query, 4);
	  };

	  return ScrollTrigger;
	}();
	ScrollTrigger.version = "3.7.1";

	ScrollTrigger.saveStyles = function (targets) {
	  return targets ? _toArray(targets).forEach(function (target) {
	    if (target && target.style) {
	      var i = _savedStyles.indexOf(target);

	      i >= 0 && _savedStyles.splice(i, 5);

	      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _creatingMedia);
	    }
	  }) : _savedStyles;
	};

	ScrollTrigger.revert = function (soft, media) {
	  return _revertAll(!soft, media);
	};

	ScrollTrigger.create = function (vars, animation) {
	  return new ScrollTrigger(vars, animation);
	};

	ScrollTrigger.refresh = function (safe) {
	  return safe ? _onResize() : _refreshAll(true);
	};

	ScrollTrigger.update = _updateAll;

	ScrollTrigger.maxScroll = function (element, horizontal) {
	  return _maxScroll(element, horizontal ? _horizontal : _vertical);
	};

	ScrollTrigger.getScrollFunc = function (element, horizontal) {
	  return _getScrollFunc(_toArray(element)[0], horizontal ? _horizontal : _vertical);
	};

	ScrollTrigger.getById = function (id) {
	  return _ids[id];
	};

	ScrollTrigger.getAll = function () {
	  return _triggers.slice(0);
	};

	ScrollTrigger.isScrolling = function () {
	  return !!_lastScrollTime;
	};

	ScrollTrigger.addEventListener = function (type, callback) {
	  var a = _listeners[type] || (_listeners[type] = []);
	  ~a.indexOf(callback) || a.push(callback);
	};

	ScrollTrigger.removeEventListener = function (type, callback) {
	  var a = _listeners[type],
	      i = a && a.indexOf(callback);
	  i >= 0 && a.splice(i, 1);
	};

	ScrollTrigger.batch = function (targets, vars) {
	  var result = [],
	      varsCopy = {},
	      interval = vars.interval || 0.016,
	      batchMax = vars.batchMax || 1e9,
	      proxyCallback = function proxyCallback(type, callback) {
	    var elements = [],
	        triggers = [],
	        delay = gsap.delayedCall(interval, function () {
	      callback(elements, triggers);
	      elements = [];
	      triggers = [];
	    }).pause();
	    return function (self) {
	      elements.length || delay.restart(true);
	      elements.push(self.trigger);
	      triggers.push(self);
	      batchMax <= elements.length && delay.progress(1);
	    };
	  },
	      p;

	  for (p in vars) {
	    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
	  }

	  if (_isFunction(batchMax)) {
	    batchMax = batchMax();

	    _addListener(ScrollTrigger, "refresh", function () {
	      return batchMax = vars.batchMax();
	    });
	  }

	  _toArray(targets).forEach(function (target) {
	    var config = {};

	    for (p in varsCopy) {
	      config[p] = varsCopy[p];
	    }

	    config.trigger = target;
	    result.push(ScrollTrigger.create(config));
	  });

	  return result;
	};

	ScrollTrigger.sort = function (func) {
	  return _triggers.sort(func || function (a, b) {
	    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
	  });
	};

	_getGSAP() && gsap.registerPlugin(ScrollTrigger);

	exports.ScrollTrigger = ScrollTrigger;
	exports.default = ScrollTrigger;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

	/*!
	 * ScrollToPlugin 3.6.1
	 * https://greensock.com
	 *
	 * @license Copyright 2008-2021, GreenSock. All rights reserved.
	 * Subject to the terms at https://greensock.com/standard-license or for
	 * Club GreenSock members, the agreement issued with that membership.
	 * @author: Jack Doyle, jack@greensock.com
	*/
	var gsap,
	    _coreInitted,
	    _window,
	    _docEl,
	    _body,
	    _toArray,
	    _config,
	    _windowExists = function _windowExists() {
	  return typeof window !== "undefined";
	},
	    _getGSAP = function _getGSAP() {
	  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
	},
	    _isString = function _isString(value) {
	  return typeof value === "string";
	},
	    _isFunction = function _isFunction(value) {
	  return typeof value === "function";
	},
	    _max = function _max(element, axis) {
	  var dim = axis === "x" ? "Width" : "Height",
	      scroll = "scroll" + dim,
	      client = "client" + dim;
	  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
	},
	    _buildGetter = function _buildGetter(e, axis) {
	  var p = "scroll" + (axis === "x" ? "Left" : "Top");

	  if (e === _window) {
	    if (e.pageXOffset != null) {
	      p = "page" + axis.toUpperCase() + "Offset";
	    } else {
	      e = _docEl[p] != null ? _docEl : _body;
	    }
	  }

	  return function () {
	    return e[p];
	  };
	},
	    _clean = function _clean(value, index, target, targets) {
	  _isFunction(value) && (value = value(index, target, targets));

	  if (typeof value !== "object") {
	    return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
	      x: value,
	      y: value
	    } : {
	      y: value
	    };
	  } else if (value.nodeType) {
	    return {
	      y: value,
	      x: value
	    };
	  } else {
	    var result = {},
	        p;

	    for (p in value) {
	      result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
	    }

	    return result;
	  }
	},
	    _getOffset = function _getOffset(element, container) {
	  element = _toArray(element)[0];

	  if (!element || !element.getBoundingClientRect) {
	    return console.warn("scrollTo target doesn't exist. Using 0") || {
	      x: 0,
	      y: 0
	    };
	  }

	  var rect = element.getBoundingClientRect(),
	      isRoot = !container || container === _window || container === _body,
	      cRect = isRoot ? {
	    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
	    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
	  } : container.getBoundingClientRect(),
	      offsets = {
	    x: rect.left - cRect.left,
	    y: rect.top - cRect.top
	  };

	  if (!isRoot && container) {
	    offsets.x += _buildGetter(container, "x")();
	    offsets.y += _buildGetter(container, "y")();
	  }

	  return offsets;
	},
	    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
	  return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
	},
	    _initCore = function _initCore() {
	  gsap = _getGSAP();

	  if (_windowExists() && gsap && document.body) {
	    _window = window;
	    _body = document.body;
	    _docEl = document.documentElement;
	    _toArray = gsap.utils.toArray;
	    gsap.config({
	      autoKillThreshold: 7
	    });
	    _config = gsap.config();
	    _coreInitted = 1;
	  }
	};

	var ScrollToPlugin = {
	  version: "3.6.1",
	  name: "scrollTo",
	  rawVars: 1,
	  register: function register(core) {
	    gsap = core;

	    _initCore();
	  },
	  init: function init(target, value, tween, index, targets) {
	    _coreInitted || _initCore();
	    var data = this;
	    data.isWin = target === _window;
	    data.target = target;
	    data.tween = tween;
	    value = _clean(value, index, target, targets);
	    data.vars = value;
	    data.autoKill = !!value.autoKill;
	    data.getX = _buildGetter(target, "x");
	    data.getY = _buildGetter(target, "y");
	    data.x = data.xPrev = data.getX();
	    data.y = data.yPrev = data.getY();

	    if (value.x != null) {
	      data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);

	      data._props.push("scrollTo_x");
	    } else {
	      data.skipX = 1;
	    }

	    if (value.y != null) {
	      data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);

	      data._props.push("scrollTo_y");
	    } else {
	      data.skipY = 1;
	    }
	  },
	  render: function render(ratio, data) {
	    var pt = data._pt,
	        target = data.target,
	        tween = data.tween,
	        autoKill = data.autoKill,
	        xPrev = data.xPrev,
	        yPrev = data.yPrev,
	        isWin = data.isWin,
	        x,
	        y,
	        yDif,
	        xDif,
	        threshold;

	    while (pt) {
	      pt.r(ratio, pt.d);
	      pt = pt._next;
	    }

	    x = isWin || !data.skipX ? data.getX() : xPrev;
	    y = isWin || !data.skipY ? data.getY() : yPrev;
	    yDif = y - yPrev;
	    xDif = x - xPrev;
	    threshold = _config.autoKillThreshold;

	    if (data.x < 0) {
	      data.x = 0;
	    }

	    if (data.y < 0) {
	      data.y = 0;
	    }

	    if (autoKill) {
	      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
	        data.skipX = 1;
	      }

	      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
	        data.skipY = 1;
	      }

	      if (data.skipX && data.skipY) {
	        tween.kill();
	        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
	      }
	    }

	    if (isWin) {
	      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
	    } else {
	      data.skipY || (target.scrollTop = data.y);
	      data.skipX || (target.scrollLeft = data.x);
	    }

	    data.xPrev = data.x;
	    data.yPrev = data.y;
	  },
	  kill: function kill(property) {
	    var both = property === "scrollTo";

	    if (both || property === "scrollTo_x") {
	      this.skipX = 1;
	    }

	    if (both || property === "scrollTo_y") {
	      this.skipY = 1;
	    }
	  }
	};
	ScrollToPlugin.max = _max;
	ScrollToPlugin.getOffset = _getOffset;
	ScrollToPlugin.buildGetter = _buildGetter;
	_getGSAP() && gsap.registerPlugin(ScrollToPlugin);

	exports.ScrollToPlugin = ScrollToPlugin;
	exports.default = ScrollToPlugin;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.window = global.window || {}));
  }(this, (function (exports) { 'use strict';
  
	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}
  
	function _assertThisInitialized(self) {
	  if (self === void 0) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
  
	  return self;
	}
  
	var _doc,
		_win,
		_docElement,
		_body,
		_divContainer,
		_svgContainer,
		_identityMatrix,
		_gEl,
		_transformProp = "transform",
		_transformOriginProp = _transformProp + "Origin",
		_hasOffsetBug,
		_setDoc = function _setDoc(element) {
	  var doc = element.ownerDocument || element;
  
	  if (!(_transformProp in element.style) && "msTransform" in element.style) {
		_transformProp = "msTransform";
		_transformOriginProp = _transformProp + "Origin";
	  }
  
	  while (doc.parentNode && (doc = doc.parentNode)) {}
  
	  _win = window;
	  _identityMatrix = new Matrix2D();
  
	  if (doc) {
		_doc = doc;
		_docElement = doc.documentElement;
		_body = doc.body;
		_gEl = _doc.createElementNS("http://www.w3.org/2000/svg", "g");
		_gEl.style.transform = "none";
		var d1 = doc.createElement("div"),
			d2 = doc.createElement("div");
  
		_body.appendChild(d1);
  
		d1.appendChild(d2);
		d1.style.position = "static";
		d1.style[_transformProp] = "translate3d(0,0,1px)";
		_hasOffsetBug = d2.offsetParent !== d1;
  
		_body.removeChild(d1);
	  }
  
	  return doc;
	},
		_forceNonZeroScale = function _forceNonZeroScale(e) {
	  var a, cache;
  
	  while (e && e !== _body) {
		cache = e._gsap;
		cache && cache.uncache && cache.get(e, "x");
  
		if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
		  cache.scaleX = cache.scaleY = 1e-4;
		  cache.renderTransform(1, cache);
		  a ? a.push(cache) : a = [cache];
		}
  
		e = e.parentNode;
	  }
  
	  return a;
	},
		_svgTemps = [],
		_divTemps = [],
		_getDocScrollTop = function _getDocScrollTop() {
	  return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;
	},
		_getDocScrollLeft = function _getDocScrollLeft() {
	  return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;
	},
		_svgOwner = function _svgOwner(element) {
	  return element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null);
	},
		_isFixed = function _isFixed(element) {
	  if (_win.getComputedStyle(element).position === "fixed") {
		return true;
	  }
  
	  element = element.parentNode;
  
	  if (element && element.nodeType === 1) {
		return _isFixed(element);
	  }
	},
		_createSibling = function _createSibling(element, i) {
	  if (element.parentNode && (_doc || _setDoc(element))) {
		var svg = _svgOwner(element),
			ns = svg ? svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
			type = svg ? i ? "rect" : "g" : "div",
			x = i !== 2 ? 0 : 100,
			y = i === 3 ? 100 : 0,
			css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
			e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, "http"), type) : _doc.createElement(type);
  
		if (i) {
		  if (!svg) {
			if (!_divContainer) {
			  _divContainer = _createSibling(element);
			  _divContainer.style.cssText = css;
			}
  
			e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";
  
			_divContainer.appendChild(e);
		  } else {
			_svgContainer || (_svgContainer = _createSibling(element));
			e.setAttribute("width", 0.01);
			e.setAttribute("height", 0.01);
			e.setAttribute("transform", "translate(" + x + "," + y + ")");
  
			_svgContainer.appendChild(e);
		  }
		}
  
		return e;
	  }
  
	  throw "Need document and parent.";
	},
		_consolidate = function _consolidate(m) {
	  var c = new Matrix2D(),
		  i = 0;
  
	  for (; i < m.numberOfItems; i++) {
		c.multiply(m.getItem(i).matrix);
	  }
  
	  return c;
	},
		_getCTM = function _getCTM(svg) {
	  var m = svg.getCTM(),
		  transform;
  
	  if (!m) {
		transform = svg.style[_transformProp];
		svg.style[_transformProp] = "none";
		svg.appendChild(_gEl);
		m = _gEl.getCTM();
		svg.removeChild(_gEl);
		transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, "-$1").toLowerCase());
	  }
  
	  return m || _identityMatrix.clone();
	},
		_placeSiblings = function _placeSiblings(element, adjustGOffset) {
	  var svg = _svgOwner(element),
		  isRootSVG = element === svg,
		  siblings = svg ? _svgTemps : _divTemps,
		  parent = element.parentNode,
		  container,
		  m,
		  b,
		  x,
		  y,
		  cs;
  
	  if (element === _win) {
		return element;
	  }
  
	  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
	  container = svg ? _svgContainer : _divContainer;
  
	  if (svg) {
		if (isRootSVG) {
		  b = _getCTM(element);
		  x = -b.e / b.a;
		  y = -b.f / b.d;
		  m = _identityMatrix;
		} else if (element.getBBox) {
		  b = element.getBBox();
		  m = element.transform ? element.transform.baseVal : {};
		  m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix;
		  x = m.a * b.x + m.c * b.y;
		  y = m.b * b.x + m.d * b.y;
		} else {
		  m = new Matrix2D();
		  x = y = 0;
		}
  
		if (adjustGOffset && element.tagName.toLowerCase() === "g") {
		  x = y = 0;
		}
  
		(isRootSVG ? svg : parent).appendChild(container);
		container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
	  } else {
		x = y = 0;
  
		if (_hasOffsetBug) {
		  m = element.offsetParent;
		  b = element;
  
		  while (b && (b = b.parentNode) && b !== m && b.parentNode) {
			if ((_win.getComputedStyle(b)[_transformProp] + "").length > 4) {
			  x = b.offsetLeft;
			  y = b.offsetTop;
			  b = 0;
			}
		  }
		}
  
		cs = _win.getComputedStyle(element);
  
		if (cs.position !== "absolute" && cs.position !== "fixed") {
		  m = element.offsetParent;
  
		  while (parent && parent !== m) {
			x += parent.scrollLeft || 0;
			y += parent.scrollTop || 0;
			parent = parent.parentNode;
		  }
		}
  
		b = container.style;
		b.top = element.offsetTop - y + "px";
		b.left = element.offsetLeft - x + "px";
		b[_transformProp] = cs[_transformProp];
		b[_transformOriginProp] = cs[_transformOriginProp];
		b.position = cs.position === "fixed" ? "fixed" : "absolute";
		element.parentNode.appendChild(container);
	  }
  
	  return container;
	},
		_setMatrix = function _setMatrix(m, a, b, c, d, e, f) {
	  m.a = a;
	  m.b = b;
	  m.c = c;
	  m.d = d;
	  m.e = e;
	  m.f = f;
	  return m;
	};
  
	var Matrix2D = function () {
	  function Matrix2D(a, b, c, d, e, f) {
		if (a === void 0) {
		  a = 1;
		}
  
		if (b === void 0) {
		  b = 0;
		}
  
		if (c === void 0) {
		  c = 0;
		}
  
		if (d === void 0) {
		  d = 1;
		}
  
		if (e === void 0) {
		  e = 0;
		}
  
		if (f === void 0) {
		  f = 0;
		}
  
		_setMatrix(this, a, b, c, d, e, f);
	  }
  
	  var _proto = Matrix2D.prototype;
  
	  _proto.inverse = function inverse() {
		var a = this.a,
			b = this.b,
			c = this.c,
			d = this.d,
			e = this.e,
			f = this.f,
			determinant = a * d - b * c || 1e-10;
		return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);
	  };
  
	  _proto.multiply = function multiply(matrix) {
		var a = this.a,
			b = this.b,
			c = this.c,
			d = this.d,
			e = this.e,
			f = this.f,
			a2 = matrix.a,
			b2 = matrix.c,
			c2 = matrix.b,
			d2 = matrix.d,
			e2 = matrix.e,
			f2 = matrix.f;
		return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);
	  };
  
	  _proto.clone = function clone() {
		return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);
	  };
  
	  _proto.equals = function equals(matrix) {
		var a = this.a,
			b = this.b,
			c = this.c,
			d = this.d,
			e = this.e,
			f = this.f;
		return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;
	  };
  
	  _proto.apply = function apply(point, decoratee) {
		if (decoratee === void 0) {
		  decoratee = {};
		}
  
		var x = point.x,
			y = point.y,
			a = this.a,
			b = this.b,
			c = this.c,
			d = this.d,
			e = this.e,
			f = this.f;
		decoratee.x = x * a + y * c + e || 0;
		decoratee.y = x * b + y * d + f || 0;
		return decoratee;
	  };
  
	  return Matrix2D;
	}();
	function getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {
	  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {
		return new Matrix2D();
	  }
  
	  var zeroScales = _forceNonZeroScale(element),
		  svg = _svgOwner(element),
		  temps = svg ? _svgTemps : _divTemps,
		  container = _placeSiblings(element, adjustGOffset),
		  b1 = temps[0].getBoundingClientRect(),
		  b2 = temps[1].getBoundingClientRect(),
		  b3 = temps[2].getBoundingClientRect(),
		  parent = container.parentNode,
		  isFixed = !includeScrollInFixed && _isFixed(element),
		  m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));
  
	  parent.removeChild(container);
  
	  if (zeroScales) {
		b1 = zeroScales.length;
  
		while (b1--) {
		  b2 = zeroScales[b1];
		  b2.scaleX = b2.scaleY = 0;
		  b2.renderTransform(1, b2);
		}
	  }
  
	  return inverse ? m.inverse() : m;
	}
  
	var gsap,
		_win$1,
		_doc$1,
		_docElement$1,
		_body$1,
		_tempDiv,
		_placeholderDiv,
		_coreInitted,
		_checkPrefix,
		_toArray,
		_supportsPassive,
		_isTouchDevice,
		_touchEventLookup,
		_dragCount,
		_isMultiTouching,
		_isAndroid,
		InertiaPlugin,
		_defaultCursor,
		_supportsPointer,
		_windowExists = function _windowExists() {
	  return typeof window !== "undefined";
	},
		_getGSAP = function _getGSAP() {
	  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
	},
		_isFunction = function _isFunction(value) {
	  return typeof value === "function";
	},
		_isObject = function _isObject(value) {
	  return typeof value === "object";
	},
		_isUndefined = function _isUndefined(value) {
	  return typeof value === "undefined";
	},
		_emptyFunc = function _emptyFunc() {
	  return false;
	},
		_transformProp$1 = "transform",
		_transformOriginProp$1 = "transformOrigin",
		_round = function _round(value) {
	  return Math.round(value * 10000) / 10000;
	},
		_isArray = Array.isArray,
		_createElement = function _createElement(type, ns) {
	  var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$1.createElement(type);
	  return e.style ? e : _doc$1.createElement(type);
	},
		_RAD2DEG = 180 / Math.PI,
		_bigNum = 1e20,
		_identityMatrix$1 = new Matrix2D(),
		_getTime = Date.now || function () {
	  return new Date().getTime();
	},
		_renderQueue = [],
		_lookup = {},
		_lookupCount = 0,
		_clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
		_lastDragTime = 0,
		_temp1 = {},
		_windowProxy = {},
		_copy = function _copy(obj, factor) {
	  var copy = {},
		  p;
  
	  for (p in obj) {
		copy[p] = factor ? obj[p] * factor : obj[p];
	  }
  
	  return copy;
	},
		_extend = function _extend(obj, defaults) {
	  for (var p in defaults) {
		if (!(p in obj)) {
		  obj[p] = defaults[p];
		}
	  }
  
	  return obj;
	},
		_setTouchActionForAllDescendants = function _setTouchActionForAllDescendants(elements, value) {
	  var i = elements.length,
		  children;
  
	  while (i--) {
		value ? elements[i].style.touchAction = value : elements[i].style.removeProperty("touch-action");
		children = elements[i].children;
		children && children.length && _setTouchActionForAllDescendants(children, value);
	  }
	},
		_renderQueueTick = function _renderQueueTick() {
	  return _renderQueue.forEach(function (func) {
		return func();
	  });
	},
		_addToRenderQueue = function _addToRenderQueue(func) {
	  _renderQueue.push(func);
  
	  if (_renderQueue.length === 1) {
		gsap.ticker.add(_renderQueueTick);
	  }
	},
		_renderQueueTimeout = function _renderQueueTimeout() {
	  return !_renderQueue.length && gsap.ticker.remove(_renderQueueTick);
	},
		_removeFromRenderQueue = function _removeFromRenderQueue(func) {
	  var i = _renderQueue.length;
  
	  while (i--) {
		if (_renderQueue[i] === func) {
		  _renderQueue.splice(i, 1);
		}
	  }
  
	  gsap.to(_renderQueueTimeout, {
		overwrite: true,
		delay: 15,
		duration: 0,
		onComplete: _renderQueueTimeout,
		data: "_draggable"
	  });
	},
		_setDefaults = function _setDefaults(obj, defaults) {
	  for (var p in defaults) {
		if (!(p in obj)) {
		  obj[p] = defaults[p];
		}
	  }
  
	  return obj;
	},
		_addListener = function _addListener(element, type, func, capture) {
	  if (element.addEventListener) {
		var touchType = _touchEventLookup[type];
		capture = capture || (_supportsPassive ? {
		  passive: false
		} : null);
		element.addEventListener(touchType || type, func, capture);
		touchType && type !== touchType && element.addEventListener(type, func, capture);
	  }
	},
		_removeListener = function _removeListener(element, type, func) {
	  if (element.removeEventListener) {
		var touchType = _touchEventLookup[type];
		element.removeEventListener(touchType || type, func);
		touchType && type !== touchType && element.removeEventListener(type, func);
	  }
	},
		_preventDefault = function _preventDefault(event) {
	  event.preventDefault && event.preventDefault();
	  event.preventManipulation && event.preventManipulation();
	},
		_hasTouchID = function _hasTouchID(list, ID) {
	  var i = list.length;
  
	  while (i--) {
		if (list[i].identifier === ID) {
		  return true;
		}
	  }
	},
		_onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(event) {
	  _isMultiTouching = event.touches && _dragCount < event.touches.length;
  
	  _removeListener(event.target, "touchend", _onMultiTouchDocumentEnd);
	},
		_onMultiTouchDocument = function _onMultiTouchDocument(event) {
	  _isMultiTouching = event.touches && _dragCount < event.touches.length;
  
	  _addListener(event.target, "touchend", _onMultiTouchDocumentEnd);
	},
		_getDocScrollTop$1 = function _getDocScrollTop(doc) {
	  return _win$1.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;
	},
		_getDocScrollLeft$1 = function _getDocScrollLeft(doc) {
	  return _win$1.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;
	},
		_addScrollListener = function _addScrollListener(e, callback) {
	  _addListener(e, "scroll", callback);
  
	  if (!_isRoot(e.parentNode)) {
		_addScrollListener(e.parentNode, callback);
	  }
	},
		_removeScrollListener = function _removeScrollListener(e, callback) {
	  _removeListener(e, "scroll", callback);
  
	  if (!_isRoot(e.parentNode)) {
		_removeScrollListener(e.parentNode, callback);
	  }
	},
		_isRoot = function _isRoot(e) {
	  return !!(!e || e === _docElement$1 || e.nodeType === 9 || e === _doc$1.body || e === _win$1 || !e.nodeType || !e.parentNode);
	},
		_getMaxScroll = function _getMaxScroll(element, axis) {
	  var dim = axis === "x" ? "Width" : "Height",
		  scroll = "scroll" + dim,
		  client = "client" + dim;
	  return Math.max(0, _isRoot(element) ? Math.max(_docElement$1[scroll], _body$1[scroll]) - (_win$1["inner" + dim] || _docElement$1[client] || _body$1[client]) : element[scroll] - element[client]);
	},
		_recordMaxScrolls = function _recordMaxScrolls(e, skipCurrent) {
	  var x = _getMaxScroll(e, "x"),
		  y = _getMaxScroll(e, "y");
  
	  if (_isRoot(e)) {
		e = _windowProxy;
	  } else {
		_recordMaxScrolls(e.parentNode, skipCurrent);
	  }
  
	  e._gsMaxScrollX = x;
	  e._gsMaxScrollY = y;
  
	  if (!skipCurrent) {
		e._gsScrollX = e.scrollLeft || 0;
		e._gsScrollY = e.scrollTop || 0;
	  }
	},
		_setStyle = function _setStyle(element, property, value) {
	  var style = element.style;
  
	  if (!style) {
		return;
	  }
  
	  if (_isUndefined(style[property])) {
		property = _checkPrefix(property, element) || property;
	  }
  
	  if (value == null) {
		style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());
	  } else {
		style[property] = value;
	  }
	},
		_getComputedStyle = function _getComputedStyle(element) {
	  return _win$1.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);
	},
		_tempRect = {},
		_parseRect = function _parseRect(e) {
	  if (e === _win$1) {
		_tempRect.left = _tempRect.top = 0;
		_tempRect.width = _tempRect.right = _docElement$1.clientWidth || e.innerWidth || _body$1.clientWidth || 0;
		_tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement$1.clientHeight ? _docElement$1.clientHeight : e.innerHeight || _body$1.clientHeight || 0;
		return _tempRect;
	  }
  
	  var doc = e.ownerDocument || _doc$1,
		  r = !_isUndefined(e.pageX) ? {
		left: e.pageX - _getDocScrollLeft$1(doc),
		top: e.pageY - _getDocScrollTop$1(doc),
		right: e.pageX - _getDocScrollLeft$1(doc) + 1,
		bottom: e.pageY - _getDocScrollTop$1(doc) + 1
	  } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();
  
	  if (_isUndefined(r.right) && !_isUndefined(r.width)) {
		r.right = r.left + r.width;
		r.bottom = r.top + r.height;
	  } else if (_isUndefined(r.width)) {
		r = {
		  width: r.right - r.left,
		  height: r.bottom - r.top,
		  right: r.right,
		  left: r.left,
		  bottom: r.bottom,
		  top: r.top
		};
	  }
  
	  return r;
	},
		_dispatchEvent = function _dispatchEvent(target, type, callbackName) {
	  var vars = target.vars,
		  callback = vars[callbackName],
		  listeners = target._listeners[type],
		  result;
  
	  if (_isFunction(callback)) {
		result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);
	  }
  
	  if (listeners && target.dispatchEvent(type) === false) {
		result = false;
	  }
  
	  return result;
	},
		_getBounds = function _getBounds(target, context) {
	  var e = _toArray(target)[0],
		  top,
		  left,
		  offset;
  
	  if (!e.nodeType && e !== _win$1) {
		if (!_isUndefined(target.left)) {
		  offset = {
			x: 0,
			y: 0
		  };
		  return {
			left: target.left - offset.x,
			top: target.top - offset.y,
			width: target.width,
			height: target.height
		  };
		}
  
		left = target.min || target.minX || target.minRotation || 0;
		top = target.min || target.minY || 0;
		return {
		  left: left,
		  top: top,
		  width: (target.max || target.maxX || target.maxRotation || 0) - left,
		  height: (target.max || target.maxY || 0) - top
		};
	  }
  
	  return _getElementBounds(e, context);
	},
		_point1 = {},
		_getElementBounds = function _getElementBounds(element, context) {
	  context = _toArray(context)[0];
	  var isSVG = element.getBBox && element.ownerSVGElement,
		  doc = element.ownerDocument || _doc$1,
		  left,
		  right,
		  top,
		  bottom,
		  matrix,
		  p1,
		  p2,
		  p3,
		  p4,
		  bbox,
		  width,
		  height,
		  cs,
		  contextParent;
  
	  if (element === _win$1) {
		top = _getDocScrollTop$1(doc);
		left = _getDocScrollLeft$1(doc);
		right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);
		bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0);
	  } else if (context === _win$1 || _isUndefined(context)) {
		return element.getBoundingClientRect();
	  } else {
		left = top = 0;
  
		if (isSVG) {
		  bbox = element.getBBox();
		  width = bbox.width;
		  height = bbox.height;
		} else {
		  if (element.viewBox && (bbox = element.viewBox.baseVal)) {
			left = bbox.x || 0;
			top = bbox.y || 0;
			width = bbox.width;
			height = bbox.height;
		  }
  
		  if (!width) {
			cs = _getComputedStyle(element);
			bbox = cs.boxSizing === "border-box";
			width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));
			height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));
		  }
		}
  
		right = width;
		bottom = height;
	  }
  
	  if (element === context) {
		return {
		  left: left,
		  top: top,
		  width: right - left,
		  height: bottom - top
		};
	  }
  
	  matrix = getGlobalMatrix(context, true).multiply(getGlobalMatrix(element));
	  p1 = matrix.apply({
		x: left,
		y: top
	  });
	  p2 = matrix.apply({
		x: right,
		y: top
	  });
	  p3 = matrix.apply({
		x: right,
		y: bottom
	  });
	  p4 = matrix.apply({
		x: left,
		y: bottom
	  });
	  left = Math.min(p1.x, p2.x, p3.x, p4.x);
	  top = Math.min(p1.y, p2.y, p3.y, p4.y);
	  contextParent = context.parentNode || {};
	  return {
		left: left + (contextParent.scrollLeft || 0),
		top: top + (contextParent.scrollTop || 0),
		width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,
		height: Math.max(p1.y, p2.y, p3.y, p4.y) - top
	  };
	},
		_parseInertia = function _parseInertia(draggable, snap, max, min, factor, forceZeroVelocity) {
	  var vars = {},
		  a,
		  i,
		  l;
  
	  if (snap) {
		if (factor !== 1 && snap instanceof Array) {
		  vars.end = a = [];
		  l = snap.length;
  
		  if (_isObject(snap[0])) {
			for (i = 0; i < l; i++) {
			  a[i] = _copy(snap[i], factor);
			}
		  } else {
			for (i = 0; i < l; i++) {
			  a[i] = snap[i] * factor;
			}
		  }
  
		  max += 1.1;
		  min -= 1.1;
		} else if (_isFunction(snap)) {
		  vars.end = function (value) {
			var result = snap.call(draggable, value),
				copy,
				p;
  
			if (factor !== 1) {
			  if (_isObject(result)) {
				copy = {};
  
				for (p in result) {
				  copy[p] = result[p] * factor;
				}
  
				result = copy;
			  } else {
				result *= factor;
			  }
			}
  
			return result;
		  };
		} else {
		  vars.end = snap;
		}
	  }
  
	  if (max || max === 0) {
		vars.max = max;
	  }
  
	  if (min || min === 0) {
		vars.min = min;
	  }
  
	  if (forceZeroVelocity) {
		vars.velocity = 0;
	  }
  
	  return vars;
	},
		_isClickable = function _isClickable(element) {
	  var data;
	  return !element || !element.getAttribute || element === _body$1 ? false : (data = element.getAttribute("data-clickable")) === "true" || data !== "false" && (element.onclick || _clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true") ? true : _isClickable(element.parentNode);
	},
		_setSelectable = function _setSelectable(elements, selectable) {
	  var i = elements.length,
		  e;
  
	  while (i--) {
		e = elements[i];
		e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;
		gsap.set(e, {
		  lazy: true,
		  userSelect: selectable ? "text" : "none"
		});
	  }
	},
		_isFixed$1 = function _isFixed(element) {
	  if (_getComputedStyle(element).position === "fixed") {
		return true;
	  }
  
	  element = element.parentNode;
  
	  if (element && element.nodeType === 1) {
		return _isFixed(element);
	  }
	},
		_supports3D,
		_addPaddingBR,
		ScrollProxy = function ScrollProxy(element, vars) {
	  element = gsap.utils.toArray(element)[0];
	  vars = vars || {};
	  var content = document.createElement("div"),
		  style = content.style,
		  node = element.firstChild,
		  offsetTop = 0,
		  offsetLeft = 0,
		  prevTop = element.scrollTop,
		  prevLeft = element.scrollLeft,
		  scrollWidth = element.scrollWidth,
		  scrollHeight = element.scrollHeight,
		  extraPadRight = 0,
		  maxLeft = 0,
		  maxTop = 0,
		  elementWidth,
		  elementHeight,
		  contentHeight,
		  nextNode,
		  transformStart,
		  transformEnd;
  
	  if (_supports3D && vars.force3D !== false) {
		transformStart = "translate3d(";
		transformEnd = "px,0px)";
	  } else if (_transformProp$1) {
		transformStart = "translate(";
		transformEnd = "px)";
	  }
  
	  this.scrollTop = function (value, force) {
		if (!arguments.length) {
		  return -this.top();
		}
  
		this.top(-value, force);
	  };
  
	  this.scrollLeft = function (value, force) {
		if (!arguments.length) {
		  return -this.left();
		}
  
		this.left(-value, force);
	  };
  
	  this.left = function (value, force) {
		if (!arguments.length) {
		  return -(element.scrollLeft + offsetLeft);
		}
  
		var dif = element.scrollLeft - prevLeft,
			oldOffset = offsetLeft;
  
		if ((dif > 2 || dif < -2) && !force) {
		  prevLeft = element.scrollLeft;
		  gsap.killTweensOf(this, {
			left: 1,
			scrollLeft: 1
		  });
		  this.left(-prevLeft);
  
		  if (vars.onKill) {
			vars.onKill();
		  }
  
		  return;
		}
  
		value = -value;
  
		if (value < 0) {
		  offsetLeft = value - 0.5 | 0;
		  value = 0;
		} else if (value > maxLeft) {
		  offsetLeft = value - maxLeft | 0;
		  value = maxLeft;
		} else {
		  offsetLeft = 0;
		}
  
		if (offsetLeft || oldOffset) {
		  if (!this._skip) {
			style[_transformProp$1] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
		  }
  
		  if (offsetLeft + extraPadRight >= 0) {
			style.paddingRight = offsetLeft + extraPadRight + "px";
		  }
		}
  
		element.scrollLeft = value | 0;
		prevLeft = element.scrollLeft;
	  };
  
	  this.top = function (value, force) {
		if (!arguments.length) {
		  return -(element.scrollTop + offsetTop);
		}
  
		var dif = element.scrollTop - prevTop,
			oldOffset = offsetTop;
  
		if ((dif > 2 || dif < -2) && !force) {
		  prevTop = element.scrollTop;
		  gsap.killTweensOf(this, {
			top: 1,
			scrollTop: 1
		  });
		  this.top(-prevTop);
  
		  if (vars.onKill) {
			vars.onKill();
		  }
  
		  return;
		}
  
		value = -value;
  
		if (value < 0) {
		  offsetTop = value - 0.5 | 0;
		  value = 0;
		} else if (value > maxTop) {
		  offsetTop = value - maxTop | 0;
		  value = maxTop;
		} else {
		  offsetTop = 0;
		}
  
		if (offsetTop || oldOffset) {
		  if (!this._skip) {
			style[_transformProp$1] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
		  }
		}
  
		element.scrollTop = value | 0;
		prevTop = element.scrollTop;
	  };
  
	  this.maxScrollTop = function () {
		return maxTop;
	  };
  
	  this.maxScrollLeft = function () {
		return maxLeft;
	  };
  
	  this.disable = function () {
		node = content.firstChild;
  
		while (node) {
		  nextNode = node.nextSibling;
		  element.appendChild(node);
		  node = nextNode;
		}
  
		if (element === content.parentNode) {
		  element.removeChild(content);
		}
	  };
  
	  this.enable = function () {
		node = element.firstChild;
  
		if (node === content) {
		  return;
		}
  
		while (node) {
		  nextNode = node.nextSibling;
		  content.appendChild(node);
		  node = nextNode;
		}
  
		element.appendChild(content);
		this.calibrate();
	  };
  
	  this.calibrate = function (force) {
		var widthMatches = element.clientWidth === elementWidth,
			cs,
			x,
			y;
		prevTop = element.scrollTop;
		prevLeft = element.scrollLeft;
  
		if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
		  return;
		}
  
		if (offsetTop || offsetLeft) {
		  x = this.left();
		  y = this.top();
		  this.left(-element.scrollLeft);
		  this.top(-element.scrollTop);
		}
  
		cs = _getComputedStyle(element);
  
		if (!widthMatches || force) {
		  style.display = "block";
		  style.width = "auto";
		  style.paddingRight = "0px";
		  extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
  
		  if (extraPadRight) {
			extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);
		  }
		}
  
		style.display = "inline-block";
		style.position = "relative";
		style.overflow = "visible";
		style.verticalAlign = "top";
		style.boxSizing = "content-box";
		style.width = "100%";
		style.paddingRight = extraPadRight + "px";
  
		if (_addPaddingBR) {
		  style.paddingBottom = cs.paddingBottom;
		}
  
		elementWidth = element.clientWidth;
		elementHeight = element.clientHeight;
		scrollWidth = element.scrollWidth;
		scrollHeight = element.scrollHeight;
		maxLeft = element.scrollWidth - elementWidth;
		maxTop = element.scrollHeight - elementHeight;
		contentHeight = content.offsetHeight;
		style.display = "block";
  
		if (x || y) {
		  this.left(x);
		  this.top(y);
		}
	  };
  
	  this.content = content;
	  this.element = element;
	  this._skip = false;
	  this.enable();
	},
		_initCore = function _initCore(required) {
	  if (_windowExists() && document.body) {
		var nav = window && window.navigator;
		_win$1 = window;
		_doc$1 = document;
		_docElement$1 = _doc$1.documentElement;
		_body$1 = _doc$1.body;
		_tempDiv = _createElement("div");
		_supportsPointer = !!window.PointerEvent;
		_placeholderDiv = _createElement("div");
		_placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";
		_defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";
		_isAndroid = nav && nav.userAgent.toLowerCase().indexOf("android") !== -1;
		_isTouchDevice = "ontouchstart" in _docElement$1 && "orientation" in _win$1 || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);
  
		_addPaddingBR = function () {
		  var div = _createElement("div"),
			  child = _createElement("div"),
			  childStyle = child.style,
			  parent = _body$1,
			  val;
  
		  childStyle.display = "inline-block";
		  childStyle.position = "relative";
		  div.style.cssText = child.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";
		  div.appendChild(child);
		  parent.appendChild(div);
		  val = child.offsetHeight + 18 > div.scrollHeight;
		  parent.removeChild(div);
		  return val;
		}();
  
		_touchEventLookup = function (types) {
		  var standard = types.split(","),
			  converted = ("onpointerdown" in _tempDiv ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in _tempDiv ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
			  obj = {},
			  i = 4;
  
		  while (--i > -1) {
			obj[standard[i]] = converted[i];
			obj[converted[i]] = standard[i];
		  }
  
		  try {
			_docElement$1.addEventListener("test", null, Object.defineProperty({}, "passive", {
			  get: function get() {
				_supportsPassive = 1;
			  }
			}));
		  } catch (e) {}
  
		  return obj;
		}("touchstart,touchmove,touchend,touchcancel");
  
		_addListener(_doc$1, "touchcancel", _emptyFunc);
  
		_addListener(_win$1, "touchmove", _emptyFunc);
  
		_body$1 && _body$1.addEventListener("touchstart", _emptyFunc);
  
		_addListener(_doc$1, "contextmenu", function () {
		  for (var p in _lookup) {
			if (_lookup[p].isPressed) {
			  _lookup[p].endDrag();
			}
		  }
		});
  
		gsap = _coreInitted = _getGSAP();
	  }
  
	  if (gsap) {
		InertiaPlugin = gsap.plugins.inertia;
		_checkPrefix = gsap.utils.checkPrefix;
		_transformProp$1 = _checkPrefix(_transformProp$1);
		_transformOriginProp$1 = _checkPrefix(_transformOriginProp$1);
		_toArray = gsap.utils.toArray;
		_supports3D = !!_checkPrefix("perspective");
	  } else if (required) {
		console.warn("Please gsap.registerPlugin(Draggable)");
	  }
	};
  
	var EventDispatcher = function () {
	  function EventDispatcher(target) {
		this._listeners = {};
		this.target = target || this;
	  }
  
	  var _proto = EventDispatcher.prototype;
  
	  _proto.addEventListener = function addEventListener(type, callback) {
		var list = this._listeners[type] || (this._listeners[type] = []);
  
		if (!~list.indexOf(callback)) {
		  list.push(callback);
		}
	  };
  
	  _proto.removeEventListener = function removeEventListener(type, callback) {
		var list = this._listeners[type],
			i = list && list.indexOf(callback) || -1;
		i > -1 && list.splice(i, 1);
	  };
  
	  _proto.dispatchEvent = function dispatchEvent(type) {
		var _this = this;
  
		var result;
		(this._listeners[type] || []).forEach(function (callback) {
		  return callback.call(_this, {
			type: type,
			target: _this.target
		  }) === false && (result = false);
		});
		return result;
	  };
  
	  return EventDispatcher;
	}();
  
	var Draggable = function (_EventDispatcher) {
	  _inheritsLoose(Draggable, _EventDispatcher);
  
	  function Draggable(target, vars) {
		var _this2;
  
		_this2 = _EventDispatcher.call(this) || this;
		_coreInitted || _initCore(1);
		target = _toArray(target)[0];
  
		if (!InertiaPlugin) {
		  InertiaPlugin = gsap.plugins.inertia;
		}
  
		_this2.vars = vars = _copy(vars || {});
		_this2.target = target;
		_this2.x = _this2.y = _this2.rotation = 0;
		_this2.dragResistance = parseFloat(vars.dragResistance) || 0;
		_this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
		_this2.lockAxis = vars.lockAxis;
		_this2.autoScroll = vars.autoScroll || 0;
		_this2.lockedAxis = null;
		_this2.allowEventDefault = !!vars.allowEventDefault;
		gsap.getProperty(target, "x");
  
		var type = (vars.type || "x,y").toLowerCase(),
			xyMode = ~type.indexOf("x") || ~type.indexOf("y"),
			rotationMode = type.indexOf("rotation") !== -1,
			xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
			yProp = xyMode ? "y" : "top",
			allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"),
			allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"),
			minimumMovement = vars.minimumMovement || 2,
			self = _assertThisInitialized(_this2),
			triggers = _toArray(vars.trigger || vars.handle || target),
			killProps = {},
			dragEndTime = 0,
			checkAutoScrollBounds = false,
			autoScrollMarginTop = vars.autoScrollMarginTop || 40,
			autoScrollMarginRight = vars.autoScrollMarginRight || 40,
			autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,
			autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,
			isClickable = vars.clickableTest || _isClickable,
			clickTime = 0,
			gsCache = target._gsap || gsap.core.getCache(target),
			isFixed = _isFixed$1(target),
			getPropAsNum = function getPropAsNum(property, unit) {
		  return parseFloat(gsCache.get(target, property, unit));
		},
			ownerDoc = target.ownerDocument || _doc$1,
			enabled,
			scrollProxy,
			startPointerX,
			startPointerY,
			startElementX,
			startElementY,
			hasBounds,
			hasDragCallback,
			hasMoveCallback,
			maxX,
			minX,
			maxY,
			minY,
			touch,
			touchID,
			rotationOrigin,
			dirty,
			old,
			snapX,
			snapY,
			snapXY,
			isClicking,
			touchEventTarget,
			matrix,
			interrupted,
			allowNativeTouchScrolling,
			touchDragAxis,
			isDispatching,
			clickDispatch,
			trustedClickDispatch,
			isPreventingDefault,
			innerMatrix,
			onContextMenu = function onContextMenu(e) {
		  _preventDefault(e);
  
		  e.stopImmediatePropagation && e.stopImmediatePropagation();
		  return false;
		},
			render = function render(suppressEvents) {
		  if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
			var e = target,
				autoScrollFactor = self.autoScroll * 15,
				parent,
				isRoot,
				rect,
				pointerX,
				pointerY,
				changeX,
				changeY,
				gap;
			checkAutoScrollBounds = false;
			_windowProxy.scrollTop = _win$1.pageYOffset != null ? _win$1.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
			_windowProxy.scrollLeft = _win$1.pageXOffset != null ? _win$1.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
			pointerX = self.pointerX - _windowProxy.scrollLeft;
			pointerY = self.pointerY - _windowProxy.scrollTop;
  
			while (e && !isRoot) {
			  isRoot = _isRoot(e.parentNode);
			  parent = isRoot ? _windowProxy : e.parentNode;
			  rect = isRoot ? {
				bottom: Math.max(_docElement$1.clientHeight, _win$1.innerHeight || 0),
				right: Math.max(_docElement$1.clientWidth, _win$1.innerWidth || 0),
				left: 0,
				top: 0
			  } : parent.getBoundingClientRect();
			  changeX = changeY = 0;
  
			  if (allowY) {
				gap = parent._gsMaxScrollY - parent.scrollTop;
  
				if (gap < 0) {
				  changeY = gap;
				} else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
				  checkAutoScrollBounds = true;
				  changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);
				} else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
				  checkAutoScrollBounds = true;
				  changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);
				}
  
				if (changeY) {
				  parent.scrollTop += changeY;
				}
			  }
  
			  if (allowX) {
				gap = parent._gsMaxScrollX - parent.scrollLeft;
  
				if (gap < 0) {
				  changeX = gap;
				} else if (pointerX > rect.right - autoScrollMarginRight && gap) {
				  checkAutoScrollBounds = true;
				  changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);
				} else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
				  checkAutoScrollBounds = true;
				  changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);
				}
  
				if (changeX) {
				  parent.scrollLeft += changeX;
				}
			  }
  
			  if (isRoot && (changeX || changeY)) {
				_win$1.scrollTo(parent.scrollLeft, parent.scrollTop);
  
				setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
			  }
  
			  e = parent;
			}
		  }
  
		  if (dirty) {
			var x = self.x,
				y = self.y;
  
			if (rotationMode) {
			  self.deltaX = x - parseFloat(gsCache.rotation);
			  self.rotation = x;
			  gsCache.rotation = x + "deg";
			  gsCache.renderTransform(1, gsCache);
			} else {
			  if (scrollProxy) {
				if (allowY) {
				  self.deltaY = y - scrollProxy.top();
				  scrollProxy.top(y);
				}
  
				if (allowX) {
				  self.deltaX = x - scrollProxy.left();
				  scrollProxy.left(x);
				}
			  } else if (xyMode) {
				if (allowY) {
				  self.deltaY = y - parseFloat(gsCache.y);
				  gsCache.y = y + "px";
				}
  
				if (allowX) {
				  self.deltaX = x - parseFloat(gsCache.x);
				  gsCache.x = x + "px";
				}
  
				gsCache.renderTransform(1, gsCache);
			  } else {
				if (allowY) {
				  self.deltaY = y - parseFloat(target.style.top || 0);
				  target.style.top = y + "px";
				}
  
				if (allowX) {
				  self.deltaX = x - parseFloat(target.style.left || 0);
				  target.style.left = x + "px";
				}
			  }
			}
  
			if (hasDragCallback && !suppressEvents && !isDispatching) {
			  isDispatching = true;
  
			  if (_dispatchEvent(self, "drag", "onDrag") === false) {
				if (allowX) {
				  self.x -= self.deltaX;
				}
  
				if (allowY) {
				  self.y -= self.deltaY;
				}
  
				render(true);
			  }
  
			  isDispatching = false;
			}
		  }
  
		  dirty = false;
		},
			syncXY = function syncXY(skipOnUpdate, skipSnap) {
		  var x = self.x,
			  y = self.y,
			  snappedValue,
			  cs;
  
		  if (!target._gsap) {
			gsCache = gsap.core.getCache(target);
		  }
  
		  gsCache.uncache && gsap.getProperty(target, "x");
  
		  if (xyMode) {
			self.x = parseFloat(gsCache.x);
			self.y = parseFloat(gsCache.y);
		  } else if (rotationMode) {
			self.x = self.rotation = parseFloat(gsCache.rotation);
		  } else if (scrollProxy) {
			self.y = scrollProxy.top();
			self.x = scrollProxy.left();
		  } else {
			self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;
			self.x = parseFloat(target.style.left || (cs || {}).left) || 0;
		  }
  
		  if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {
			if (snapXY) {
			  _temp1.x = self.x;
			  _temp1.y = self.y;
			  snappedValue = snapXY(_temp1);
  
			  if (snappedValue.x !== self.x) {
				self.x = snappedValue.x;
				dirty = true;
			  }
  
			  if (snappedValue.y !== self.y) {
				self.y = snappedValue.y;
				dirty = true;
			  }
			}
  
			if (snapX) {
			  snappedValue = snapX(self.x);
  
			  if (snappedValue !== self.x) {
				self.x = snappedValue;
  
				if (rotationMode) {
				  self.rotation = snappedValue;
				}
  
				dirty = true;
			  }
			}
  
			if (snapY) {
			  snappedValue = snapY(self.y);
  
			  if (snappedValue !== self.y) {
				self.y = snappedValue;
			  }
  
			  dirty = true;
			}
		  }
  
		  dirty && render(true);
  
		  if (!skipOnUpdate) {
			self.deltaX = self.x - x;
			self.deltaY = self.y - y;
  
			_dispatchEvent(self, "throwupdate", "onThrowUpdate");
		  }
		},
			buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {
		  if (min == null) {
			min = -_bigNum;
		  }
  
		  if (max == null) {
			max = _bigNum;
		  }
  
		  if (_isFunction(snap)) {
			return function (n) {
			  var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance;
			  return snap.call(self, n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor;
			};
		  }
  
		  if (_isArray(snap)) {
			return function (n) {
			  var i = snap.length,
				  closest = 0,
				  absDif = _bigNum,
				  val,
				  dif;
  
			  while (--i > -1) {
				val = snap[i];
				dif = val - n;
  
				if (dif < 0) {
				  dif = -dif;
				}
  
				if (dif < absDif && val >= min && val <= max) {
				  closest = i;
				  absDif = dif;
				}
			  }
  
			  return snap[closest];
			};
		  }
  
		  return isNaN(snap) ? function (n) {
			return n;
		  } : function () {
			return snap * factor;
		  };
		},
			buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {
		  radius = radius && radius < _bigNum ? radius * radius : _bigNum;
  
		  if (_isFunction(snap)) {
			return function (point) {
			  var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,
				  x = point.x,
				  y = point.y,
				  result,
				  dx,
				  dy;
			  point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;
			  point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;
			  result = snap.call(self, point);
  
			  if (result !== point) {
				point.x = result.x;
				point.y = result.y;
			  }
  
			  if (factor !== 1) {
				point.x *= factor;
				point.y *= factor;
			  }
  
			  if (radius < _bigNum) {
				dx = point.x - x;
				dy = point.y - y;
  
				if (dx * dx + dy * dy > radius) {
				  point.x = x;
				  point.y = y;
				}
			  }
  
			  return point;
			};
		  }
  
		  if (_isArray(snap)) {
			return function (p) {
			  var i = snap.length,
				  closest = 0,
				  minDist = _bigNum,
				  x,
				  y,
				  point,
				  dist;
  
			  while (--i > -1) {
				point = snap[i];
				x = point.x - p.x;
				y = point.y - p.y;
				dist = x * x + y * y;
  
				if (dist < minDist) {
				  closest = i;
				  minDist = dist;
				}
			  }
  
			  return minDist <= radius ? snap[closest] : p;
			};
		  }
  
		  return function (n) {
			return n;
		  };
		},
			calculateBounds = function calculateBounds() {
		  var bounds, targetBounds, snap, snapIsRaw;
		  hasBounds = false;
  
		  if (scrollProxy) {
			scrollProxy.calibrate();
			self.minX = minX = -scrollProxy.maxScrollLeft();
			self.minY = minY = -scrollProxy.maxScrollTop();
			self.maxX = maxX = self.maxY = maxY = 0;
			hasBounds = true;
		  } else if (!!vars.bounds) {
			bounds = _getBounds(vars.bounds, target.parentNode);
  
			if (rotationMode) {
			  self.minX = minX = bounds.left;
			  self.maxX = maxX = bounds.left + bounds.width;
			  self.minY = minY = self.maxY = maxY = 0;
			} else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {
			  bounds = vars.bounds;
			  self.minX = minX = bounds.minX;
			  self.minY = minY = bounds.minY;
			  self.maxX = maxX = bounds.maxX;
			  self.maxY = maxY = bounds.maxY;
			} else {
			  targetBounds = _getBounds(target, target.parentNode);
			  self.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left);
			  self.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top);
			  self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));
			  self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));
			}
  
			if (minX > maxX) {
			  self.minX = maxX;
			  self.maxX = maxX = minX;
			  minX = self.minX;
			}
  
			if (minY > maxY) {
			  self.minY = maxY;
			  self.maxY = maxY = minY;
			  minY = self.minY;
			}
  
			if (rotationMode) {
			  self.minRotation = minX;
			  self.maxRotation = maxX;
			}
  
			hasBounds = true;
		  }
  
		  if (vars.liveSnap) {
			snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;
			snapIsRaw = _isArray(snap) || _isFunction(snap);
  
			if (rotationMode) {
			  snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);
			  snapY = null;
			} else {
			  if (snap.points) {
				snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);
			  } else {
				if (allowX) {
				  snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);
				}
  
				if (allowY) {
				  snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);
				}
			  }
			}
		  }
		},
			onThrowComplete = function onThrowComplete() {
		  self.isThrowing = false;
  
		  _dispatchEvent(self, "throwcomplete", "onThrowComplete");
		},
			onThrowInterrupt = function onThrowInterrupt() {
		  self.isThrowing = false;
		},
			animate = function animate(inertia, forceZeroVelocity) {
		  var snap, snapIsRaw, tween, overshootTolerance;
  
		  if (inertia && InertiaPlugin) {
			if (inertia === true) {
			  snap = vars.snap || vars.liveSnap || {};
			  snapIsRaw = _isArray(snap) || _isFunction(snap);
			  inertia = {
				resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)
			  };
  
			  if (rotationMode) {
				inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
			  } else {
				if (allowX) {
				  inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "x");
				}
  
				if (allowY) {
				  inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "y");
				}
  
				if (snap.points || _isArray(snap) && _isObject(snap[0])) {
				  inertia.linkedProps = xProp + "," + yProp;
				  inertia.radius = snap.radius;
				}
			  }
			}
  
			self.isThrowing = true;
			overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;
  
			if (!inertia.duration) {
			  inertia.duration = {
				max: Math.max(vars.minDuration || 0, "maxDuration" in vars ? vars.maxDuration : 2),
				min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,
				overshoot: overshootTolerance
			  };
			}
  
			self.tween = tween = gsap.to(scrollProxy || target, {
			  inertia: inertia,
			  data: "_draggable",
			  onComplete: onThrowComplete,
			  onInterrupt: onThrowInterrupt,
			  onUpdate: vars.fastMode ? _dispatchEvent : syncXY,
			  onUpdateParams: vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : snap && snap.radius ? [false, true] : []
			});
  
			if (!vars.fastMode) {
			  if (scrollProxy) {
				scrollProxy._skip = true;
			  }
  
			  tween.render(1e9, true, true);
			  syncXY(true, true);
			  self.endX = self.x;
			  self.endY = self.y;
  
			  if (rotationMode) {
				self.endRotation = self.x;
			  }
  
			  tween.play(0);
			  syncXY(true, true);
  
			  if (scrollProxy) {
				scrollProxy._skip = false;
			  }
			}
		  } else if (hasBounds) {
			self.applyBounds();
		  }
		},
			updateMatrix = function updateMatrix(shiftStart) {
		  var start = matrix,
			  p;
		  matrix = getGlobalMatrix(target.parentNode, true);
  
		  if (shiftStart && self.isPressed && !matrix.equals(start || new Matrix2D())) {
			p = start.inverse().apply({
			  x: startPointerX,
			  y: startPointerY
			});
			matrix.apply(p, p);
			startPointerX = p.x;
			startPointerY = p.y;
		  }
  
		  if (matrix.equals(_identityMatrix$1)) {
			matrix = null;
		  }
		},
			recordStartPositions = function recordStartPositions() {
		  var edgeTolerance = 1 - self.edgeResistance,
			  offsetX = isFixed ? _getDocScrollLeft$1(ownerDoc) : 0,
			  offsetY = isFixed ? _getDocScrollTop$1(ownerDoc) : 0,
			  parsedOrigin,
			  x,
			  y;
		  updateMatrix(false);
		  _point1.x = self.pointerX - offsetX;
		  _point1.y = self.pointerY - offsetY;
		  matrix && matrix.apply(_point1, _point1);
		  startPointerX = _point1.x;
		  startPointerY = _point1.y;
  
		  if (dirty) {
			setPointerPosition(self.pointerX, self.pointerY);
			render(true);
		  }
  
		  innerMatrix = getGlobalMatrix(target);
  
		  if (scrollProxy) {
			calculateBounds();
			startElementY = scrollProxy.top();
			startElementX = scrollProxy.left();
		  } else {
			if (isTweening()) {
			  syncXY(true, true);
			  calculateBounds();
			} else {
			  self.applyBounds();
			}
  
			if (rotationMode) {
			  parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp$1] || "0 0").split(" ");
			  rotationOrigin = self.rotationOrigin = getGlobalMatrix(target).apply({
				x: parseFloat(parsedOrigin[0]) || 0,
				y: parseFloat(parsedOrigin[1]) || 0
			  });
			  syncXY(true, true);
			  x = self.pointerX - rotationOrigin.x - offsetX;
			  y = rotationOrigin.y - self.pointerY + offsetY;
			  startElementX = self.x;
			  startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;
			} else {
			  startElementY = getPropAsNum(yProp, "px");
			  startElementX = getPropAsNum(xProp, "px");
			}
		  }
  
		  if (hasBounds && edgeTolerance) {
			if (startElementX > maxX) {
			  startElementX = maxX + (startElementX - maxX) / edgeTolerance;
			} else if (startElementX < minX) {
			  startElementX = minX - (minX - startElementX) / edgeTolerance;
			}
  
			if (!rotationMode) {
			  if (startElementY > maxY) {
				startElementY = maxY + (startElementY - maxY) / edgeTolerance;
			  } else if (startElementY < minY) {
				startElementY = minY - (minY - startElementY) / edgeTolerance;
			  }
			}
		  }
  
		  self.startX = startElementX = _round(startElementX);
		  self.startY = startElementY = _round(startElementY);
		},
			isTweening = function isTweening() {
		  return self.tween && self.tween.isActive();
		},
			removePlaceholder = function removePlaceholder() {
		  if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {
			_placeholderDiv.parentNode.removeChild(_placeholderDiv);
		  }
		},
			onPress = function onPress(e, force) {
		  var i;
  
		  if (!enabled || self.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {
			isPreventingDefault && e && enabled && _preventDefault(e);
			return;
		  }
  
		  interrupted = isTweening();
		  self.pointerEvent = e;
  
		  if (_touchEventLookup[e.type]) {
			touchEventTarget = ~e.type.indexOf("touch") ? e.currentTarget || e.target : ownerDoc;
  
			_addListener(touchEventTarget, "touchend", onRelease);
  
			_addListener(touchEventTarget, "touchmove", onMove);
  
			_addListener(touchEventTarget, "touchcancel", onRelease);
  
			_addListener(ownerDoc, "touchstart", _onMultiTouchDocument);
		  } else {
			touchEventTarget = null;
  
			_addListener(ownerDoc, "mousemove", onMove);
		  }
  
		  touchDragAxis = null;
  
		  if (!_supportsPointer || !touchEventTarget) {
			_addListener(ownerDoc, "mouseup", onRelease);
  
			e && e.target && _addListener(e.target, "mouseup", onRelease);
		  }
  
		  isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;
  
		  if (isClicking) {
			_addListener(e.target, "change", onRelease);
  
			_dispatchEvent(self, "pressInit", "onPressInit");
  
			_dispatchEvent(self, "press", "onPress");
  
			_setSelectable(triggers, true);
  
			isPreventingDefault = false;
			return;
		  }
  
		  allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x";
		  isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;
  
		  if (isPreventingDefault) {
			_preventDefault(e);
  
			_addListener(_win$1, "touchforcechange", _preventDefault);
		  }
  
		  if (e.changedTouches) {
			e = touch = e.changedTouches[0];
			touchID = e.identifier;
		  } else if (e.pointerId) {
			touchID = e.pointerId;
		  } else {
			touch = touchID = null;
		  }
  
		  _dragCount++;
  
		  _addToRenderQueue(render);
  
		  startPointerY = self.pointerY = e.pageY;
		  startPointerX = self.pointerX = e.pageX;
  
		  _dispatchEvent(self, "pressInit", "onPressInit");
  
		  if (allowNativeTouchScrolling || self.autoScroll) {
			_recordMaxScrolls(target.parentNode);
		  }
  
		  if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {
			_placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
			target.parentNode.appendChild(_placeholderDiv);
		  }
  
		  recordStartPositions();
		  self.tween && self.tween.kill();
		  self.isThrowing = false;
		  gsap.killTweensOf(scrollProxy || target, killProps, true);
		  scrollProxy && gsap.killTweensOf(target, {
			scrollTo: 1
		  }, true);
		  self.tween = self.lockedAxis = null;
  
		  if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {
			target.style.zIndex = Draggable.zIndex++;
		  }
  
		  self.isPressed = true;
		  hasDragCallback = !!(vars.onDrag || self._listeners.drag);
		  hasMoveCallback = !!(vars.onMove || self._listeners.move);
  
		  if (vars.cursor !== false || vars.activeCursor) {
			i = triggers.length;
  
			while (--i > -1) {
			  gsap.set(triggers[i], {
				cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)
			  });
			}
		  }
  
		  _dispatchEvent(self, "press", "onPress");
		},
			onMove = function onMove(e) {
		  var originalEvent = e,
			  touches,
			  pointerX,
			  pointerY,
			  i,
			  dx,
			  dy;
  
		  if (!enabled || _isMultiTouching || !self.isPressed || !e) {
			isPreventingDefault && e && enabled && _preventDefault(e);
			return;
		  }
  
		  self.pointerEvent = e;
		  touches = e.changedTouches;
  
		  if (touches) {
			e = touches[0];
  
			if (e !== touch && e.identifier !== touchID) {
			  i = touches.length;
  
			  while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}
  
			  if (i < 0) {
				return;
			  }
			}
		  } else if (e.pointerId && touchID && e.pointerId !== touchID) {
			return;
		  }
  
		  if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {
			_point1.x = e.pageX - (isFixed ? _getDocScrollLeft$1(ownerDoc) : 0);
			_point1.y = e.pageY - (isFixed ? _getDocScrollTop$1(ownerDoc) : 0);
			matrix && matrix.apply(_point1, _point1);
			pointerX = _point1.x;
			pointerY = _point1.y;
			dx = Math.abs(pointerX - startPointerX);
			dy = Math.abs(pointerY - startPointerY);
  
			if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {
			  touchDragAxis = dx > dy && allowX ? "x" : "y";
  
			  if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {
				_addListener(_win$1, "touchforcechange", _preventDefault);
			  }
  
			  if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {
				self.lockedAxis = touchDragAxis === "x" ? "y" : "x";
				_isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);
			  }
  
			  if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
				onRelease(originalEvent);
				return;
			  }
			}
		  }
  
		  if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {
			_preventDefault(originalEvent);
  
			isPreventingDefault = true;
		  } else if (isPreventingDefault) {
			isPreventingDefault = false;
		  }
  
		  if (self.autoScroll) {
			checkAutoScrollBounds = true;
		  }
  
		  setPointerPosition(e.pageX, e.pageY, hasMoveCallback);
		},
			setPointerPosition = function setPointerPosition(pointerX, pointerY, invokeOnMove) {
		  var dragTolerance = 1 - self.dragResistance,
			  edgeTolerance = 1 - self.edgeResistance,
			  prevPointerX = self.pointerX,
			  prevPointerY = self.pointerY,
			  prevStartElementY = startElementY,
			  prevX = self.x,
			  prevY = self.y,
			  prevEndX = self.endX,
			  prevEndY = self.endY,
			  prevEndRotation = self.endRotation,
			  prevDirty = dirty,
			  xChange,
			  yChange,
			  x,
			  y,
			  dif,
			  temp;
		  self.pointerX = pointerX;
		  self.pointerY = pointerY;
  
		  if (isFixed) {
			pointerX -= _getDocScrollLeft$1(ownerDoc);
			pointerY -= _getDocScrollTop$1(ownerDoc);
		  }
  
		  if (rotationMode) {
			y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
			dif = self.y - y;
  
			if (dif > 180) {
			  startElementY -= 360;
			  self.y = y;
			} else if (dif < -180) {
			  startElementY += 360;
			  self.y = y;
			}
  
			if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
			  self.y = y;
			  x = startElementX + (startElementY - y) * dragTolerance;
			} else {
			  x = startElementX;
			}
		  } else {
			if (matrix) {
			  temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;
			  pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;
			  pointerX = temp;
			}
  
			yChange = pointerY - startPointerY;
			xChange = pointerX - startPointerX;
  
			if (yChange < minimumMovement && yChange > -minimumMovement) {
			  yChange = 0;
			}
  
			if (xChange < minimumMovement && xChange > -minimumMovement) {
			  xChange = 0;
			}
  
			if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
			  temp = self.lockedAxis;
  
			  if (!temp) {
				self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;
  
				if (temp && _isFunction(self.vars.onLockAxis)) {
				  self.vars.onLockAxis.call(self, self.pointerEvent);
				}
			  }
  
			  if (temp === "y") {
				yChange = 0;
			  } else if (temp === "x") {
				xChange = 0;
			  }
			}
  
			x = _round(startElementX + xChange * dragTolerance);
			y = _round(startElementY + yChange * dragTolerance);
		  }
  
		  if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {
			if (snapXY) {
			  _temp1.x = x;
			  _temp1.y = y;
			  temp = snapXY(_temp1);
			  x = _round(temp.x);
			  y = _round(temp.y);
			}
  
			if (snapX) {
			  x = _round(snapX(x));
			}
  
			if (snapY) {
			  y = _round(snapY(y));
			}
		  }
  
		  if (hasBounds) {
			if (x > maxX) {
			  x = maxX + Math.round((x - maxX) * edgeTolerance);
			} else if (x < minX) {
			  x = minX + Math.round((x - minX) * edgeTolerance);
			}
  
			if (!rotationMode) {
			  if (y > maxY) {
				y = Math.round(maxY + (y - maxY) * edgeTolerance);
			  } else if (y < minY) {
				y = Math.round(minY + (y - minY) * edgeTolerance);
			  }
			}
		  }
  
		  if (self.x !== x || self.y !== y && !rotationMode) {
			if (rotationMode) {
			  self.endRotation = self.x = self.endX = x;
			  dirty = true;
			} else {
			  if (allowY) {
				self.y = self.endY = y;
				dirty = true;
			  }
  
			  if (allowX) {
				self.x = self.endX = x;
				dirty = true;
			  }
			}
  
			if (!invokeOnMove || _dispatchEvent(self, "move", "onMove") !== false) {
			  if (!self.isDragging && self.isPressed) {
				self.isDragging = true;
  
				_dispatchEvent(self, "dragstart", "onDragStart");
			  }
			} else {
			  self.pointerX = prevPointerX;
			  self.pointerY = prevPointerY;
			  startElementY = prevStartElementY;
			  self.x = prevX;
			  self.y = prevY;
			  self.endX = prevEndX;
			  self.endY = prevEndY;
			  self.endRotation = prevEndRotation;
			  dirty = prevDirty;
			}
		  }
		},
			onRelease = function onRelease(e, force) {
		  if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {
			isPreventingDefault && e && enabled && _preventDefault(e);
			return;
		  }
  
		  self.isPressed = false;
		  var originalEvent = e,
			  wasDragging = self.isDragging,
			  isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),
			  placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder),
			  touches,
			  i,
			  syntheticEvent,
			  eventTarget,
			  syntheticClick;
  
		  if (touchEventTarget) {
			_removeListener(touchEventTarget, "touchend", onRelease);
  
			_removeListener(touchEventTarget, "touchmove", onMove);
  
			_removeListener(touchEventTarget, "touchcancel", onRelease);
  
			_removeListener(ownerDoc, "touchstart", _onMultiTouchDocument);
		  } else {
			_removeListener(ownerDoc, "mousemove", onMove);
		  }
  
		  _removeListener(_win$1, "touchforcechange", _preventDefault);
  
		  if (!_supportsPointer || !touchEventTarget) {
			_removeListener(ownerDoc, "mouseup", onRelease);
  
			e && e.target && _removeListener(e.target, "mouseup", onRelease);
		  }
  
		  dirty = false;
  
		  if (wasDragging) {
			dragEndTime = _lastDragTime = _getTime();
			self.isDragging = false;
		  }
  
		  if (isClicking && !isContextMenuRelease) {
			if (e) {
			  _removeListener(e.target, "change", onRelease);
  
			  self.pointerEvent = originalEvent;
			}
  
			_setSelectable(triggers, false);
  
			_dispatchEvent(self, "release", "onRelease");
  
			_dispatchEvent(self, "click", "onClick");
  
			isClicking = false;
			return;
		  }
  
		  _removeFromRenderQueue(render);
  
		  i = triggers.length;
  
		  while (--i > -1) {
			_setStyle(triggers[i], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));
		  }
  
		  _dragCount--;
  
		  if (e) {
			touches = e.changedTouches;
  
			if (touches) {
			  e = touches[0];
  
			  if (e !== touch && e.identifier !== touchID) {
				i = touches.length;
  
				while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}
  
				if (i < 0) {
				  return;
				}
			  }
			}
  
			self.pointerEvent = originalEvent;
			self.pointerX = e.pageX;
			self.pointerY = e.pageY;
		  }
  
		  if (isContextMenuRelease && originalEvent) {
			_preventDefault(originalEvent);
  
			isPreventingDefault = true;
  
			_dispatchEvent(self, "release", "onRelease");
		  } else if (originalEvent && !wasDragging) {
			isPreventingDefault = false;
  
			if (interrupted && (vars.snap || vars.bounds)) {
			  animate(vars.inertia || vars.throwProps);
			}
  
			_dispatchEvent(self, "release", "onRelease");
  
			if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {
			  _dispatchEvent(self, "click", "onClick");
  
			  if (_getTime() - clickTime < 300) {
				_dispatchEvent(self, "doubleclick", "onDoubleClick");
			  }
  
			  eventTarget = originalEvent.target || target;
			  clickTime = _getTime();
  
			  syntheticClick = function syntheticClick() {
				if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {
				  if (eventTarget.click) {
					eventTarget.click();
				  } else if (ownerDoc.createEvent) {
					syntheticEvent = ownerDoc.createEvent("MouseEvents");
					syntheticEvent.initMouseEvent("click", true, true, _win$1, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
					eventTarget.dispatchEvent(syntheticEvent);
				  }
				}
			  };
  
			  if (!_isAndroid && !originalEvent.defaultPrevented) {
				gsap.delayedCall(0.05, syntheticClick);
			  }
			}
		  } else {
			animate(vars.inertia || vars.throwProps);
  
			if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {
			  isPreventingDefault = true;
  
			  _preventDefault(originalEvent);
			} else {
			  isPreventingDefault = false;
			}
  
			_dispatchEvent(self, "release", "onRelease");
		  }
  
		  isTweening() && placeholderDelayedCall.duration(self.tween.duration());
		  wasDragging && _dispatchEvent(self, "dragend", "onDragEnd");
		  return true;
		},
			updateScroll = function updateScroll(e) {
		  if (e && self.isDragging && !scrollProxy) {
			var parent = e.target || target.parentNode,
				deltaX = parent.scrollLeft - parent._gsScrollX,
				deltaY = parent.scrollTop - parent._gsScrollY;
  
			if (deltaX || deltaY) {
			  if (matrix) {
				startPointerX -= deltaX * matrix.a + deltaY * matrix.c;
				startPointerY -= deltaY * matrix.d + deltaX * matrix.b;
			  } else {
				startPointerX -= deltaX;
				startPointerY -= deltaY;
			  }
  
			  parent._gsScrollX += deltaX;
			  parent._gsScrollY += deltaY;
			  setPointerPosition(self.pointerX, self.pointerY);
			}
		  }
		},
			onClick = function onClick(e) {
		  var time = _getTime(),
			  recentlyClicked = time - clickTime < 100,
			  recentlyDragged = time - dragEndTime < 50,
			  alreadyDispatched = recentlyClicked && clickDispatch === clickTime,
			  defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,
			  alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,
			  trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched;
  
		  if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {
			e.stopImmediatePropagation();
		  }
  
		  if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {
			if (trusted && alreadyDispatched) {
			  trustedClickDispatch = clickTime;
			}
  
			clickDispatch = clickTime;
			return;
		  }
  
		  if (self.isPressed || recentlyDragged || recentlyClicked) {
			if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
			  _preventDefault(e);
			}
		  }
  
		  if (!recentlyClicked && !recentlyDragged) {
			e && e.target && (self.pointerEvent = e);
  
			_dispatchEvent(self, "click", "onClick");
		  }
		},
			localizePoint = function localizePoint(p) {
		  return matrix ? {
			x: p.x * matrix.a + p.y * matrix.c + matrix.e,
			y: p.x * matrix.b + p.y * matrix.d + matrix.f
		  } : {
			x: p.x,
			y: p.y
		  };
		};
  
		old = Draggable.get(target);
		old && old.kill();
  
		_this2.startDrag = function (event, align) {
		  var r1, r2, p1, p2;
		  onPress(event || self.pointerEvent, true);
  
		  if (align && !self.hitTest(event || self.pointerEvent)) {
			r1 = _parseRect(event || self.pointerEvent);
			r2 = _parseRect(target);
			p1 = localizePoint({
			  x: r1.left + r1.width / 2,
			  y: r1.top + r1.height / 2
			});
			p2 = localizePoint({
			  x: r2.left + r2.width / 2,
			  y: r2.top + r2.height / 2
			});
			startPointerX -= p1.x - p2.x;
			startPointerY -= p1.y - p2.y;
		  }
  
		  if (!self.isDragging) {
			self.isDragging = true;
  
			_dispatchEvent(self, "dragstart", "onDragStart");
		  }
		};
  
		_this2.drag = onMove;
  
		_this2.endDrag = function (e) {
		  return onRelease(e || self.pointerEvent, true);
		};
  
		_this2.timeSinceDrag = function () {
		  return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
		};
  
		_this2.timeSinceClick = function () {
		  return (_getTime() - clickTime) / 1000;
		};
  
		_this2.hitTest = function (target, threshold) {
		  return Draggable.hitTest(self.target, target, threshold);
		};
  
		_this2.getDirection = function (from, diagonalThreshold) {
		  var mode = from === "velocity" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? "element" : "start",
			  xChange,
			  yChange,
			  ratio,
			  direction,
			  r1,
			  r2;
  
		  if (mode === "element") {
			r1 = _parseRect(self.target);
			r2 = _parseRect(from);
		  }
  
		  xChange = mode === "start" ? self.x - startElementX : mode === "velocity" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);
  
		  if (rotationMode) {
			return xChange < 0 ? "counter-clockwise" : "clockwise";
		  } else {
			diagonalThreshold = diagonalThreshold || 2;
			yChange = mode === "start" ? self.y - startElementY : mode === "velocity" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);
			ratio = Math.abs(xChange / yChange);
			direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";
  
			if (ratio < diagonalThreshold) {
			  if (direction !== "") {
				direction += "-";
			  }
  
			  direction += yChange < 0 ? "up" : "down";
			}
		  }
  
		  return direction;
		};
  
		_this2.applyBounds = function (newBounds, sticky) {
		  var x, y, forceZeroVelocity, e, parent, isRoot;
  
		  if (newBounds && vars.bounds !== newBounds) {
			vars.bounds = newBounds;
			return self.update(true, sticky);
		  }
  
		  syncXY(true);
		  calculateBounds();
  
		  if (hasBounds && !isTweening()) {
			x = self.x;
			y = self.y;
  
			if (x > maxX) {
			  x = maxX;
			} else if (x < minX) {
			  x = minX;
			}
  
			if (y > maxY) {
			  y = maxY;
			} else if (y < minY) {
			  y = minY;
			}
  
			if (self.x !== x || self.y !== y) {
			  forceZeroVelocity = true;
			  self.x = self.endX = x;
  
			  if (rotationMode) {
				self.endRotation = x;
			  } else {
				self.y = self.endY = y;
			  }
  
			  dirty = true;
			  render(true);
  
			  if (self.autoScroll && !self.isDragging) {
				_recordMaxScrolls(target.parentNode);
  
				e = target;
				_windowProxy.scrollTop = _win$1.pageYOffset != null ? _win$1.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
				_windowProxy.scrollLeft = _win$1.pageXOffset != null ? _win$1.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
  
				while (e && !isRoot) {
				  isRoot = _isRoot(e.parentNode);
				  parent = isRoot ? _windowProxy : e.parentNode;
  
				  if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
					parent.scrollTop = parent._gsMaxScrollY;
				  }
  
				  if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
					parent.scrollLeft = parent._gsMaxScrollX;
				  }
  
				  e = parent;
				}
			  }
			}
  
			if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
			  animate(vars.inertia || vars.throwProps, forceZeroVelocity);
			}
		  }
  
		  return self;
		};
  
		_this2.update = function (applyBounds, sticky, ignoreExternalChanges) {
		  if (sticky && self.isPressed) {
			var m = getGlobalMatrix(target),
				p = innerMatrix.apply({
			  x: self.x - startElementX,
			  y: self.y - startElementY
			}),
				m2 = getGlobalMatrix(target.parentNode, true);
			m2.apply({
			  x: m.e - p.x,
			  y: m.f - p.y
			}, p);
			self.x -= p.x - m2.e;
			self.y -= p.y - m2.f;
			render(true);
			recordStartPositions();
		  }
  
		  var x = self.x,
			  y = self.y;
		  updateMatrix(!sticky);
  
		  if (applyBounds) {
			self.applyBounds();
		  } else {
			dirty && ignoreExternalChanges && render(true);
			syncXY(true);
		  }
  
		  if (sticky) {
			setPointerPosition(self.pointerX, self.pointerY);
			dirty && render(true);
		  }
  
		  if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {
			recordStartPositions();
		  }
  
		  if (self.autoScroll) {
			_recordMaxScrolls(target.parentNode, self.isDragging);
  
			checkAutoScrollBounds = self.isDragging;
			render(true);
  
			_removeScrollListener(target, updateScroll);
  
			_addScrollListener(target, updateScroll);
		  }
  
		  return self;
		};
  
		_this2.enable = function (type) {
		  var setVars = {
			lazy: true
		  },
			  id,
			  i,
			  trigger;
  
		  if (vars.cursor !== false) {
			setVars.cursor = vars.cursor || _defaultCursor;
		  }
  
		  if (gsap.utils.checkPrefix("touchCallout")) {
			setVars.touchCallout = "none";
		  }
  
		  if (type !== "soft") {
			_setTouchActionForAllDescendants(triggers, allowX === allowY ? "none" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x");
  
			i = triggers.length;
  
			while (--i > -1) {
			  trigger = triggers[i];
			  _supportsPointer || _addListener(trigger, "mousedown", onPress);
  
			  _addListener(trigger, "touchstart", onPress);
  
			  _addListener(trigger, "click", onClick, true);
  
			  gsap.set(trigger, setVars);
  
			  if (trigger.getBBox && trigger.ownerSVGElement) {
				gsap.set(trigger.ownerSVGElement, {
				  touchAction: allowX === allowY ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"
				});
			  }
  
			  vars.allowContextMenu || _addListener(trigger, "contextmenu", onContextMenu);
			}
  
			_setSelectable(triggers, false);
		  }
  
		  _addScrollListener(target, updateScroll);
  
		  enabled = true;
  
		  if (InertiaPlugin && type !== "soft") {
			InertiaPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
		  }
  
		  target._gsDragID = id = "d" + _lookupCount++;
		  _lookup[id] = self;
  
		  if (scrollProxy) {
			scrollProxy.enable();
			scrollProxy.element._gsDragID = id;
		  }
  
		  (vars.bounds || rotationMode) && recordStartPositions();
		  vars.bounds && self.applyBounds();
		  return self;
		};
  
		_this2.disable = function (type) {
		  var dragging = self.isDragging,
			  i = triggers.length,
			  trigger;
  
		  while (--i > -1) {
			_setStyle(triggers[i], "cursor", null);
		  }
  
		  if (type !== "soft") {
			_setTouchActionForAllDescendants(triggers, null);
  
			i = triggers.length;
  
			while (--i > -1) {
			  trigger = triggers[i];
  
			  _setStyle(trigger, "touchCallout", null);
  
			  _removeListener(trigger, "mousedown", onPress);
  
			  _removeListener(trigger, "touchstart", onPress);
  
			  _removeListener(trigger, "click", onClick);
  
			  _removeListener(trigger, "contextmenu", onContextMenu);
			}
  
			_setSelectable(triggers, true);
  
			if (touchEventTarget) {
			  _removeListener(touchEventTarget, "touchcancel", onRelease);
  
			  _removeListener(touchEventTarget, "touchend", onRelease);
  
			  _removeListener(touchEventTarget, "touchmove", onMove);
			}
  
			_removeListener(ownerDoc, "mouseup", onRelease);
  
			_removeListener(ownerDoc, "mousemove", onMove);
		  }
  
		  _removeScrollListener(target, updateScroll);
  
		  enabled = false;
		  InertiaPlugin && type !== "soft" && InertiaPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
		  scrollProxy && scrollProxy.disable();
  
		  _removeFromRenderQueue(render);
  
		  self.isDragging = self.isPressed = isClicking = false;
		  dragging && _dispatchEvent(self, "dragend", "onDragEnd");
		  return self;
		};
  
		_this2.enabled = function (value, type) {
		  return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;
		};
  
		_this2.kill = function () {
		  self.isThrowing = false;
		  self.tween && self.tween.kill();
		  self.disable();
		  gsap.set(triggers, {
			clearProps: "userSelect"
		  });
		  delete _lookup[target._gsDragID];
		  return self;
		};
  
		if (~type.indexOf("scroll")) {
		  scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({
			onKill: function onKill() {
			  self.isPressed && onRelease(null);
			}
		  }, vars));
		  target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";
		  target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";
		  target = scrollProxy.content;
		}
  
		if (rotationMode) {
		  killProps.rotation = 1;
		} else {
		  if (allowX) {
			killProps[xProp] = 1;
		  }
  
		  if (allowY) {
			killProps[yProp] = 1;
		  }
		}
  
		gsCache.force3D = "force3D" in vars ? vars.force3D : true;
  
		_this2.enable();
  
		return _this2;
	  }
  
	  Draggable.register = function register(core) {
		gsap = core;
  
		_initCore();
	  };
  
	  Draggable.create = function create(targets, vars) {
		_coreInitted || _initCore(true);
		return _toArray(targets).map(function (target) {
		  return new Draggable(target, vars);
		});
	  };
  
	  Draggable.get = function get(target) {
		return _lookup[(_toArray(target)[0] || {})._gsDragID];
	  };
  
	  Draggable.timeSinceDrag = function timeSinceDrag() {
		return (_getTime() - _lastDragTime) / 1000;
	  };
  
	  Draggable.hitTest = function hitTest(obj1, obj2, threshold) {
		if (obj1 === obj2) {
		  return false;
		}
  
		var r1 = _parseRect(obj1),
			r2 = _parseRect(obj2),
			top = r1.top,
			left = r1.left,
			right = r1.right,
			bottom = r1.bottom,
			width = r1.width,
			height = r1.height,
			isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top,
			overlap,
			area,
			isRatio;
  
		if (isOutside || !threshold) {
		  return !isOutside;
		}
  
		isRatio = (threshold + "").indexOf("%") !== -1;
		threshold = parseFloat(threshold) || 0;
		overlap = {
		  left: Math.max(left, r2.left),
		  top: Math.max(top, r2.top)
		};
		overlap.width = Math.min(right, r2.right) - overlap.left;
		overlap.height = Math.min(bottom, r2.bottom) - overlap.top;
  
		if (overlap.width < 0 || overlap.height < 0) {
		  return false;
		}
  
		if (isRatio) {
		  threshold *= 0.01;
		  area = overlap.width * overlap.height;
		  return area >= width * height * threshold || area >= r2.width * r2.height * threshold;
		}
  
		return overlap.width > threshold && overlap.height > threshold;
	  };
  
	  return Draggable;
	}(EventDispatcher);
  
	_setDefaults(Draggable.prototype, {
	  pointerX: 0,
	  pointerY: 0,
	  startX: 0,
	  startY: 0,
	  deltaX: 0,
	  deltaY: 0,
	  isDragging: false,
	  isPressed: false
	});
  
	Draggable.zIndex = 1000;
	Draggable.version = "3.10.4";
	_getGSAP() && gsap.registerPlugin(Draggable);
  
	exports.Draggable = Draggable;
	exports.default = Draggable;
  
	if (typeof(window) === 'undefined' || window !== exports) {Object.defineProperty(exports, '__esModule', { value: true });} else {delete window.default;}
  
  })));
/*!
 * Flickity PACKAGED v2.2.2
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */

/**
 * Bridget makes jQuery widgets
 * v2.0.1
 * MIT license
 */

/* jshint browser: true, strict: true, undef: true, unused: true */

( function( window, factory ) {
  // universal module definition
  /*jshint strict: false */ /* globals define, module, require */
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'jquery-bridget/jquery-bridget',[ 'jquery' ], function( jQuery ) {
      return factory( window, jQuery );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('jquery')
    );
  } else {
    // browser global
    window.jQueryBridget = factory(
      window,
      window.jQuery
    );
  }

}( window, function factory( window, jQuery ) {
'use strict';

// ----- utils ----- //

var arraySlice = Array.prototype.slice;

// helper function for logging errors
// $.error breaks jQuery chaining
var console = window.console;
var logError = typeof console == 'undefined' ? function() {} :
  function( message ) {
    console.error( message );
  };

// ----- jQueryBridget ----- //

function jQueryBridget( namespace, PluginClass, $ ) {
  $ = $ || jQuery || window.jQuery;
  if ( !$ ) {
    return;
  }

  // add option method -> $().plugin('option', {...})
  if ( !PluginClass.prototype.option ) {
    // option setter
    PluginClass.prototype.option = function( opts ) {
      // bail out if not an object
      if ( !$.isPlainObject( opts ) ){
        return;
      }
      this.options = $.extend( true, this.options, opts );
    };
  }

  // make jQuery plugin
  $.fn[ namespace ] = function( arg0 /*, arg1 */ ) {
    if ( typeof arg0 == 'string' ) {
      // method call $().plugin( 'methodName', { options } )
      // shift arguments by 1
      var args = arraySlice.call( arguments, 1 );
      return methodCall( this, arg0, args );
    }
    // just $().plugin({ options })
    plainCall( this, arg0 );
    return this;
  };

  // $().plugin('methodName')
  function methodCall( $elems, methodName, args ) {
    var returnValue;
    var pluginMethodStr = '$().' + namespace + '("' + methodName + '")';

    $elems.each( function( i, elem ) {
      // get instance
      var instance = $.data( elem, namespace );
      if ( !instance ) {
        logError( namespace + ' not initialized. Cannot call methods, i.e. ' +
          pluginMethodStr );
        return;
      }

      var method = instance[ methodName ];
      if ( !method || methodName.charAt(0) == '_' ) {
        logError( pluginMethodStr + ' is not a valid method' );
        return;
      }

      // apply method, get return value
      var value = method.apply( instance, args );
      // set return value if value is returned, use only first value
      returnValue = returnValue === undefined ? value : returnValue;
    });

    return returnValue !== undefined ? returnValue : $elems;
  }

  function plainCall( $elems, options ) {
    $elems.each( function( i, elem ) {
      var instance = $.data( elem, namespace );
      if ( instance ) {
        // set options & init
        instance.option( options );
        instance._init();
      } else {
        // initialize new instance
        instance = new PluginClass( elem, options );
        $.data( elem, namespace, instance );
      }
    });
  }

  updateJQuery( $ );

}

// ----- updateJQuery ----- //

// set $.bridget for v1 backwards compatibility
function updateJQuery( $ ) {
  if ( !$ || ( $ && $.bridget ) ) {
    return;
  }
  $.bridget = jQueryBridget;
}

updateJQuery( jQuery || window.jQuery );

// -----  ----- //

return jQueryBridget;

}));

/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

( function( global, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if ( typeof define == 'function' && define.amd ) {
    // AMD - RequireJS
    define( 'ev-emitter/ev-emitter',factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }

}( typeof window != 'undefined' ? window : this, function() {



function EvEmitter() {}

var proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // set events hash
  var events = this._events = this._events || {};
  // set listeners array
  var listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( listeners.indexOf( listener ) == -1 ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  var onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  var index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  // copy over to avoid interference if .off() in listener
  listeners = listeners.slice(0);
  args = args || [];
  // once stuff
  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  for ( var i=0; i < listeners.length; i++ ) {
    var listener = listeners[i]
    var isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
  }

  return this;
};

proto.allOff = function() {
  delete this._events;
  delete this._onceEvents;
};

return EvEmitter;

}));

/*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */

/* jshint browser: true, strict: true, undef: true, unused: true */
/* globals console: false */

( function( window, factory ) {
  /* jshint strict: false */ /* globals define, module */
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'get-size/get-size',factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.getSize = factory();
  }

})( window, function factory() {
'use strict';

// -------------------------- helpers -------------------------- //

// get a number from a string, not a percentage
function getStyleSize( value ) {
  var num = parseFloat( value );
  // not a percent like '100%', and a number
  var isValid = value.indexOf('%') == -1 && !isNaN( num );
  return isValid && num;
}

function noop() {}

var logError = typeof console == 'undefined' ? noop :
  function( message ) {
    console.error( message );
  };

// -------------------------- measurements -------------------------- //

var measurements = [
  'paddingLeft',
  'paddingRight',
  'paddingTop',
  'paddingBottom',
  'marginLeft',
  'marginRight',
  'marginTop',
  'marginBottom',
  'borderLeftWidth',
  'borderRightWidth',
  'borderTopWidth',
  'borderBottomWidth'
];

var measurementsLength = measurements.length;

function getZeroSize() {
  var size = {
    width: 0,
    height: 0,
    innerWidth: 0,
    innerHeight: 0,
    outerWidth: 0,
    outerHeight: 0
  };
  for ( var i=0; i < measurementsLength; i++ ) {
    var measurement = measurements[i];
    size[ measurement ] = 0;
  }
  return size;
}

// -------------------------- getStyle -------------------------- //

/**
 * getStyle, get style of element, check for Firefox bug
 * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 */
function getStyle( elem ) {
  var style = getComputedStyle( elem );
  if ( !style ) {
    logError( 'Style returned ' + style +
      '. Are you running this code in a hidden iframe on Firefox? ' +
      'See https://bit.ly/getsizebug1' );
  }
  return style;
}

// -------------------------- setup -------------------------- //

var isSetup = false;

var isBoxSizeOuter;

/**
 * setup
 * check isBoxSizerOuter
 * do on first getSize() rather than on page load for Firefox bug
 */
function setup() {
  // setup once
  if ( isSetup ) {
    return;
  }
  isSetup = true;

  // -------------------------- box sizing -------------------------- //

  /**
   * Chrome & Safari measure the outer-width on style.width on border-box elems
   * IE11 & Firefox<29 measures the inner-width
   */
  var div = document.createElement('div');
  div.style.width = '200px';
  div.style.padding = '1px 2px 3px 4px';
  div.style.borderStyle = 'solid';
  div.style.borderWidth = '1px 2px 3px 4px';
  div.style.boxSizing = 'border-box';

  var body = document.body || document.documentElement;
  body.appendChild( div );
  var style = getStyle( div );
  // round value for browser zoom. desandro/masonry#928
  isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;
  getSize.isBoxSizeOuter = isBoxSizeOuter;

  body.removeChild( div );
}

// -------------------------- getSize -------------------------- //

function getSize( elem ) {
  setup();

  // use querySeletor if elem is string
  if ( typeof elem == 'string' ) {
    elem = document.querySelector( elem );
  }

  // do not proceed on non-objects
  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
    return;
  }

  var style = getStyle( elem );

  // if hidden, everything is 0
  if ( style.display == 'none' ) {
    return getZeroSize();
  }

  var size = {};
  size.width = elem.offsetWidth;
  size.height = elem.offsetHeight;

  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

  // get all measurements
  for ( var i=0; i < measurementsLength; i++ ) {
    var measurement = measurements[i];
    var value = style[ measurement ];
    var num = parseFloat( value );
    // any 'auto', 'medium' value will be 0
    size[ measurement ] = !isNaN( num ) ? num : 0;
  }

  var paddingWidth = size.paddingLeft + size.paddingRight;
  var paddingHeight = size.paddingTop + size.paddingBottom;
  var marginWidth = size.marginLeft + size.marginRight;
  var marginHeight = size.marginTop + size.marginBottom;
  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
  var borderHeight = size.borderTopWidth + size.borderBottomWidth;

  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

  // overwrite width and height if we can get it from style
  var styleWidth = getStyleSize( style.width );
  if ( styleWidth !== false ) {
    size.width = styleWidth +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
  }

  var styleHeight = getStyleSize( style.height );
  if ( styleHeight !== false ) {
    size.height = styleHeight +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
  }

  size.innerWidth = size.width - ( paddingWidth + borderWidth );
  size.innerHeight = size.height - ( paddingHeight + borderHeight );

  size.outerWidth = size.width + marginWidth;
  size.outerHeight = size.height + marginHeight;

  return size;
}

return getSize;

});

/**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

( function( window, factory ) {
  /*global define: false, module: false */
  'use strict';
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'desandro-matches-selector/matches-selector',factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.matchesSelector = factory();
  }

}( window, function factory() {
  'use strict';

  var matchesMethod = ( function() {
    var ElemProto = window.Element.prototype;
    // check for the standard method name first
    if ( ElemProto.matches ) {
      return 'matches';
    }
    // check un-prefixed
    if ( ElemProto.matchesSelector ) {
      return 'matchesSelector';
    }
    // check vendor prefixes
    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];

    for ( var i=0; i < prefixes.length; i++ ) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';
      if ( ElemProto[ method ] ) {
        return method;
      }
    }
  })();

  return function matchesSelector( elem, selector ) {
    return elem[ matchesMethod ]( selector );
  };

}));

/**
 * Fizzy UI utils v2.0.7
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

( function( window, factory ) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'fizzy-ui-utils/utils',[
      'desandro-matches-selector/matches-selector'
    ], function( matchesSelector ) {
      return factory( window, matchesSelector );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('desandro-matches-selector')
    );
  } else {
    // browser global
    window.fizzyUIUtils = factory(
      window,
      window.matchesSelector
    );
  }

}( window, function factory( window, matchesSelector ) {



var utils = {};

// ----- extend ----- //

// extends objects
utils.extend = function( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
};

// ----- modulo ----- //

utils.modulo = function( num, div ) {
  return ( ( num % div ) + div ) % div;
};

// ----- makeArray ----- //

var arraySlice = Array.prototype.slice;

// turn element or nodeList into an array
utils.makeArray = function( obj ) {
  if ( Array.isArray( obj ) ) {
    // use object if already an array
    return obj;
  }
  // return empty array if undefined or null. #6
  if ( obj === null || obj === undefined ) {
    return [];
  }

  var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
  if ( isArrayLike ) {
    // convert nodeList to array
    return arraySlice.call( obj );
  }

  // array of single index
  return [ obj ];
};

// ----- removeFrom ----- //

utils.removeFrom = function( ary, obj ) {
  var index = ary.indexOf( obj );
  if ( index != -1 ) {
    ary.splice( index, 1 );
  }
};

// ----- getParent ----- //

utils.getParent = function( elem, selector ) {
  while ( elem.parentNode && elem != document.body ) {
    elem = elem.parentNode;
    if ( matchesSelector( elem, selector ) ) {
      return elem;
    }
  }
};

// ----- getQueryElement ----- //

// use element as selector string
utils.getQueryElement = function( elem ) {
  if ( typeof elem == 'string' ) {
    return document.querySelector( elem );
  }
  return elem;
};

// ----- handleEvent ----- //

// enable .ontype to trigger from .addEventListener( elem, 'type' )
utils.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

// ----- filterFindElements ----- //

utils.filterFindElements = function( elems, selector ) {
  // make array of elems
  elems = utils.makeArray( elems );
  var ffElems = [];

  elems.forEach( function( elem ) {
    // check that elem is an actual element
    if ( !( elem instanceof HTMLElement ) ) {
      return;
    }
    // add elem if no selector
    if ( !selector ) {
      ffElems.push( elem );
      return;
    }
    // filter & find items if we have a selector
    // filter
    if ( matchesSelector( elem, selector ) ) {
      ffElems.push( elem );
    }
    // find children
    var childElems = elem.querySelectorAll( selector );
    // concat childElems to filterFound array
    for ( var i=0; i < childElems.length; i++ ) {
      ffElems.push( childElems[i] );
    }
  });

  return ffElems;
};

// ----- debounceMethod ----- //

utils.debounceMethod = function( _class, methodName, threshold ) {
  threshold = threshold || 100;
  // original method
  var method = _class.prototype[ methodName ];
  var timeoutName = methodName + 'Timeout';

  _class.prototype[ methodName ] = function() {
    var timeout = this[ timeoutName ];
    clearTimeout( timeout );

    var args = arguments;
    var _this = this;
    this[ timeoutName ] = setTimeout( function() {
      method.apply( _this, args );
      delete _this[ timeoutName ];
    }, threshold );
  };
};

// ----- docReady ----- //

utils.docReady = function( callback ) {
  var readyState = document.readyState;
  if ( readyState == 'complete' || readyState == 'interactive' ) {
    // do async to allow for other scripts to run. metafizzy/flickity#441
    setTimeout( callback );
  } else {
    document.addEventListener( 'DOMContentLoaded', callback );
  }
};

// ----- htmlInit ----- //

// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
utils.toDashed = function( str ) {
  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
    return $1 + '-' + $2;
  }).toLowerCase();
};

var console = window.console;
/**
 * allow user to initialize classes via [data-namespace] or .js-namespace class
 * htmlInit( Widget, 'widgetName' )
 * options are parsed from data-namespace-options
 */
utils.htmlInit = function( WidgetClass, namespace ) {
  utils.docReady( function() {
    var dashedNamespace = utils.toDashed( namespace );
    var dataAttr = 'data-' + dashedNamespace;
    var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
    var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
    var elems = utils.makeArray( dataAttrElems )
      .concat( utils.makeArray( jsDashElems ) );
    var dataOptionsAttr = dataAttr + '-options';
    var jQuery = window.jQuery;

    elems.forEach( function( elem ) {
      var attr = elem.getAttribute( dataAttr ) ||
        elem.getAttribute( dataOptionsAttr );
      var options;
      try {
        options = attr && JSON.parse( attr );
      } catch ( error ) {
        // log error, do not initialize
        if ( console ) {
          console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
          ': ' + error );
        }
        return;
      }
      // initialize
      var instance = new WidgetClass( elem, options );
      // make available via $().data('namespace')
      if ( jQuery ) {
        jQuery.data( elem, namespace, instance );
      }
    });

  });
};

// -----  ----- //

return utils;

}));

// Flickity.Cell
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/cell',[
      'get-size/get-size',
    ], function( getSize ) {
      return factory( window, getSize );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('get-size')
    );
  } else {
    // browser global
    window.Flickity = window.Flickity || {};
    window.Flickity.Cell = factory(
        window,
        window.getSize
    );
  }

}( window, function factory( window, getSize ) {



function Cell( elem, parent ) {
  this.element = elem;
  this.parent = parent;

  this.create();
}

var proto = Cell.prototype;

proto.create = function() {
  this.element.style.position = 'absolute';
  this.element.setAttribute( 'aria-hidden', 'true' );
  this.x = 0;
  this.shift = 0;
};

proto.destroy = function() {
  // reset style
  this.unselect();
  this.element.style.position = '';
  var side = this.parent.originSide;
  this.element.style[ side ] = '';
  this.element.removeAttribute('aria-hidden');
};

proto.getSize = function() {
  this.size = getSize( this.element );
};

proto.setPosition = function( x ) {
  this.x = x;
  this.updateTarget();
  this.renderPosition( x );
};

// setDefaultTarget v1 method, backwards compatibility, remove in v3
proto.updateTarget = proto.setDefaultTarget = function() {
  var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';
  this.target = this.x + this.size[ marginProperty ] +
    this.size.width * this.parent.cellAlign;
};

proto.renderPosition = function( x ) {
  // render position of cell with in slider
  var side = this.parent.originSide;
  this.element.style[ side ] = this.parent.getPositionValue( x );
};

proto.select = function() {
  this.element.classList.add('is-selected');
  this.element.removeAttribute('aria-hidden');
};

proto.unselect = function() {
  this.element.classList.remove('is-selected');
  this.element.setAttribute( 'aria-hidden', 'true' );
};

/**
 * @param {Integer} shift - 0, 1, or -1
 */
proto.wrapShift = function( shift ) {
  this.shift = shift;
  this.renderPosition( this.x + this.parent.slideableWidth * shift );
};

proto.remove = function() {
  this.element.parentNode.removeChild( this.element );
};

return Cell;

} ) );

// slide
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/slide',factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.Flickity = window.Flickity || {};
    window.Flickity.Slide = factory();
  }

}( window, function factory() {
'use strict';

function Slide( parent ) {
  this.parent = parent;
  this.isOriginLeft = parent.originSide == 'left';
  this.cells = [];
  this.outerWidth = 0;
  this.height = 0;
}

var proto = Slide.prototype;

proto.addCell = function( cell ) {
  this.cells.push( cell );
  this.outerWidth += cell.size.outerWidth;
  this.height = Math.max( cell.size.outerHeight, this.height );
  // first cell stuff
  if ( this.cells.length == 1 ) {
    this.x = cell.x; // x comes from first cell
    var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';
    this.firstMargin = cell.size[ beginMargin ];
  }
};

proto.updateTarget = function() {
  var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';
  var lastCell = this.getLastCell();
  var lastMargin = lastCell ? lastCell.size[ endMargin ] : 0;
  var slideWidth = this.outerWidth - ( this.firstMargin + lastMargin );
  this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;
};

proto.getLastCell = function() {
  return this.cells[ this.cells.length - 1 ];
};

proto.select = function() {
  this.cells.forEach( function( cell ) {
    cell.select();
  } );
};

proto.unselect = function() {
  this.cells.forEach( function( cell ) {
    cell.unselect();
  } );
};

proto.getCellElements = function() {
  return this.cells.map( function( cell ) {
    return cell.element;
  } );
};

return Slide;

} ) );

// animate
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/animate',[
      'fizzy-ui-utils/utils',
    ], function( utils ) {
      return factory( window, utils );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('fizzy-ui-utils')
    );
  } else {
    // browser global
    window.Flickity = window.Flickity || {};
    window.Flickity.animatePrototype = factory(
        window,
        window.fizzyUIUtils
    );
  }

}( window, function factory( window, utils ) {



// -------------------------- animate -------------------------- //

var proto = {};

proto.startAnimation = function() {
  if ( this.isAnimating ) {
    return;
  }

  this.isAnimating = true;
  this.restingFrames = 0;
  this.animate();
};

proto.animate = function() {
  this.applyDragForce();
  this.applySelectedAttraction();

  var previousX = this.x;

  this.integratePhysics();
  this.positionSlider();
  this.settle( previousX );
  // animate next frame
  if ( this.isAnimating ) {
    var _this = this;
    requestAnimationFrame( function animateFrame() {
      _this.animate();
    } );
  }
};

proto.positionSlider = function() {
  var x = this.x;
  // wrap position around
  if ( this.options.wrapAround && this.cells.length > 1 ) {
    x = utils.modulo( x, this.slideableWidth );
    x -= this.slideableWidth;
    this.shiftWrapCells( x );
  }

  this.setTranslateX( x, this.isAnimating );
  this.dispatchScrollEvent();
};

proto.setTranslateX = function( x, is3d ) {
  x += this.cursorPosition;
  // reverse if right-to-left and using transform
  x = this.options.rightToLeft ? -x : x;
  var translateX = this.getPositionValue( x );
  // use 3D transforms for hardware acceleration on iOS
  // but use 2D when settled, for better font-rendering
  this.slider.style.transform = is3d ?
    'translate3d(' + translateX + ',0,0)' : 'translateX(' + translateX + ')';
};

proto.dispatchScrollEvent = function() {
  var firstSlide = this.slides[0];
  if ( !firstSlide ) {
    return;
  }
  var positionX = -this.x - firstSlide.target;
  var progress = positionX / this.slidesWidth;
  this.dispatchEvent( 'scroll', null, [ progress, positionX ] );
};

proto.positionSliderAtSelected = function() {
  if ( !this.cells.length ) {
    return;
  }
  this.x = -this.selectedSlide.target;
  this.velocity = 0; // stop wobble
  this.positionSlider();
};

proto.getPositionValue = function( position ) {
  if ( this.options.percentPosition ) {
    // percent position, round to 2 digits, like 12.34%
    return ( Math.round( ( position / this.size.innerWidth ) * 10000 ) * 0.01 ) + '%';
  } else {
    // pixel positioning
    return Math.round( position ) + 'px';
  }
};

proto.settle = function( previousX ) {
  // keep track of frames where x hasn't moved
  var isResting = !this.isPointerDown &&
      Math.round( this.x * 100 ) == Math.round( previousX * 100 );
  if ( isResting ) {
    this.restingFrames++;
  }
  // stop animating if resting for 3 or more frames
  if ( this.restingFrames > 2 ) {
    this.isAnimating = false;
    delete this.isFreeScrolling;
    // render position with translateX when settled
    this.positionSlider();
    this.dispatchEvent( 'settle', null, [ this.selectedIndex ] );
  }
};

proto.shiftWrapCells = function( x ) {
  // shift before cells
  var beforeGap = this.cursorPosition + x;
  this._shiftCells( this.beforeShiftCells, beforeGap, -1 );
  // shift after cells
  var afterGap = this.size.innerWidth - ( x + this.slideableWidth + this.cursorPosition );
  this._shiftCells( this.afterShiftCells, afterGap, 1 );
};

proto._shiftCells = function( cells, gap, shift ) {
  for ( var i = 0; i < cells.length; i++ ) {
    var cell = cells[i];
    var cellShift = gap > 0 ? shift : 0;
    cell.wrapShift( cellShift );
    gap -= cell.size.outerWidth;
  }
};

proto._unshiftCells = function( cells ) {
  if ( !cells || !cells.length ) {
    return;
  }
  for ( var i = 0; i < cells.length; i++ ) {
    cells[i].wrapShift( 0 );
  }
};

// -------------------------- physics -------------------------- //

proto.integratePhysics = function() {
  this.x += this.velocity;
  this.velocity *= this.getFrictionFactor();
};

proto.applyForce = function( force ) {
  this.velocity += force;
};

proto.getFrictionFactor = function() {
  return 1 - this.options[ this.isFreeScrolling ? 'freeScrollFriction' : 'friction' ];
};

proto.getRestingPosition = function() {
  // my thanks to Steven Wittens, who simplified this math greatly
  return this.x + this.velocity / ( 1 - this.getFrictionFactor() );
};

proto.applyDragForce = function() {
  if ( !this.isDraggable || !this.isPointerDown ) {
    return;
  }
  // change the position to drag position by applying force
  var dragVelocity = this.dragX - this.x;
  var dragForce = dragVelocity - this.velocity;
  this.applyForce( dragForce );
};

proto.applySelectedAttraction = function() {
  // do not attract if pointer down or no slides
  var dragDown = this.isDraggable && this.isPointerDown;
  if ( dragDown || this.isFreeScrolling || !this.slides.length ) {
    return;
  }
  var distance = this.selectedSlide.target * -1 - this.x;
  var force = distance * this.options.selectedAttraction;
  this.applyForce( force );
};

return proto;

} ) );

// Flickity main
/* eslint-disable max-params */
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/flickity',[
      'ev-emitter/ev-emitter',
      'get-size/get-size',
      'fizzy-ui-utils/utils',
      './cell',
      './slide',
      './animate',
    ], function( EvEmitter, getSize, utils, Cell, Slide, animatePrototype ) {
      return factory( window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('ev-emitter'),
        require('get-size'),
        require('fizzy-ui-utils'),
        require('./cell'),
        require('./slide'),
        require('./animate')
    );
  } else {
    // browser global
    var _Flickity = window.Flickity;

    window.Flickity = factory(
        window,
        window.EvEmitter,
        window.getSize,
        window.fizzyUIUtils,
        _Flickity.Cell,
        _Flickity.Slide,
        _Flickity.animatePrototype
    );
  }

}( window, function factory( window, EvEmitter, getSize,
    utils, Cell, Slide, animatePrototype ) {

/* eslint-enable max-params */


// vars
var jQuery = window.jQuery;
var getComputedStyle = window.getComputedStyle;
var console = window.console;

function moveElements( elems, toElem ) {
  elems = utils.makeArray( elems );
  while ( elems.length ) {
    toElem.appendChild( elems.shift() );
  }
}

// -------------------------- Flickity -------------------------- //

// globally unique identifiers
var GUID = 0;
// internal store of all Flickity intances
var instances = {};

function Flickity( element, options ) {
  var queryElement = utils.getQueryElement( element );
  if ( !queryElement ) {
    if ( console ) {
      console.error( 'Bad element for Flickity: ' + ( queryElement || element ) );
    }
    return;
  }
  this.element = queryElement;
  // do not initialize twice on same element
  if ( this.element.flickityGUID ) {
    var instance = instances[ this.element.flickityGUID ];
    if ( instance ) instance.option( options );
    return instance;
  }

  // add jQuery
  if ( jQuery ) {
    this.$element = jQuery( this.element );
  }
  // options
  this.options = utils.extend( {}, this.constructor.defaults );
  this.option( options );

  // kick things off
  this._create();
}

Flickity.defaults = {
  accessibility: true,
  // adaptiveHeight: false,
  cellAlign: 'center',
  // cellSelector: undefined,
  // contain: false,
  freeScrollFriction: 0.075, // friction when free-scrolling
  friction: 0.28, // friction when selecting
  namespaceJQueryEvents: true,
  // initialIndex: 0,
  percentPosition: true,
  resize: true,
  selectedAttraction: 0.025,
  setGallerySize: true,
  // watchCSS: false,
  // wrapAround: false
};

// hash of methods triggered on _create()
Flickity.createMethods = [];

var proto = Flickity.prototype;
// inherit EventEmitter
utils.extend( proto, EvEmitter.prototype );

proto._create = function() {
  // add id for Flickity.data
  var id = this.guid = ++GUID;
  this.element.flickityGUID = id; // expando
  instances[ id ] = this; // associate via id
  // initial properties
  this.selectedIndex = 0;
  // how many frames slider has been in same position
  this.restingFrames = 0;
  // initial physics properties
  this.x = 0;
  this.velocity = 0;
  this.originSide = this.options.rightToLeft ? 'right' : 'left';
  // create viewport & slider
  this.viewport = document.createElement('div');
  this.viewport.className = 'flickity-viewport';
  this._createSlider();

  if ( this.options.resize || this.options.watchCSS ) {
    window.addEventListener( 'resize', this );
  }

  // add listeners from on option
  for ( var eventName in this.options.on ) {
    var listener = this.options.on[ eventName ];
    this.on( eventName, listener );
  }

  Flickity.createMethods.forEach( function( method ) {
    this[ method ]();
  }, this );

  if ( this.options.watchCSS ) {
    this.watchCSS();
  } else {
    this.activate();
  }

};

/**
 * set options
 * @param {Object} opts - options to extend
 */
proto.option = function( opts ) {
  utils.extend( this.options, opts );
};

proto.activate = function() {
  if ( this.isActive ) {
    return;
  }
  this.isActive = true;
  this.element.classList.add('flickity-enabled');
  if ( this.options.rightToLeft ) {
    this.element.classList.add('flickity-rtl');
  }

  this.getSize();
  // move initial cell elements so they can be loaded as cells
  var cellElems = this._filterFindCellElements( this.element.children );
  moveElements( cellElems, this.slider );
  this.viewport.appendChild( this.slider );
  this.element.appendChild( this.viewport );
  // get cells from children
  this.reloadCells();

  if ( this.options.accessibility ) {
    // allow element to focusable
    this.element.tabIndex = 0;
    // listen for key presses
    this.element.addEventListener( 'keydown', this );
  }

  this.emitEvent('activate');
  this.selectInitialIndex();
  // flag for initial activation, for using initialIndex
  this.isInitActivated = true;
  // ready event. #493
  this.dispatchEvent('ready');
};

// slider positions the cells
proto._createSlider = function() {
  // slider element does all the positioning
  var slider = document.createElement('div');
  slider.className = 'flickity-slider';
  slider.style[ this.originSide ] = 0;
  this.slider = slider;
};

proto._filterFindCellElements = function( elems ) {
  return utils.filterFindElements( elems, this.options.cellSelector );
};

// goes through all children
proto.reloadCells = function() {
  // collection of item elements
  this.cells = this._makeCells( this.slider.children );
  this.positionCells();
  this._getWrapShiftCells();
  this.setGallerySize();
};

/**
 * turn elements into Flickity.Cells
 * @param {[Array, NodeList, HTMLElement]} elems - elements to make into cells
 * @returns {Array} items - collection of new Flickity Cells
 */
proto._makeCells = function( elems ) {
  var cellElems = this._filterFindCellElements( elems );

  // create new Flickity for collection
  var cells = cellElems.map( function( cellElem ) {
    return new Cell( cellElem, this );
  }, this );

  return cells;
};

proto.getLastCell = function() {
  return this.cells[ this.cells.length - 1 ];
};

proto.getLastSlide = function() {
  return this.slides[ this.slides.length - 1 ];
};

// positions all cells
proto.positionCells = function() {
  // size all cells
  this._sizeCells( this.cells );
  // position all cells
  this._positionCells( 0 );
};

/**
 * position certain cells
 * @param {Integer} index - which cell to start with
 */
proto._positionCells = function( index ) {
  index = index || 0;
  // also measure maxCellHeight
  // start 0 if positioning all cells
  this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;
  var cellX = 0;
  // get cellX
  if ( index > 0 ) {
    var startCell = this.cells[ index - 1 ];
    cellX = startCell.x + startCell.size.outerWidth;
  }
  var len = this.cells.length;
  for ( var i = index; i < len; i++ ) {
    var cell = this.cells[i];
    cell.setPosition( cellX );
    cellX += cell.size.outerWidth;
    this.maxCellHeight = Math.max( cell.size.outerHeight, this.maxCellHeight );
  }
  // keep track of cellX for wrap-around
  this.slideableWidth = cellX;
  // slides
  this.updateSlides();
  // contain slides target
  this._containSlides();
  // update slidesWidth
  this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;
};

/**
 * cell.getSize() on multiple cells
 * @param {Array} cells - cells to size
 */
proto._sizeCells = function( cells ) {
  cells.forEach( function( cell ) {
    cell.getSize();
  } );
};

// --------------------------  -------------------------- //

proto.updateSlides = function() {
  this.slides = [];
  if ( !this.cells.length ) {
    return;
  }

  var slide = new Slide( this );
  this.slides.push( slide );
  var isOriginLeft = this.originSide == 'left';
  var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';

  var canCellFit = this._getCanCellFit();

  this.cells.forEach( function( cell, i ) {
    // just add cell if first cell in slide
    if ( !slide.cells.length ) {
      slide.addCell( cell );
      return;
    }

    var slideWidth = ( slide.outerWidth - slide.firstMargin ) +
      ( cell.size.outerWidth - cell.size[ nextMargin ] );

    if ( canCellFit.call( this, i, slideWidth ) ) {
      slide.addCell( cell );
    } else {
      // doesn't fit, new slide
      slide.updateTarget();

      slide = new Slide( this );
      this.slides.push( slide );
      slide.addCell( cell );
    }
  }, this );
  // last slide
  slide.updateTarget();
  // update .selectedSlide
  this.updateSelectedSlide();
};

proto._getCanCellFit = function() {
  var groupCells = this.options.groupCells;
  if ( !groupCells ) {
    return function() {
      return false;
    };
  } else if ( typeof groupCells == 'number' ) {
    // group by number. 3 -> [0,1,2], [3,4,5], ...
    var number = parseInt( groupCells, 10 );
    return function( i ) {
      return ( i % number ) !== 0;
    };
  }
  // default, group by width of slide
  // parse '75%
  var percentMatch = typeof groupCells == 'string' &&
    groupCells.match( /^(\d+)%$/ );
  var percent = percentMatch ? parseInt( percentMatch[1], 10 ) / 100 : 1;
  return function( i, slideWidth ) {
    /* eslint-disable-next-line no-invalid-this */
    return slideWidth <= ( this.size.innerWidth + 1 ) * percent;
  };
};

// alias _init for jQuery plugin .flickity()
proto._init =
proto.reposition = function() {
  this.positionCells();
  this.positionSliderAtSelected();
};

proto.getSize = function() {
  this.size = getSize( this.element );
  this.setCellAlign();
  this.cursorPosition = this.size.innerWidth * this.cellAlign;
};

var cellAlignShorthands = {
  // cell align, then based on origin side
  center: {
    left: 0.5,
    right: 0.5,
  },
  left: {
    left: 0,
    right: 1,
  },
  right: {
    right: 0,
    left: 1,
  },
};

proto.setCellAlign = function() {
  var shorthand = cellAlignShorthands[ this.options.cellAlign ];
  this.cellAlign = shorthand ? shorthand[ this.originSide ] : this.options.cellAlign;
};

proto.setGallerySize = function() {
  if ( this.options.setGallerySize ) {
    var height = this.options.adaptiveHeight && this.selectedSlide ?
      this.selectedSlide.height : this.maxCellHeight;
    this.viewport.style.height = height + 'px';
  }
};

proto._getWrapShiftCells = function() {
  // only for wrap-around
  if ( !this.options.wrapAround ) {
    return;
  }
  // unshift previous cells
  this._unshiftCells( this.beforeShiftCells );
  this._unshiftCells( this.afterShiftCells );
  // get before cells
  // initial gap
  var gapX = this.cursorPosition;
  var cellIndex = this.cells.length - 1;
  this.beforeShiftCells = this._getGapCells( gapX, cellIndex, -1 );
  // get after cells
  // ending gap between last cell and end of gallery viewport
  gapX = this.size.innerWidth - this.cursorPosition;
  // start cloning at first cell, working forwards
  this.afterShiftCells = this._getGapCells( gapX, 0, 1 );
};

proto._getGapCells = function( gapX, cellIndex, increment ) {
  // keep adding cells until the cover the initial gap
  var cells = [];
  while ( gapX > 0 ) {
    var cell = this.cells[ cellIndex ];
    if ( !cell ) {
      break;
    }
    cells.push( cell );
    cellIndex += increment;
    gapX -= cell.size.outerWidth;
  }
  return cells;
};

// ----- contain ----- //

// contain cell targets so no excess sliding
proto._containSlides = function() {
  if ( !this.options.contain || this.options.wrapAround || !this.cells.length ) {
    return;
  }
  var isRightToLeft = this.options.rightToLeft;
  var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';
  var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';
  var contentWidth = this.slideableWidth - this.getLastCell().size[ endMargin ];
  // content is less than gallery size
  var isContentSmaller = contentWidth < this.size.innerWidth;
  // bounds
  var beginBound = this.cursorPosition + this.cells[0].size[ beginMargin ];
  var endBound = contentWidth - this.size.innerWidth * ( 1 - this.cellAlign );
  // contain each cell target
  this.slides.forEach( function( slide ) {
    if ( isContentSmaller ) {
      // all cells fit inside gallery
      slide.target = contentWidth * this.cellAlign;
    } else {
      // contain to bounds
      slide.target = Math.max( slide.target, beginBound );
      slide.target = Math.min( slide.target, endBound );
    }
  }, this );
};

// -----  ----- //

/**
 * emits events via eventEmitter and jQuery events
 * @param {String} type - name of event
 * @param {Event} event - original event
 * @param {Array} args - extra arguments
 */
proto.dispatchEvent = function( type, event, args ) {
  var emitArgs = event ? [ event ].concat( args ) : args;
  this.emitEvent( type, emitArgs );

  if ( jQuery && this.$element ) {
    // default trigger with type if no event
    type += this.options.namespaceJQueryEvents ? '.flickity' : '';
    var $event = type;
    if ( event ) {
      // create jQuery event
      var jQEvent = new jQuery.Event( event );
      jQEvent.type = type;
      $event = jQEvent;
    }
    this.$element.trigger( $event, args );
  }
};

// -------------------------- select -------------------------- //

/**
 * @param {Integer} index - index of the slide
 * @param {Boolean} isWrap - will wrap-around to last/first if at the end
 * @param {Boolean} isInstant - will immediately set position at selected cell
 */
proto.select = function( index, isWrap, isInstant ) {
  if ( !this.isActive ) {
    return;
  }
  index = parseInt( index, 10 );
  this._wrapSelect( index );

  if ( this.options.wrapAround || isWrap ) {
    index = utils.modulo( index, this.slides.length );
  }
  // bail if invalid index
  if ( !this.slides[ index ] ) {
    return;
  }
  var prevIndex = this.selectedIndex;
  this.selectedIndex = index;
  this.updateSelectedSlide();
  if ( isInstant ) {
    this.positionSliderAtSelected();
  } else {
    this.startAnimation();
  }
  if ( this.options.adaptiveHeight ) {
    this.setGallerySize();
  }
  // events
  this.dispatchEvent( 'select', null, [ index ] );
  // change event if new index
  if ( index != prevIndex ) {
    this.dispatchEvent( 'change', null, [ index ] );
  }
  // old v1 event name, remove in v3
  this.dispatchEvent('cellSelect');
};

// wraps position for wrapAround, to move to closest slide. #113
proto._wrapSelect = function( index ) {
  var len = this.slides.length;
  var isWrapping = this.options.wrapAround && len > 1;
  if ( !isWrapping ) {
    return index;
  }
  var wrapIndex = utils.modulo( index, len );
  // go to shortest
  var delta = Math.abs( wrapIndex - this.selectedIndex );
  var backWrapDelta = Math.abs( ( wrapIndex + len ) - this.selectedIndex );
  var forewardWrapDelta = Math.abs( ( wrapIndex - len ) - this.selectedIndex );
  if ( !this.isDragSelect && backWrapDelta < delta ) {
    index += len;
  } else if ( !this.isDragSelect && forewardWrapDelta < delta ) {
    index -= len;
  }
  // wrap position so slider is within normal area
  if ( index < 0 ) {
    this.x -= this.slideableWidth;
  } else if ( index >= len ) {
    this.x += this.slideableWidth;
  }
};

proto.previous = function( isWrap, isInstant ) {
  this.select( this.selectedIndex - 1, isWrap, isInstant );
};

proto.next = function( isWrap, isInstant ) {
  this.select( this.selectedIndex + 1, isWrap, isInstant );
};

proto.updateSelectedSlide = function() {
  var slide = this.slides[ this.selectedIndex ];
  // selectedIndex could be outside of slides, if triggered before resize()
  if ( !slide ) {
    return;
  }
  // unselect previous selected slide
  this.unselectSelectedSlide();
  // update new selected slide
  this.selectedSlide = slide;
  slide.select();
  this.selectedCells = slide.cells;
  this.selectedElements = slide.getCellElements();
  // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility
  // Remove in v3?
  this.selectedCell = slide.cells[0];
  this.selectedElement = this.selectedElements[0];
};

proto.unselectSelectedSlide = function() {
  if ( this.selectedSlide ) {
    this.selectedSlide.unselect();
  }
};

proto.selectInitialIndex = function() {
  var initialIndex = this.options.initialIndex;
  // already activated, select previous selectedIndex
  if ( this.isInitActivated ) {
    this.select( this.selectedIndex, false, true );
    return;
  }
  // select with selector string
  if ( initialIndex && typeof initialIndex == 'string' ) {
    var cell = this.queryCell( initialIndex );
    if ( cell ) {
      this.selectCell( initialIndex, false, true );
      return;
    }
  }

  var index = 0;
  // select with number
  if ( initialIndex && this.slides[ initialIndex ] ) {
    index = initialIndex;
  }
  // select instantly
  this.select( index, false, true );
};

/**
 * select slide from number or cell element
 * @param {[Element, Number]} value - zero-based index or element to select
 * @param {Boolean} isWrap - enables wrapping around for extra index
 * @param {Boolean} isInstant - disables slide animation
 */
proto.selectCell = function( value, isWrap, isInstant ) {
  // get cell
  var cell = this.queryCell( value );
  if ( !cell ) {
    return;
  }

  var index = this.getCellSlideIndex( cell );
  this.select( index, isWrap, isInstant );
};

proto.getCellSlideIndex = function( cell ) {
  // get index of slides that has cell
  for ( var i = 0; i < this.slides.length; i++ ) {
    var slide = this.slides[i];
    var index = slide.cells.indexOf( cell );
    if ( index != -1 ) {
      return i;
    }
  }
};

// -------------------------- get cells -------------------------- //

/**
 * get Flickity.Cell, given an Element
 * @param {Element} elem - matching cell element
 * @returns {Flickity.Cell} cell - matching cell
 */
proto.getCell = function( elem ) {
  // loop through cells to get the one that matches
  for ( var i = 0; i < this.cells.length; i++ ) {
    var cell = this.cells[i];
    if ( cell.element == elem ) {
      return cell;
    }
  }
};

/**
 * get collection of Flickity.Cells, given Elements
 * @param {[Element, Array, NodeList]} elems - multiple elements
 * @returns {Array} cells - Flickity.Cells
 */
proto.getCells = function( elems ) {
  elems = utils.makeArray( elems );
  var cells = [];
  elems.forEach( function( elem ) {
    var cell = this.getCell( elem );
    if ( cell ) {
      cells.push( cell );
    }
  }, this );
  return cells;
};

/**
 * get cell elements
 * @returns {Array} cellElems
 */
proto.getCellElements = function() {
  return this.cells.map( function( cell ) {
    return cell.element;
  } );
};

/**
 * get parent cell from an element
 * @param {Element} elem - child element
 * @returns {Flickit.Cell} cell - parent cell
 */
proto.getParentCell = function( elem ) {
  // first check if elem is cell
  var cell = this.getCell( elem );
  if ( cell ) {
    return cell;
  }
  // try to get parent cell elem
  elem = utils.getParent( elem, '.flickity-slider > *' );
  return this.getCell( elem );
};

/**
 * get cells adjacent to a slide
 * @param {Integer} adjCount - number of adjacent slides
 * @param {Integer} index - index of slide to start
 * @returns {Array} cells - array of Flickity.Cells
 */
proto.getAdjacentCellElements = function( adjCount, index ) {
  if ( !adjCount ) {
    return this.selectedSlide.getCellElements();
  }
  index = index === undefined ? this.selectedIndex : index;

  var len = this.slides.length;
  if ( 1 + ( adjCount * 2 ) >= len ) {
    return this.getCellElements();
  }

  var cellElems = [];
  for ( var i = index - adjCount; i <= index + adjCount; i++ ) {
    var slideIndex = this.options.wrapAround ? utils.modulo( i, len ) : i;
    var slide = this.slides[ slideIndex ];
    if ( slide ) {
      cellElems = cellElems.concat( slide.getCellElements() );
    }
  }
  return cellElems;
};

/**
 * select slide from number or cell element
 * @param {[Element, String, Number]} selector - element, selector string, or index
 * @returns {Flickity.Cell} - matching cell
 */
proto.queryCell = function( selector ) {
  if ( typeof selector == 'number' ) {
    // use number as index
    return this.cells[ selector ];
  }
  if ( typeof selector == 'string' ) {
    // do not select invalid selectors from hash: #123, #/. #791
    if ( selector.match( /^[#.]?[\d/]/ ) ) {
      return;
    }
    // use string as selector, get element
    selector = this.element.querySelector( selector );
  }
  // get cell from element
  return this.getCell( selector );
};

// -------------------------- events -------------------------- //

proto.uiChange = function() {
  this.emitEvent('uiChange');
};

// keep focus on element when child UI elements are clicked
proto.childUIPointerDown = function( event ) {
  // HACK iOS does not allow touch events to bubble up?!
  if ( event.type != 'touchstart' ) {
    event.preventDefault();
  }
  this.focus();
};

// ----- resize ----- //

proto.onresize = function() {
  this.watchCSS();
  this.resize();
};

utils.debounceMethod( Flickity, 'onresize', 150 );

proto.resize = function() {
  if ( !this.isActive ) {
    return;
  }
  this.getSize();
  // wrap values
  if ( this.options.wrapAround ) {
    this.x = utils.modulo( this.x, this.slideableWidth );
  }
  this.positionCells();
  this._getWrapShiftCells();
  this.setGallerySize();
  this.emitEvent('resize');
  // update selected index for group slides, instant
  // TODO: position can be lost between groups of various numbers
  var selectedElement = this.selectedElements && this.selectedElements[0];
  this.selectCell( selectedElement, false, true );
};

// watches the :after property, activates/deactivates
proto.watchCSS = function() {
  var watchOption = this.options.watchCSS;
  if ( !watchOption ) {
    return;
  }

  var afterContent = getComputedStyle( this.element, ':after' ).content;
  // activate if :after { content: 'flickity' }
  if ( afterContent.indexOf('flickity') != -1 ) {
    this.activate();
  } else {
    this.deactivate();
  }
};

// ----- keydown ----- //

// go previous/next if left/right keys pressed
proto.onkeydown = function( event ) {
  // only work if element is in focus
  var isNotFocused = document.activeElement && document.activeElement != this.element;
  if ( !this.options.accessibility || isNotFocused ) {
    return;
  }

  var handler = Flickity.keyboardHandlers[ event.keyCode ];
  if ( handler ) {
    handler.call( this );
  }
};

Flickity.keyboardHandlers = {
  // left arrow
  37: function() {
    var leftMethod = this.options.rightToLeft ? 'next' : 'previous';
    this.uiChange();
    this[ leftMethod ]();
  },
  // right arrow
  39: function() {
    var rightMethod = this.options.rightToLeft ? 'previous' : 'next';
    this.uiChange();
    this[ rightMethod ]();
  },
};

// ----- focus ----- //

proto.focus = function() {
  // TODO remove scrollTo once focus options gets more support
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus ...
  //    #Browser_compatibility
  var prevScrollY = window.pageYOffset;
  this.element.focus({ preventScroll: true });
  // hack to fix scroll jump after focus, #76
  if ( window.pageYOffset != prevScrollY ) {
    window.scrollTo( window.pageXOffset, prevScrollY );
  }
};

// -------------------------- destroy -------------------------- //

// deactivate all Flickity functionality, but keep stuff available
proto.deactivate = function() {
  if ( !this.isActive ) {
    return;
  }
  this.element.classList.remove('flickity-enabled');
  this.element.classList.remove('flickity-rtl');
  this.unselectSelectedSlide();
  // destroy cells
  this.cells.forEach( function( cell ) {
    cell.destroy();
  } );
  this.element.removeChild( this.viewport );
  // move child elements back into element
  moveElements( this.slider.children, this.element );
  if ( this.options.accessibility ) {
    this.element.removeAttribute('tabIndex');
    this.element.removeEventListener( 'keydown', this );
  }
  // set flags
  this.isActive = false;
  this.emitEvent('deactivate');
};

proto.destroy = function() {
  this.deactivate();
  window.removeEventListener( 'resize', this );
  this.allOff();
  this.emitEvent('destroy');
  if ( jQuery && this.$element ) {
    jQuery.removeData( this.element, 'flickity' );
  }
  delete this.element.flickityGUID;
  delete instances[ this.guid ];
};

// -------------------------- prototype -------------------------- //

utils.extend( proto, animatePrototype );

// -------------------------- extras -------------------------- //

/**
 * get Flickity instance from element
 * @param {[Element, String]} elem - element or selector string
 * @returns {Flickity} - Flickity instance
 */
Flickity.data = function( elem ) {
  elem = utils.getQueryElement( elem );
  var id = elem && elem.flickityGUID;
  return id && instances[ id ];
};

utils.htmlInit( Flickity, 'flickity' );

if ( jQuery && jQuery.bridget ) {
  jQuery.bridget( 'flickity', Flickity );
}

// set internal jQuery, for Webpack + jQuery v3, #478
Flickity.setJQuery = function( jq ) {
  jQuery = jq;
};

Flickity.Cell = Cell;
Flickity.Slide = Slide;

return Flickity;

} ) );

/*!
 * Unipointer v2.3.0
 * base class for doing one thing with pointer event
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /*global define, module, require */
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'unipointer/unipointer',[
      'ev-emitter/ev-emitter'
    ], function( EvEmitter ) {
      return factory( window, EvEmitter );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('ev-emitter')
    );
  } else {
    // browser global
    window.Unipointer = factory(
      window,
      window.EvEmitter
    );
  }

}( window, function factory( window, EvEmitter ) {



function noop() {}

function Unipointer() {}

// inherit EvEmitter
var proto = Unipointer.prototype = Object.create( EvEmitter.prototype );

proto.bindStartEvent = function( elem ) {
  this._bindStartEvent( elem, true );
};

proto.unbindStartEvent = function( elem ) {
  this._bindStartEvent( elem, false );
};

/**
 * Add or remove start event
 * @param {Boolean} isAdd - remove if falsey
 */
proto._bindStartEvent = function( elem, isAdd ) {
  // munge isAdd, default to true
  isAdd = isAdd === undefined ? true : isAdd;
  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';

  // default to mouse events
  var startEvent = 'mousedown';
  if ( window.PointerEvent ) {
    // Pointer Events
    startEvent = 'pointerdown';
  } else if ( 'ontouchstart' in window ) {
    // Touch Events. iOS Safari
    startEvent = 'touchstart';
  }
  elem[ bindMethod ]( startEvent, this );
};

// trigger handler methods for events
proto.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

// returns the touch that we're keeping track of
proto.getTouch = function( touches ) {
  for ( var i=0; i < touches.length; i++ ) {
    var touch = touches[i];
    if ( touch.identifier == this.pointerIdentifier ) {
      return touch;
    }
  }
};

// ----- start event ----- //

proto.onmousedown = function( event ) {
  // dismiss clicks from right or middle buttons
  var button = event.button;
  if ( button && ( button !== 0 && button !== 1 ) ) {
    return;
  }
  this._pointerDown( event, event );
};

proto.ontouchstart = function( event ) {
  this._pointerDown( event, event.changedTouches[0] );
};

proto.onpointerdown = function( event ) {
  this._pointerDown( event, event );
};

/**
 * pointer start
 * @param {Event} event
 * @param {Event or Touch} pointer
 */
proto._pointerDown = function( event, pointer ) {
  // dismiss right click and other pointers
  // button = 0 is okay, 1-4 not
  if ( event.button || this.isPointerDown ) {
    return;
  }

  this.isPointerDown = true;
  // save pointer identifier to match up touch events
  this.pointerIdentifier = pointer.pointerId !== undefined ?
    // pointerId for pointer events, touch.indentifier for touch events
    pointer.pointerId : pointer.identifier;

  this.pointerDown( event, pointer );
};

proto.pointerDown = function( event, pointer ) {
  this._bindPostStartEvents( event );
  this.emitEvent( 'pointerDown', [ event, pointer ] );
};

// hash of events to be bound after start event
var postStartEvents = {
  mousedown: [ 'mousemove', 'mouseup' ],
  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],
  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],
};

proto._bindPostStartEvents = function( event ) {
  if ( !event ) {
    return;
  }
  // get proper events to match start event
  var events = postStartEvents[ event.type ];
  // bind events to node
  events.forEach( function( eventName ) {
    window.addEventListener( eventName, this );
  }, this );
  // save these arguments
  this._boundPointerEvents = events;
};

proto._unbindPostStartEvents = function() {
  // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)
  if ( !this._boundPointerEvents ) {
    return;
  }
  this._boundPointerEvents.forEach( function( eventName ) {
    window.removeEventListener( eventName, this );
  }, this );

  delete this._boundPointerEvents;
};

// ----- move event ----- //

proto.onmousemove = function( event ) {
  this._pointerMove( event, event );
};

proto.onpointermove = function( event ) {
  if ( event.pointerId == this.pointerIdentifier ) {
    this._pointerMove( event, event );
  }
};

proto.ontouchmove = function( event ) {
  var touch = this.getTouch( event.changedTouches );
  if ( touch ) {
    this._pointerMove( event, touch );
  }
};

/**
 * pointer move
 * @param {Event} event
 * @param {Event or Touch} pointer
 * @private
 */
proto._pointerMove = function( event, pointer ) {
  this.pointerMove( event, pointer );
};

// public
proto.pointerMove = function( event, pointer ) {
  this.emitEvent( 'pointerMove', [ event, pointer ] );
};

// ----- end event ----- //


proto.onmouseup = function( event ) {
  this._pointerUp( event, event );
};

proto.onpointerup = function( event ) {
  if ( event.pointerId == this.pointerIdentifier ) {
    this._pointerUp( event, event );
  }
};

proto.ontouchend = function( event ) {
  var touch = this.getTouch( event.changedTouches );
  if ( touch ) {
    this._pointerUp( event, touch );
  }
};

/**
 * pointer up
 * @param {Event} event
 * @param {Event or Touch} pointer
 * @private
 */
proto._pointerUp = function( event, pointer ) {
  this._pointerDone();
  this.pointerUp( event, pointer );
};

// public
proto.pointerUp = function( event, pointer ) {
  this.emitEvent( 'pointerUp', [ event, pointer ] );
};

// ----- pointer done ----- //

// triggered on pointer up & pointer cancel
proto._pointerDone = function() {
  this._pointerReset();
  this._unbindPostStartEvents();
  this.pointerDone();
};

proto._pointerReset = function() {
  // reset properties
  this.isPointerDown = false;
  delete this.pointerIdentifier;
};

proto.pointerDone = noop;

// ----- pointer cancel ----- //

proto.onpointercancel = function( event ) {
  if ( event.pointerId == this.pointerIdentifier ) {
    this._pointerCancel( event, event );
  }
};

proto.ontouchcancel = function( event ) {
  var touch = this.getTouch( event.changedTouches );
  if ( touch ) {
    this._pointerCancel( event, touch );
  }
};

/**
 * pointer cancel
 * @param {Event} event
 * @param {Event or Touch} pointer
 * @private
 */
proto._pointerCancel = function( event, pointer ) {
  this._pointerDone();
  this.pointerCancel( event, pointer );
};

// public
proto.pointerCancel = function( event, pointer ) {
  this.emitEvent( 'pointerCancel', [ event, pointer ] );
};

// -----  ----- //

// utility function for getting x/y coords from event
Unipointer.getPointerPoint = function( pointer ) {
  return {
    x: pointer.pageX,
    y: pointer.pageY
  };
};

// -----  ----- //

return Unipointer;

}));

/*!
 * Unidragger v2.3.1
 * Draggable base class
 * MIT license
 */

/*jshint browser: true, unused: true, undef: true, strict: true */

( function( window, factory ) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'unidragger/unidragger',[
      'unipointer/unipointer'
    ], function( Unipointer ) {
      return factory( window, Unipointer );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('unipointer')
    );
  } else {
    // browser global
    window.Unidragger = factory(
      window,
      window.Unipointer
    );
  }

}( window, function factory( window, Unipointer ) {



// -------------------------- Unidragger -------------------------- //

function Unidragger() {}

// inherit Unipointer & EvEmitter
var proto = Unidragger.prototype = Object.create( Unipointer.prototype );

// ----- bind start ----- //

proto.bindHandles = function() {
  this._bindHandles( true );
};

proto.unbindHandles = function() {
  this._bindHandles( false );
};

/**
 * Add or remove start event
 * @param {Boolean} isAdd
 */
proto._bindHandles = function( isAdd ) {
  // munge isAdd, default to true
  isAdd = isAdd === undefined ? true : isAdd;
  // bind each handle
  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';
  var touchAction = isAdd ? this._touchActionValue : '';
  for ( var i=0; i < this.handles.length; i++ ) {
    var handle = this.handles[i];
    this._bindStartEvent( handle, isAdd );
    handle[ bindMethod ]( 'click', this );
    // touch-action: none to override browser touch gestures. metafizzy/flickity#540
    if ( window.PointerEvent ) {
      handle.style.touchAction = touchAction;
    }
  }
};

// prototype so it can be overwriteable by Flickity
proto._touchActionValue = 'none';

// ----- start event ----- //

/**
 * pointer start
 * @param {Event} event
 * @param {Event or Touch} pointer
 */
proto.pointerDown = function( event, pointer ) {
  var isOkay = this.okayPointerDown( event );
  if ( !isOkay ) {
    return;
  }
  // track start event position
  // Safari 9 overrides pageX and pageY. These values needs to be copied. flickity#842
  this.pointerDownPointer = {
    pageX: pointer.pageX,
    pageY: pointer.pageY,
  };

  event.preventDefault();
  this.pointerDownBlur();
  // bind move and end events
  this._bindPostStartEvents( event );
  this.emitEvent( 'pointerDown', [ event, pointer ] );
};

// nodes that have text fields
var cursorNodes = {
  TEXTAREA: true,
  INPUT: true,
  SELECT: true,
  OPTION: true,
};

// input types that do not have text fields
var clickTypes = {
  radio: true,
  checkbox: true,
  button: true,
  submit: true,
  image: true,
  file: true,
};

// dismiss inputs with text fields. flickity#403, flickity#404
proto.okayPointerDown = function( event ) {
  var isCursorNode = cursorNodes[ event.target.nodeName ];
  var isClickType = clickTypes[ event.target.type ];
  var isOkay = !isCursorNode || isClickType;
  if ( !isOkay ) {
    this._pointerReset();
  }
  return isOkay;
};

// kludge to blur previously focused input
proto.pointerDownBlur = function() {
  var focused = document.activeElement;
  // do not blur body for IE10, metafizzy/flickity#117
  var canBlur = focused && focused.blur && focused != document.body;
  if ( canBlur ) {
    focused.blur();
  }
};

// ----- move event ----- //

/**
 * drag move
 * @param {Event} event
 * @param {Event or Touch} pointer
 */
proto.pointerMove = function( event, pointer ) {
  var moveVector = this._dragPointerMove( event, pointer );
  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );
  this._dragMove( event, pointer, moveVector );
};

// base pointer move logic
proto._dragPointerMove = function( event, pointer ) {
  var moveVector = {
    x: pointer.pageX - this.pointerDownPointer.pageX,
    y: pointer.pageY - this.pointerDownPointer.pageY
  };
  // start drag if pointer has moved far enough to start drag
  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {
    this._dragStart( event, pointer );
  }
  return moveVector;
};

// condition if pointer has moved far enough to start drag
proto.hasDragStarted = function( moveVector ) {
  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;
};

// ----- end event ----- //

/**
 * pointer up
 * @param {Event} event
 * @param {Event or Touch} pointer
 */
proto.pointerUp = function( event, pointer ) {
  this.emitEvent( 'pointerUp', [ event, pointer ] );
  this._dragPointerUp( event, pointer );
};

proto._dragPointerUp = function( event, pointer ) {
  if ( this.isDragging ) {
    this._dragEnd( event, pointer );
  } else {
    // pointer didn't move enough for drag to start
    this._staticClick( event, pointer );
  }
};

// -------------------------- drag -------------------------- //

// dragStart
proto._dragStart = function( event, pointer ) {
  this.isDragging = true;
  // prevent clicks
  this.isPreventingClicks = true;
  this.dragStart( event, pointer );
};

proto.dragStart = function( event, pointer ) {
  this.emitEvent( 'dragStart', [ event, pointer ] );
};

// dragMove
proto._dragMove = function( event, pointer, moveVector ) {
  // do not drag if not dragging yet
  if ( !this.isDragging ) {
    return;
  }

  this.dragMove( event, pointer, moveVector );
};

proto.dragMove = function( event, pointer, moveVector ) {
  event.preventDefault();
  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );
};

// dragEnd
proto._dragEnd = function( event, pointer ) {
  // set flags
  this.isDragging = false;
  // re-enable clicking async
  setTimeout( function() {
    delete this.isPreventingClicks;
  }.bind( this ) );

  this.dragEnd( event, pointer );
};

proto.dragEnd = function( event, pointer ) {
  this.emitEvent( 'dragEnd', [ event, pointer ] );
};

// ----- onclick ----- //

// handle all clicks and prevent clicks when dragging
proto.onclick = function( event ) {
  if ( this.isPreventingClicks ) {
    event.preventDefault();
  }
};

// ----- staticClick ----- //

// triggered after pointer down & up with no/tiny movement
proto._staticClick = function( event, pointer ) {
  // ignore emulated mouse up clicks
  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {
    return;
  }

  this.staticClick( event, pointer );

  // set flag for emulated clicks 300ms after touchend
  if ( event.type != 'mouseup' ) {
    this.isIgnoringMouseUp = true;
    // reset flag after 300ms
    setTimeout( function() {
      delete this.isIgnoringMouseUp;
    }.bind( this ), 400 );
  }
};

proto.staticClick = function( event, pointer ) {
  this.emitEvent( 'staticClick', [ event, pointer ] );
};

// ----- utils ----- //

Unidragger.getPointerPoint = Unipointer.getPointerPoint;

// -----  ----- //

return Unidragger;

}));

// drag
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/drag',[
      './flickity',
      'unidragger/unidragger',
      'fizzy-ui-utils/utils',
    ], function( Flickity, Unidragger, utils ) {
      return factory( window, Flickity, Unidragger, utils );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('./flickity'),
        require('unidragger'),
        require('fizzy-ui-utils')
    );
  } else {
    // browser global
    window.Flickity = factory(
        window,
        window.Flickity,
        window.Unidragger,
        window.fizzyUIUtils
    );
  }

}( window, function factory( window, Flickity, Unidragger, utils ) {



// ----- defaults ----- //

utils.extend( Flickity.defaults, {
  draggable: '>1',
  dragThreshold: 3,
} );

// ----- create ----- //

Flickity.createMethods.push('_createDrag');

// -------------------------- drag prototype -------------------------- //

var proto = Flickity.prototype;
utils.extend( proto, Unidragger.prototype );
proto._touchActionValue = 'pan-y';

// --------------------------  -------------------------- //

var isTouch = 'createTouch' in document;
var isTouchmoveScrollCanceled = false;

proto._createDrag = function() {
  this.on( 'activate', this.onActivateDrag );
  this.on( 'uiChange', this._uiChangeDrag );
  this.on( 'deactivate', this.onDeactivateDrag );
  this.on( 'cellChange', this.updateDraggable );
  // TODO updateDraggable on resize? if groupCells & slides change
  // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior
  // #457, RubaXa/Sortable#973
  if ( isTouch && !isTouchmoveScrollCanceled ) {
    window.addEventListener( 'touchmove', function() {} );
    isTouchmoveScrollCanceled = true;
  }
};

proto.onActivateDrag = function() {
  this.handles = [ this.viewport ];
  this.bindHandles();
  this.updateDraggable();
};

proto.onDeactivateDrag = function() {
  this.unbindHandles();
  this.element.classList.remove('is-draggable');
};

proto.updateDraggable = function() {
  // disable dragging if less than 2 slides. #278
  if ( this.options.draggable == '>1' ) {
    this.isDraggable = this.slides.length > 1;
  } else {
    this.isDraggable = this.options.draggable;
  }
  if ( this.isDraggable ) {
    this.element.classList.add('is-draggable');
  } else {
    this.element.classList.remove('is-draggable');
  }
};

// backwards compatibility
proto.bindDrag = function() {
  this.options.draggable = true;
  this.updateDraggable();
};

proto.unbindDrag = function() {
  this.options.draggable = false;
  this.updateDraggable();
};

proto._uiChangeDrag = function() {
  delete this.isFreeScrolling;
};

// -------------------------- pointer events -------------------------- //

proto.pointerDown = function( event, pointer ) {
  if ( !this.isDraggable ) {
    this._pointerDownDefault( event, pointer );
    return;
  }
  var isOkay = this.okayPointerDown( event );
  if ( !isOkay ) {
    return;
  }

  this._pointerDownPreventDefault( event );
  this.pointerDownFocus( event );
  // blur
  if ( document.activeElement != this.element ) {
    // do not blur if already focused
    this.pointerDownBlur();
  }

  // stop if it was moving
  this.dragX = this.x;
  this.viewport.classList.add('is-pointer-down');
  // track scrolling
  this.pointerDownScroll = getScrollPosition();
  window.addEventListener( 'scroll', this );

  this._pointerDownDefault( event, pointer );
};

// default pointerDown logic, used for staticClick
proto._pointerDownDefault = function( event, pointer ) {
  // track start event position
  // Safari 9 overrides pageX and pageY. These values needs to be copied. #779
  this.pointerDownPointer = {
    pageX: pointer.pageX,
    pageY: pointer.pageY,
  };
  // bind move and end events
  this._bindPostStartEvents( event );
  this.dispatchEvent( 'pointerDown', event, [ pointer ] );
};

var focusNodes = {
  INPUT: true,
  TEXTAREA: true,
  SELECT: true,
};

proto.pointerDownFocus = function( event ) {
  var isFocusNode = focusNodes[ event.target.nodeName ];
  if ( !isFocusNode ) {
    this.focus();
  }
};

proto._pointerDownPreventDefault = function( event ) {
  var isTouchStart = event.type == 'touchstart';
  var isTouchPointer = event.pointerType == 'touch';
  var isFocusNode = focusNodes[ event.target.nodeName ];
  if ( !isTouchStart && !isTouchPointer && !isFocusNode ) {
    event.preventDefault();
  }
};

// ----- move ----- //

proto.hasDragStarted = function( moveVector ) {
  return Math.abs( moveVector.x ) > this.options.dragThreshold;
};

// ----- up ----- //

proto.pointerUp = function( event, pointer ) {
  delete this.isTouchScrolling;
  this.viewport.classList.remove('is-pointer-down');
  this.dispatchEvent( 'pointerUp', event, [ pointer ] );
  this._dragPointerUp( event, pointer );
};

proto.pointerDone = function() {
  window.removeEventListener( 'scroll', this );
  delete this.pointerDownScroll;
};

// -------------------------- dragging -------------------------- //

proto.dragStart = function( event, pointer ) {
  if ( !this.isDraggable ) {
    return;
  }
  this.dragStartPosition = this.x;
  this.startAnimation();
  window.removeEventListener( 'scroll', this );
  this.dispatchEvent( 'dragStart', event, [ pointer ] );
};

proto.pointerMove = function( event, pointer ) {
  var moveVector = this._dragPointerMove( event, pointer );
  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );
  this._dragMove( event, pointer, moveVector );
};

proto.dragMove = function( event, pointer, moveVector ) {
  if ( !this.isDraggable ) {
    return;
  }
  event.preventDefault();

  this.previousDragX = this.dragX;
  // reverse if right-to-left
  var direction = this.options.rightToLeft ? -1 : 1;
  if ( this.options.wrapAround ) {
    // wrap around move. #589
    moveVector.x %= this.slideableWidth;
  }
  var dragX = this.dragStartPosition + moveVector.x * direction;

  if ( !this.options.wrapAround && this.slides.length ) {
    // slow drag
    var originBound = Math.max( -this.slides[0].target, this.dragStartPosition );
    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;
    var endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );
    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;
  }

  this.dragX = dragX;

  this.dragMoveTime = new Date();
  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );
};

proto.dragEnd = function( event, pointer ) {
  if ( !this.isDraggable ) {
    return;
  }
  if ( this.options.freeScroll ) {
    this.isFreeScrolling = true;
  }
  // set selectedIndex based on where flick will end up
  var index = this.dragEndRestingSelect();

  if ( this.options.freeScroll && !this.options.wrapAround ) {
    // if free-scroll & not wrap around
    // do not free-scroll if going outside of bounding slides
    // so bounding slides can attract slider, and keep it in bounds
    var restingX = this.getRestingPosition();
    this.isFreeScrolling = -restingX > this.slides[0].target &&
      -restingX < this.getLastSlide().target;
  } else if ( !this.options.freeScroll && index == this.selectedIndex ) {
    // boost selection if selected index has not changed
    index += this.dragEndBoostSelect();
  }
  delete this.previousDragX;
  // apply selection
  // TODO refactor this, selecting here feels weird
  // HACK, set flag so dragging stays in correct direction
  this.isDragSelect = this.options.wrapAround;
  this.select( index );
  delete this.isDragSelect;
  this.dispatchEvent( 'dragEnd', event, [ pointer ] );
};

proto.dragEndRestingSelect = function() {
  var restingX = this.getRestingPosition();
  // how far away from selected slide
  var distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );
  // get closet resting going up and going down
  var positiveResting = this._getClosestResting( restingX, distance, 1 );
  var negativeResting = this._getClosestResting( restingX, distance, -1 );
  // use closer resting for wrap-around
  var index = positiveResting.distance < negativeResting.distance ?
    positiveResting.index : negativeResting.index;
  return index;
};

/**
 * given resting X and distance to selected cell
 * get the distance and index of the closest cell
 * @param {Number} restingX - estimated post-flick resting position
 * @param {Number} distance - distance to selected cell
 * @param {Integer} increment - +1 or -1, going up or down
 * @returns {Object} - { distance: {Number}, index: {Integer} }
 */
proto._getClosestResting = function( restingX, distance, increment ) {
  var index = this.selectedIndex;
  var minDistance = Infinity;
  var condition = this.options.contain && !this.options.wrapAround ?
    // if contain, keep going if distance is equal to minDistance
    function( dist, minDist ) {
      return dist <= minDist;
    } : function( dist, minDist ) {
      return dist < minDist;
    };
  while ( condition( distance, minDistance ) ) {
    // measure distance to next cell
    index += increment;
    minDistance = distance;
    distance = this.getSlideDistance( -restingX, index );
    if ( distance === null ) {
      break;
    }
    distance = Math.abs( distance );
  }
  return {
    distance: minDistance,
    // selected was previous index
    index: index - increment,
  };
};

/**
 * measure distance between x and a slide target
 * @param {Number} x - horizontal position
 * @param {Integer} index - slide index
 * @returns {Number} - slide distance
 */
proto.getSlideDistance = function( x, index ) {
  var len = this.slides.length;
  // wrap around if at least 2 slides
  var isWrapAround = this.options.wrapAround && len > 1;
  var slideIndex = isWrapAround ? utils.modulo( index, len ) : index;
  var slide = this.slides[ slideIndex ];
  if ( !slide ) {
    return null;
  }
  // add distance for wrap-around slides
  var wrap = isWrapAround ? this.slideableWidth * Math.floor( index/len ) : 0;
  return x - ( slide.target + wrap );
};

proto.dragEndBoostSelect = function() {
  // do not boost if no previousDragX or dragMoveTime
  if ( this.previousDragX === undefined || !this.dragMoveTime ||
    // or if drag was held for 100 ms
    new Date() - this.dragMoveTime > 100 ) {
    return 0;
  }

  var distance = this.getSlideDistance( -this.dragX, this.selectedIndex );
  var delta = this.previousDragX - this.dragX;
  if ( distance > 0 && delta > 0 ) {
    // boost to next if moving towards the right, and positive velocity
    return 1;
  } else if ( distance < 0 && delta < 0 ) {
    // boost to previous if moving towards the left, and negative velocity
    return -1;
  }
  return 0;
};

// ----- staticClick ----- //

proto.staticClick = function( event, pointer ) {
  // get clickedCell, if cell was clicked
  var clickedCell = this.getParentCell( event.target );
  var cellElem = clickedCell && clickedCell.element;
  var cellIndex = clickedCell && this.cells.indexOf( clickedCell );
  this.dispatchEvent( 'staticClick', event, [ pointer, cellElem, cellIndex ] );
};

// ----- scroll ----- //

proto.onscroll = function() {
  var scroll = getScrollPosition();
  var scrollMoveX = this.pointerDownScroll.x - scroll.x;
  var scrollMoveY = this.pointerDownScroll.y - scroll.y;
  // cancel click/tap if scroll is too much
  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {
    this._pointerDone();
  }
};

// ----- utils ----- //

function getScrollPosition() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset,
  };
}

// -----  ----- //

return Flickity;

} ) );

// prev/next buttons
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/prev-next-button',[
      './flickity',
      'unipointer/unipointer',
      'fizzy-ui-utils/utils',
    ], function( Flickity, Unipointer, utils ) {
      return factory( window, Flickity, Unipointer, utils );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('./flickity'),
        require('unipointer'),
        require('fizzy-ui-utils')
    );
  } else {
    // browser global
    factory(
        window,
        window.Flickity,
        window.Unipointer,
        window.fizzyUIUtils
    );
  }

}( window, function factory( window, Flickity, Unipointer, utils ) {
'use strict';

var svgURI = 'http://www.w3.org/2000/svg';

// -------------------------- PrevNextButton -------------------------- //

function PrevNextButton( direction, parent ) {
  this.direction = direction;
  this.parent = parent;
  this._create();
}

PrevNextButton.prototype = Object.create( Unipointer.prototype );

PrevNextButton.prototype._create = function() {
  // properties
  this.isEnabled = true;
  this.isPrevious = this.direction == -1;
  var leftDirection = this.parent.options.rightToLeft ? 1 : -1;
  this.isLeft = this.direction == leftDirection;

  var element = this.element = document.createElement('button');
  element.className = 'flickity-button flickity-prev-next-button';
  element.className += this.isPrevious ? ' previous' : ' next';
  // prevent button from submitting form http://stackoverflow.com/a/10836076/182183
  element.setAttribute( 'type', 'button' );
  // init as disabled
  this.disable();

  element.setAttribute( 'aria-label', this.isPrevious ? 'Previous' : 'Next' );

  // create arrow
  var svg = this.createSVG();
  element.appendChild( svg );
  // events
  this.parent.on( 'select', this.update.bind( this ) );
  this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );
};

PrevNextButton.prototype.activate = function() {
  this.bindStartEvent( this.element );
  this.element.addEventListener( 'click', this );
  // add to DOM
  this.parent.element.appendChild( this.element );
};

PrevNextButton.prototype.deactivate = function() {
  // remove from DOM
  this.parent.element.removeChild( this.element );
  // click events
  this.unbindStartEvent( this.element );
  this.element.removeEventListener( 'click', this );
};

PrevNextButton.prototype.createSVG = function() {
  var svg = document.createElementNS( svgURI, 'svg' );
  svg.setAttribute( 'class', 'flickity-button-icon' );
  svg.setAttribute( 'viewBox', '0 0 100 100' );
  var path = document.createElementNS( svgURI, 'path' );
  var pathMovements = getArrowMovements( this.parent.options.arrowShape );
  path.setAttribute( 'd', pathMovements );
  path.setAttribute( 'class', 'arrow' );
  // rotate arrow
  if ( !this.isLeft ) {
    path.setAttribute( 'transform', 'translate(100, 100) rotate(180) ' );
  }
  svg.appendChild( path );
  return svg;
};

// get SVG path movmement
function getArrowMovements( shape ) {
  // use shape as movement if string
  if ( typeof shape == 'string' ) {
    return shape;
  }
  // create movement string
  return 'M ' + shape.x0 + ',50' +
    ' L ' + shape.x1 + ',' + ( shape.y1 + 50 ) +
    ' L ' + shape.x2 + ',' + ( shape.y2 + 50 ) +
    ' L ' + shape.x3 + ',50 ' +
    ' L ' + shape.x2 + ',' + ( 50 - shape.y2 ) +
    ' L ' + shape.x1 + ',' + ( 50 - shape.y1 ) +
    ' Z';
}

PrevNextButton.prototype.handleEvent = utils.handleEvent;

PrevNextButton.prototype.onclick = function() {
  if ( !this.isEnabled ) {
    return;
  }
  this.parent.uiChange();
  var method = this.isPrevious ? 'previous' : 'next';
  this.parent[ method ]();
};

// -----  ----- //

PrevNextButton.prototype.enable = function() {
  if ( this.isEnabled ) {
    return;
  }
  this.element.disabled = false;
  this.isEnabled = true;
};

PrevNextButton.prototype.disable = function() {
  if ( !this.isEnabled ) {
    return;
  }
  this.element.disabled = true;
  this.isEnabled = false;
};

PrevNextButton.prototype.update = function() {
  // index of first or last slide, if previous or next
  var slides = this.parent.slides;
  // enable is wrapAround and at least 2 slides
  if ( this.parent.options.wrapAround && slides.length > 1 ) {
    this.enable();
    return;
  }
  var lastIndex = slides.length ? slides.length - 1 : 0;
  var boundIndex = this.isPrevious ? 0 : lastIndex;
  var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';
  this[ method ]();
};

PrevNextButton.prototype.destroy = function() {
  this.deactivate();
  this.allOff();
};

// -------------------------- Flickity prototype -------------------------- //

utils.extend( Flickity.defaults, {
  prevNextButtons: true,
  arrowShape: {
    x0: 10,
    x1: 60, y1: 50,
    x2: 70, y2: 40,
    x3: 30,
  },
} );

Flickity.createMethods.push('_createPrevNextButtons');
var proto = Flickity.prototype;

proto._createPrevNextButtons = function() {
  if ( !this.options.prevNextButtons ) {
    return;
  }

  this.prevButton = new PrevNextButton( -1, this );
  this.nextButton = new PrevNextButton( 1, this );

  this.on( 'activate', this.activatePrevNextButtons );
};

proto.activatePrevNextButtons = function() {
  this.prevButton.activate();
  this.nextButton.activate();
  this.on( 'deactivate', this.deactivatePrevNextButtons );
};

proto.deactivatePrevNextButtons = function() {
  this.prevButton.deactivate();
  this.nextButton.deactivate();
  this.off( 'deactivate', this.deactivatePrevNextButtons );
};

// --------------------------  -------------------------- //

Flickity.PrevNextButton = PrevNextButton;

return Flickity;

} ) );

// page dots
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/page-dots',[
      './flickity',
      'unipointer/unipointer',
      'fizzy-ui-utils/utils',
    ], function( Flickity, Unipointer, utils ) {
      return factory( window, Flickity, Unipointer, utils );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('./flickity'),
        require('unipointer'),
        require('fizzy-ui-utils')
    );
  } else {
    // browser global
    factory(
        window,
        window.Flickity,
        window.Unipointer,
        window.fizzyUIUtils
    );
  }

}( window, function factory( window, Flickity, Unipointer, utils ) {

// -------------------------- PageDots -------------------------- //



function PageDots( parent ) {
  this.parent = parent;
  this._create();
}

PageDots.prototype = Object.create( Unipointer.prototype );

PageDots.prototype._create = function() {
  // create holder element
  this.holder = document.createElement('ol');
  this.holder.className = 'flickity-page-dots';
  // create dots, array of elements
  this.dots = [];
  // events
  this.handleClick = this.onClick.bind( this );
  this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );
};

PageDots.prototype.activate = function() {
  this.setDots();
  this.holder.addEventListener( 'click', this.handleClick );
  this.bindStartEvent( this.holder );
  // add to DOM
  this.parent.element.appendChild( this.holder );
};

PageDots.prototype.deactivate = function() {
  this.holder.removeEventListener( 'click', this.handleClick );
  this.unbindStartEvent( this.holder );
  // remove from DOM
  this.parent.element.removeChild( this.holder );
};

PageDots.prototype.setDots = function() {
  // get difference between number of slides and number of dots
  var delta = this.parent.slides.length - this.dots.length;
  if ( delta > 0 ) {
    this.addDots( delta );
  } else if ( delta < 0 ) {
    this.removeDots( -delta );
  }
};

PageDots.prototype.addDots = function( count ) {
  var fragment = document.createDocumentFragment();
  var newDots = [];
  var length = this.dots.length;
  var max = length + count;

  for ( var i = length; i < max; i++ ) {
    var dot = document.createElement('li');
    dot.className = 'dot';
    dot.setAttribute( 'aria-label', 'Page dot ' + ( i + 1 ) );
    fragment.appendChild( dot );
    newDots.push( dot );
  }

  this.holder.appendChild( fragment );
  this.dots = this.dots.concat( newDots );
};

PageDots.prototype.removeDots = function( count ) {
  // remove from this.dots collection
  var removeDots = this.dots.splice( this.dots.length - count, count );
  // remove from DOM
  removeDots.forEach( function( dot ) {
    this.holder.removeChild( dot );
  }, this );
};

PageDots.prototype.updateSelected = function() {
  // remove selected class on previous
  if ( this.selectedDot ) {
    this.selectedDot.className = 'dot';
    this.selectedDot.removeAttribute('aria-current');
  }
  // don't proceed if no dots
  if ( !this.dots.length ) {
    return;
  }
  this.selectedDot = this.dots[ this.parent.selectedIndex ];
  this.selectedDot.className = 'dot is-selected';
  this.selectedDot.setAttribute( 'aria-current', 'step' );
};

PageDots.prototype.onTap = // old method name, backwards-compatible
PageDots.prototype.onClick = function( event ) {
  var target = event.target;
  // only care about dot clicks
  if ( target.nodeName != 'LI' ) {
    return;
  }

  this.parent.uiChange();
  var index = this.dots.indexOf( target );
  this.parent.select( index );
};

PageDots.prototype.destroy = function() {
  this.deactivate();
  this.allOff();
};

Flickity.PageDots = PageDots;

// -------------------------- Flickity -------------------------- //

utils.extend( Flickity.defaults, {
  pageDots: true,
} );

Flickity.createMethods.push('_createPageDots');

var proto = Flickity.prototype;

proto._createPageDots = function() {
  if ( !this.options.pageDots ) {
    return;
  }
  this.pageDots = new PageDots( this );
  // events
  this.on( 'activate', this.activatePageDots );
  this.on( 'select', this.updateSelectedPageDots );
  this.on( 'cellChange', this.updatePageDots );
  this.on( 'resize', this.updatePageDots );
  this.on( 'deactivate', this.deactivatePageDots );
};

proto.activatePageDots = function() {
  this.pageDots.activate();
};

proto.updateSelectedPageDots = function() {
  this.pageDots.updateSelected();
};

proto.updatePageDots = function() {
  this.pageDots.setDots();
};

proto.deactivatePageDots = function() {
  this.pageDots.deactivate();
};

// -----  ----- //

Flickity.PageDots = PageDots;

return Flickity;

} ) );

// player & autoPlay
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/player',[
      'ev-emitter/ev-emitter',
      'fizzy-ui-utils/utils',
      './flickity',
    ], function( EvEmitter, utils, Flickity ) {
      return factory( EvEmitter, utils, Flickity );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        require('ev-emitter'),
        require('fizzy-ui-utils'),
        require('./flickity')
    );
  } else {
    // browser global
    factory(
        window.EvEmitter,
        window.fizzyUIUtils,
        window.Flickity
    );
  }

}( window, function factory( EvEmitter, utils, Flickity ) {



// -------------------------- Player -------------------------- //

function Player( parent ) {
  this.parent = parent;
  this.state = 'stopped';
  // visibility change event handler
  this.onVisibilityChange = this.visibilityChange.bind( this );
  this.onVisibilityPlay = this.visibilityPlay.bind( this );
}

Player.prototype = Object.create( EvEmitter.prototype );

// start play
Player.prototype.play = function() {
  if ( this.state == 'playing' ) {
    return;
  }
  // do not play if page is hidden, start playing when page is visible
  var isPageHidden = document.hidden;
  if ( isPageHidden ) {
    document.addEventListener( 'visibilitychange', this.onVisibilityPlay );
    return;
  }

  this.state = 'playing';
  // listen to visibility change
  document.addEventListener( 'visibilitychange', this.onVisibilityChange );
  // start ticking
  this.tick();
};

Player.prototype.tick = function() {
  // do not tick if not playing
  if ( this.state != 'playing' ) {
    return;
  }

  var time = this.parent.options.autoPlay;
  // default to 3 seconds
  time = typeof time == 'number' ? time : 3000;
  var _this = this;
  // HACK: reset ticks if stopped and started within interval
  this.clear();
  this.timeout = setTimeout( function() {
    _this.parent.next( true );
    _this.tick();
  }, time );
};

Player.prototype.stop = function() {
  this.state = 'stopped';
  this.clear();
  // remove visibility change event
  document.removeEventListener( 'visibilitychange', this.onVisibilityChange );
};

Player.prototype.clear = function() {
  clearTimeout( this.timeout );
};

Player.prototype.pause = function() {
  if ( this.state == 'playing' ) {
    this.state = 'paused';
    this.clear();
  }
};

Player.prototype.unpause = function() {
  // re-start play if paused
  if ( this.state == 'paused' ) {
    this.play();
  }
};

// pause if page visibility is hidden, unpause if visible
Player.prototype.visibilityChange = function() {
  var isPageHidden = document.hidden;
  this[ isPageHidden ? 'pause' : 'unpause' ]();
};

Player.prototype.visibilityPlay = function() {
  this.play();
  document.removeEventListener( 'visibilitychange', this.onVisibilityPlay );
};

// -------------------------- Flickity -------------------------- //

utils.extend( Flickity.defaults, {
  pauseAutoPlayOnHover: true,
} );

Flickity.createMethods.push('_createPlayer');
var proto = Flickity.prototype;

proto._createPlayer = function() {
  this.player = new Player( this );

  this.on( 'activate', this.activatePlayer );
  this.on( 'uiChange', this.stopPlayer );
  this.on( 'pointerDown', this.stopPlayer );
  this.on( 'deactivate', this.deactivatePlayer );
};

proto.activatePlayer = function() {
  if ( !this.options.autoPlay ) {
    return;
  }
  this.player.play();
  this.element.addEventListener( 'mouseenter', this );
};

// Player API, don't hate the ... thanks I know where the door is

proto.playPlayer = function() {
  this.player.play();
};

proto.stopPlayer = function() {
  this.player.stop();
};

proto.pausePlayer = function() {
  this.player.pause();
};

proto.unpausePlayer = function() {
  this.player.unpause();
};

proto.deactivatePlayer = function() {
  this.player.stop();
  this.element.removeEventListener( 'mouseenter', this );
};

// ----- mouseenter/leave ----- //

// pause auto-play on hover
proto.onmouseenter = function() {
  if ( !this.options.pauseAutoPlayOnHover ) {
    return;
  }
  this.player.pause();
  this.element.addEventListener( 'mouseleave', this );
};

// resume auto-play on hover off
proto.onmouseleave = function() {
  this.player.unpause();
  this.element.removeEventListener( 'mouseleave', this );
};

// -----  ----- //

Flickity.Player = Player;

return Flickity;

} ) );

// add, remove cell
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/add-remove-cell',[
      './flickity',
      'fizzy-ui-utils/utils',
    ], function( Flickity, utils ) {
      return factory( window, Flickity, utils );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('./flickity'),
        require('fizzy-ui-utils')
    );
  } else {
    // browser global
    factory(
        window,
        window.Flickity,
        window.fizzyUIUtils
    );
  }

}( window, function factory( window, Flickity, utils ) {



// append cells to a document fragment
function getCellsFragment( cells ) {
  var fragment = document.createDocumentFragment();
  cells.forEach( function( cell ) {
    fragment.appendChild( cell.element );
  } );
  return fragment;
}

// -------------------------- add/remove cell prototype -------------------------- //

var proto = Flickity.prototype;

/**
 * Insert, prepend, or append cells
 * @param {[Element, Array, NodeList]} elems - Elements to insert
 * @param {Integer} index - Zero-based number to insert
 */
proto.insert = function( elems, index ) {
  var cells = this._makeCells( elems );
  if ( !cells || !cells.length ) {
    return;
  }
  var len = this.cells.length;
  // default to append
  index = index === undefined ? len : index;
  // add cells with document fragment
  var fragment = getCellsFragment( cells );
  // append to slider
  var isAppend = index == len;
  if ( isAppend ) {
    this.slider.appendChild( fragment );
  } else {
    var insertCellElement = this.cells[ index ].element;
    this.slider.insertBefore( fragment, insertCellElement );
  }
  // add to this.cells
  if ( index === 0 ) {
    // prepend, add to start
    this.cells = cells.concat( this.cells );
  } else if ( isAppend ) {
    // append, add to end
    this.cells = this.cells.concat( cells );
  } else {
    // insert in this.cells
    var endCells = this.cells.splice( index, len - index );
    this.cells = this.cells.concat( cells ).concat( endCells );
  }

  this._sizeCells( cells );
  this.cellChange( index, true );
};

proto.append = function( elems ) {
  this.insert( elems, this.cells.length );
};

proto.prepend = function( elems ) {
  this.insert( elems, 0 );
};

/**
 * Remove cells
 * @param {[Element, Array, NodeList]} elems - ELements to remove
 */
proto.remove = function( elems ) {
  var cells = this.getCells( elems );
  if ( !cells || !cells.length ) {
    return;
  }

  var minCellIndex = this.cells.length - 1;
  // remove cells from collection & DOM
  cells.forEach( function( cell ) {
    cell.remove();
    var index = this.cells.indexOf( cell );
    minCellIndex = Math.min( index, minCellIndex );
    utils.removeFrom( this.cells, cell );
  }, this );

  this.cellChange( minCellIndex, true );
};

/**
 * logic to be run after a cell's size changes
 * @param {Element} elem - cell's element
 */
proto.cellSizeChange = function( elem ) {
  var cell = this.getCell( elem );
  if ( !cell ) {
    return;
  }
  cell.getSize();

  var index = this.cells.indexOf( cell );
  this.cellChange( index );
};

/**
 * logic any time a cell is changed: added, removed, or size changed
 * @param {Integer} changedCellIndex - index of the changed cell, optional
 * @param {Boolean} isPositioningSlider - Positions slider after selection
 */
proto.cellChange = function( changedCellIndex, isPositioningSlider ) {
  var prevSelectedElem = this.selectedElement;
  this._positionCells( changedCellIndex );
  this._getWrapShiftCells();
  this.setGallerySize();
  // update selectedIndex
  // try to maintain position & select previous selected element
  var cell = this.getCell( prevSelectedElem );
  if ( cell ) {
    this.selectedIndex = this.getCellSlideIndex( cell );
  }
  this.selectedIndex = Math.min( this.slides.length - 1, this.selectedIndex );

  this.emitEvent( 'cellChange', [ changedCellIndex ] );
  // position slider
  this.select( this.selectedIndex );
  // do not position slider after lazy load
  if ( isPositioningSlider ) {
    this.positionSliderAtSelected();
  }
};

// -----  ----- //

return Flickity;

} ) );

// lazyload
( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/lazyload',[
      './flickity',
      'fizzy-ui-utils/utils',
    ], function( Flickity, utils ) {
      return factory( window, Flickity, utils );
    } );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        window,
        require('./flickity'),
        require('fizzy-ui-utils')
    );
  } else {
    // browser global
    factory(
        window,
        window.Flickity,
        window.fizzyUIUtils
    );
  }

}( window, function factory( window, Flickity, utils ) {
'use strict';

Flickity.createMethods.push('_createLazyload');
var proto = Flickity.prototype;

proto._createLazyload = function() {
  this.on( 'select', this.lazyLoad );
};

proto.lazyLoad = function() {
  var lazyLoad = this.options.lazyLoad;
  if ( !lazyLoad ) {
    return;
  }
  // get adjacent cells, use lazyLoad option for adjacent count
  var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;
  var cellElems = this.getAdjacentCellElements( adjCount );
  // get lazy images in those cells
  var lazyImages = [];
  cellElems.forEach( function( cellElem ) {
    var lazyCellImages = getCellLazyImages( cellElem );
    lazyImages = lazyImages.concat( lazyCellImages );
  } );
  // load lazy images
  lazyImages.forEach( function( img ) {
    new LazyLoader( img, this );
  }, this );
};

function getCellLazyImages( cellElem ) {
  // check if cell element is lazy image
  if ( cellElem.nodeName == 'IMG' ) {
    var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');
    var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');
    var srcsetAttr = cellElem.getAttribute('data-flickity-lazyload-srcset');
    if ( lazyloadAttr || srcAttr || srcsetAttr ) {
      return [ cellElem ];
    }
  }
  // select lazy images in cell
  var lazySelector = 'img[data-flickity-lazyload], ' +
    'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';
  var imgs = cellElem.querySelectorAll( lazySelector );
  return utils.makeArray( imgs );
}

// -------------------------- LazyLoader -------------------------- //

/**
 * class to handle loading images
 * @param {Image} img - Image element
 * @param {Flickity} flickity - Flickity instance
 */
function LazyLoader( img, flickity ) {
  this.img = img;
  this.flickity = flickity;
  this.load();
}

LazyLoader.prototype.handleEvent = utils.handleEvent;

LazyLoader.prototype.load = function() {
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  // get src & srcset
  var src = this.img.getAttribute('data-flickity-lazyload') ||
    this.img.getAttribute('data-flickity-lazyload-src');
  var srcset = this.img.getAttribute('data-flickity-lazyload-srcset');
  // set src & serset
  this.img.src = src;
  if ( srcset ) {
    this.img.setAttribute( 'srcset', srcset );
  }
  // remove attr
  this.img.removeAttribute('data-flickity-lazyload');
  this.img.removeAttribute('data-flickity-lazyload-src');
  this.img.removeAttribute('data-flickity-lazyload-srcset');
};

LazyLoader.prototype.onload = function( event ) {
  this.complete( event, 'flickity-lazyloaded' );
};

LazyLoader.prototype.onerror = function( event ) {
  this.complete( event, 'flickity-lazyerror' );
};

LazyLoader.prototype.complete = function( event, className ) {
  // unbind events
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );

  var cell = this.flickity.getParentCell( this.img );
  var cellElem = cell && cell.element;
  this.flickity.cellSizeChange( cellElem );

  this.img.classList.add( className );
  this.flickity.dispatchEvent( 'lazyLoad', event, cellElem );
};

// -----  ----- //

Flickity.LazyLoader = LazyLoader;

return Flickity;

} ) );

/*!
 * Flickity v2.2.2
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */

( function( window, factory ) {
  // universal module definition
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity/js/index',[
      './flickity',
      './drag',
      './prev-next-button',
      './page-dots',
      './player',
      './add-remove-cell',
      './lazyload',
    ], factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
        require('./flickity'),
        require('./drag'),
        require('./prev-next-button'),
        require('./page-dots'),
        require('./player'),
        require('./add-remove-cell'),
        require('./lazyload')
    );
  }

} )( window, function factory( Flickity ) {
  return Flickity;
} );

/*!
 * Flickity asNavFor v2.0.2
 * enable asNavFor for Flickity
 */

/*jshint browser: true, undef: true, unused: true, strict: true*/

( function( window, factory ) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'flickity-as-nav-for/as-nav-for',[
      'flickity/js/index',
      'fizzy-ui-utils/utils'
    ], factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      require('flickity'),
      require('fizzy-ui-utils')
    );
  } else {
    // browser global
    window.Flickity = factory(
      window.Flickity,
      window.fizzyUIUtils
    );
  }

}( window, function factory( Flickity, utils ) {



// -------------------------- asNavFor prototype -------------------------- //

// Flickity.defaults.asNavFor = null;

Flickity.createMethods.push('_createAsNavFor');

var proto = Flickity.prototype;

proto._createAsNavFor = function() {
  this.on( 'activate', this.activateAsNavFor );
  this.on( 'deactivate', this.deactivateAsNavFor );
  this.on( 'destroy', this.destroyAsNavFor );

  var asNavForOption = this.options.asNavFor;
  if ( !asNavForOption ) {
    return;
  }
  // HACK do async, give time for other flickity to be initalized
  var _this = this;
  setTimeout( function initNavCompanion() {
    _this.setNavCompanion( asNavForOption );
  });
};

proto.setNavCompanion = function( elem ) {
  elem = utils.getQueryElement( elem );
  var companion = Flickity.data( elem );
  // stop if no companion or companion is self
  if ( !companion || companion == this ) {
    return;
  }

  this.navCompanion = companion;
  // companion select
  var _this = this;
  this.onNavCompanionSelect = function() {
    _this.navCompanionSelect();
  };
  companion.on( 'select', this.onNavCompanionSelect );
  // click
  this.on( 'staticClick', this.onNavStaticClick );

  this.navCompanionSelect( true );
};

proto.navCompanionSelect = function( isInstant ) {
  // wait for companion & selectedCells first. #8
  var companionCells = this.navCompanion && this.navCompanion.selectedCells;
  if ( !companionCells ) {
    return;
  }
  // select slide that matches first cell of slide
  var selectedCell = companionCells[0];
  var firstIndex = this.navCompanion.cells.indexOf( selectedCell );
  var lastIndex = firstIndex + companionCells.length - 1;
  var selectIndex = Math.floor( lerp( firstIndex, lastIndex,
    this.navCompanion.cellAlign ) );
  this.selectCell( selectIndex, false, isInstant );
  // set nav selected class
  this.removeNavSelectedElements();
  // stop if companion has more cells than this one
  if ( selectIndex >= this.cells.length ) {
    return;
  }

  var selectedCells = this.cells.slice( firstIndex, lastIndex + 1 );
  this.navSelectedElements = selectedCells.map( function( cell ) {
    return cell.element;
  });
  this.changeNavSelectedClass('add');
};

function lerp( a, b, t ) {
  return ( b - a ) * t + a;
}

proto.changeNavSelectedClass = function( method ) {
  this.navSelectedElements.forEach( function( navElem ) {
    navElem.classList[ method ]('is-nav-selected');
  });
};

proto.activateAsNavFor = function() {
  this.navCompanionSelect( true );
};

proto.removeNavSelectedElements = function() {
  if ( !this.navSelectedElements ) {
    return;
  }
  this.changeNavSelectedClass('remove');
  delete this.navSelectedElements;
};

proto.onNavStaticClick = function( event, pointer, cellElement, cellIndex ) {
  if ( typeof cellIndex == 'number' ) {
    this.navCompanion.selectCell( cellIndex );
  }
};

proto.deactivateAsNavFor = function() {
  this.removeNavSelectedElements();
};

proto.destroyAsNavFor = function() {
  if ( !this.navCompanion ) {
    return;
  }
  this.navCompanion.off( 'select', this.onNavCompanionSelect );
  this.off( 'staticClick', this.onNavStaticClick );
  delete this.navCompanion;
};

// -----  ----- //

return Flickity;

}));

/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) { 'use strict';
  // universal module definition

  /*global define: false, module: false, require: false */

  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( 'imagesloaded/imagesloaded',[
      'ev-emitter/ev-emitter'
    ], function( EvEmitter ) {
      return factory( window, EvEmitter );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('ev-emitter')
    );
  } else {
    // browser global
    window.imagesLoaded = factory(
      window,
      window.EvEmitter
    );
  }

})( typeof window !== 'undefined' ? window : this,

// --------------------------  factory -------------------------- //

function factory( window, EvEmitter ) {



var $ = window.jQuery;
var console = window.console;

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var arraySlice = Array.prototype.slice;

// turn element or nodeList into an array
function makeArray( obj ) {
  if ( Array.isArray( obj ) ) {
    // use object if already an array
    return obj;
  }

  var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
  if ( isArrayLike ) {
    // convert nodeList to array
    return arraySlice.call( obj );
  }

  // array of single index
  return [ obj ];
}

// -------------------------- imagesLoaded -------------------------- //

/**
 * @param {Array, Element, NodeList, String} elem
 * @param {Object or Function} options - if function, use as callback
 * @param {Function} onAlways - callback function
 */
function ImagesLoaded( elem, options, onAlways ) {
  // coerce ImagesLoaded() without new, to be new ImagesLoaded()
  if ( !( this instanceof ImagesLoaded ) ) {
    return new ImagesLoaded( elem, options, onAlways );
  }
  // use elem as selector string
  var queryElem = elem;
  if ( typeof elem == 'string' ) {
    queryElem = document.querySelectorAll( elem );
  }
  // bail if bad element
  if ( !queryElem ) {
    console.error( 'Bad element for imagesLoaded ' + ( queryElem || elem ) );
    return;
  }

  this.elements = makeArray( queryElem );
  this.options = extend( {}, this.options );
  // shift arguments if no options set
  if ( typeof options == 'function' ) {
    onAlways = options;
  } else {
    extend( this.options, options );
  }

  if ( onAlways ) {
    this.on( 'always', onAlways );
  }

  this.getImages();

  if ( $ ) {
    // add jQuery Deferred object
    this.jqDeferred = new $.Deferred();
  }

  // HACK check async to allow time to bind listeners
  setTimeout( this.check.bind( this ) );
}

ImagesLoaded.prototype = Object.create( EvEmitter.prototype );

ImagesLoaded.prototype.options = {};

ImagesLoaded.prototype.getImages = function() {
  this.images = [];

  // filter & find items if we have an item selector
  this.elements.forEach( this.addElementImages, this );
};

/**
 * @param {Node} element
 */
ImagesLoaded.prototype.addElementImages = function( elem ) {
  // filter siblings
  if ( elem.nodeName == 'IMG' ) {
    this.addImage( elem );
  }
  // get background image on element
  if ( this.options.background === true ) {
    this.addElementBackgroundImages( elem );
  }

  // find children
  // no non-element nodes, #143
  var nodeType = elem.nodeType;
  if ( !nodeType || !elementNodeTypes[ nodeType ] ) {
    return;
  }
  var childImgs = elem.querySelectorAll('img');
  // concat childElems to filterFound array
  for ( var i=0; i < childImgs.length; i++ ) {
    var img = childImgs[i];
    this.addImage( img );
  }

  // get child background images
  if ( typeof this.options.background == 'string' ) {
    var children = elem.querySelectorAll( this.options.background );
    for ( i=0; i < children.length; i++ ) {
      var child = children[i];
      this.addElementBackgroundImages( child );
    }
  }
};

var elementNodeTypes = {
  1: true,
  9: true,
  11: true
};

ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
  var style = getComputedStyle( elem );
  if ( !style ) {
    // Firefox returns null if in a hidden iframe https://bugzil.la/548397
    return;
  }
  // get url inside url("...")
  var reURL = /url\((['"])?(.*?)\1\)/gi;
  var matches = reURL.exec( style.backgroundImage );
  while ( matches !== null ) {
    var url = matches && matches[2];
    if ( url ) {
      this.addBackground( url, elem );
    }
    matches = reURL.exec( style.backgroundImage );
  }
};

/**
 * @param {Image} img
 */
ImagesLoaded.prototype.addImage = function( img ) {
  var loadingImage = new LoadingImage( img );
  this.images.push( loadingImage );
};

ImagesLoaded.prototype.addBackground = function( url, elem ) {
  var background = new Background( url, elem );
  this.images.push( background );
};

ImagesLoaded.prototype.check = function() {
  var _this = this;
  this.progressedCount = 0;
  this.hasAnyBroken = false;
  // complete if no images
  if ( !this.images.length ) {
    this.complete();
    return;
  }

  function onProgress( image, elem, message ) {
    // HACK - Chrome triggers event before object properties have changed. #83
    setTimeout( function() {
      _this.progress( image, elem, message );
    });
  }

  this.images.forEach( function( loadingImage ) {
    loadingImage.once( 'progress', onProgress );
    loadingImage.check();
  });
};

ImagesLoaded.prototype.progress = function( image, elem, message ) {
  this.progressedCount++;
  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
  // progress event
  this.emitEvent( 'progress', [ this, image, elem ] );
  if ( this.jqDeferred && this.jqDeferred.notify ) {
    this.jqDeferred.notify( this, image );
  }
  // check if completed
  if ( this.progressedCount == this.images.length ) {
    this.complete();
  }

  if ( this.options.debug && console ) {
    console.log( 'progress: ' + message, image, elem );
  }
};

ImagesLoaded.prototype.complete = function() {
  var eventName = this.hasAnyBroken ? 'fail' : 'done';
  this.isComplete = true;
  this.emitEvent( eventName, [ this ] );
  this.emitEvent( 'always', [ this ] );
  if ( this.jqDeferred ) {
    var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
    this.jqDeferred[ jqMethod ]( this );
  }
};

// --------------------------  -------------------------- //

function LoadingImage( img ) {
  this.img = img;
}

LoadingImage.prototype = Object.create( EvEmitter.prototype );

LoadingImage.prototype.check = function() {
  // If complete is true and browser supports natural sizes,
  // try to check for image status manually.
  var isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    // report based on naturalWidth
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    return;
  }

  // If none of the checks above matched, simulate loading on detached element.
  this.proxyImage = new Image();
  this.proxyImage.addEventListener( 'load', this );
  this.proxyImage.addEventListener( 'error', this );
  // bind to image as well for Firefox. #191
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.proxyImage.src = this.img.src;
};

LoadingImage.prototype.getIsImageComplete = function() {
  // check for non-zero, non-undefined naturalWidth
  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
  return this.img.complete && this.img.naturalWidth;
};

LoadingImage.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.img, message ] );
};

// ----- events ----- //

// trigger specified handler for event type
LoadingImage.prototype.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

LoadingImage.prototype.onload = function() {
  this.confirm( true, 'onload' );
  this.unbindEvents();
};

LoadingImage.prototype.onerror = function() {
  this.confirm( false, 'onerror' );
  this.unbindEvents();
};

LoadingImage.prototype.unbindEvents = function() {
  this.proxyImage.removeEventListener( 'load', this );
  this.proxyImage.removeEventListener( 'error', this );
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

// -------------------------- Background -------------------------- //

function Background( url, element ) {
  this.url = url;
  this.element = element;
  this.img = new Image();
}

// inherit LoadingImage prototype
Background.prototype = Object.create( LoadingImage.prototype );

Background.prototype.check = function() {
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.img.src = this.url;
  // check if image is already complete
  var isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    this.unbindEvents();
  }
};

Background.prototype.unbindEvents = function() {
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

Background.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.element, message ] );
};

// -------------------------- jQuery -------------------------- //

ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
  jQuery = jQuery || window.jQuery;
  if ( !jQuery ) {
    return;
  }
  // set local variable
  $ = jQuery;
  // $().imagesLoaded()
  $.fn.imagesLoaded = function( options, callback ) {
    var instance = new ImagesLoaded( this, options, callback );
    return instance.jqDeferred.promise( $(this) );
  };
};
// try making plugin
ImagesLoaded.makeJQueryPlugin();

// --------------------------  -------------------------- //

return ImagesLoaded;

});

/*!
 * Flickity imagesLoaded v2.0.0
 * enables imagesLoaded option for Flickity
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

( function( window, factory ) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */
  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( [
      'flickity/js/index',
      'imagesloaded/imagesloaded'
    ], function( Flickity, imagesLoaded ) {
      return factory( window, Flickity, imagesLoaded );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('flickity'),
      require('imagesloaded')
    );
  } else {
    // browser global
    window.Flickity = factory(
      window,
      window.Flickity,
      window.imagesLoaded
    );
  }

}( window, function factory( window, Flickity, imagesLoaded ) {
'use strict';

Flickity.createMethods.push('_createImagesLoaded');

var proto = Flickity.prototype;

proto._createImagesLoaded = function() {
  this.on( 'activate', this.imagesLoaded );
};

proto.imagesLoaded = function() {
  if ( !this.options.imagesLoaded ) {
    return;
  }
  var _this = this;
  function onImagesLoadedProgress( instance, image ) {
    var cell = _this.getParentCell( image.img );
    _this.cellSizeChange( cell && cell.element );
    if ( !_this.options.freeScroll ) {
      _this.positionSliderAtSelected();
    }
  }
  imagesLoaded( this.slider ).on( 'progress', onImagesLoadedProgress );
};

return Flickity;

}));

/**
 * MARQUEE 3000 MARQUEE 3000 MARQUEE 3000 MARQUEE 3000 MARQUEE 3000
 * http://github.com/ezekielaquino/marquee3000
 * Marquees for the new millennium v1.0
 * MIT License
 */

 ;(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Marquee3k = factory();
  }
}(this, function() {
  'use strict';

  let animationId = 0;

  class Marquee3k {
    constructor(element, options) {

      if (element.children.length === 0) {
        throw new Error("Encountered a marquee element without children, please supply a wrapper for your content");
      }

      this.element = element;
      this.selector = options.selector;
      this.speed = element.dataset.speed || 0.25;
      this.pausable = element.dataset.pausable;
      this.reverse = element.dataset.reverse;
      this.paused = false;
      this.parent = element.parentElement;
      this.parentProps = this.parent.getBoundingClientRect();
      this.content = element.children[0];
      this.innerContent = this.content.innerHTML;
      this.wrapStyles = '';
      this.offset = 0;

      this._setupWrapper();
      this._setupContent();
      this._setupEvents();

      this.wrapper.appendChild(this.content);
      this.element.appendChild(this.wrapper);
    }

    _setupWrapper() {
      this.wrapper = document.createElement('div');
      this.wrapper.classList.add('marquee3k__wrapper');
      this.wrapper.style.whiteSpace = 'nowrap';
    }

    _setupContent() {
      this.content.classList.add(`${this.selector}__copy`);
      this.content.style.display = 'inline-block';
      this.contentWidth = this.content.offsetWidth;

      this.requiredReps = this.contentWidth > this.parentProps.width ? 2 : Math.ceil((this.parentProps.width - this.contentWidth) / this.contentWidth) + 1;

      for (let i = 0; i < this.requiredReps; i++) {
        this._createClone();
      }

      if (this.reverse) {
        this.offset = this.contentWidth * -1;
      }

      this.element.classList.add('is-init');
    }

    _setupEvents() {
      this.element.addEventListener('mouseenter', () => {
        if (this.pausable) this.paused = true;
      });

      this.element.addEventListener('mouseleave', () => {
        if (this.pausable) this.paused = false;
      });
    }

    _createClone() {
      const clone = this.content.cloneNode(true);
      clone.style.display = 'inline-block';
      clone.classList.add(`${this.selector}__copy`);
      this.wrapper.appendChild(clone);
    }

    animate() {
      if (!this.paused) {
        const isScrolled = this.reverse ? this.offset < 0 : this.offset > this.contentWidth * -1;
        const direction = this.reverse ? -1 : 1;
        const reset = this.reverse ? this.contentWidth * -1 : 0;

        if (isScrolled) this.offset -= this.speed * direction;
        else this.offset = reset;

        this.wrapper.style.whiteSpace = 'nowrap';
        this.wrapper.style.transform = `translate(${this.offset}px, 0) translateZ(0)`;
      }
    }

    _refresh() {
      this.contentWidth = this.content.offsetWidth;
    }

    repopulate(difference, isLarger) {
      this.contentWidth = this.content.offsetWidth;

      if (isLarger) {
        const amount = Math.ceil(difference / this.contentWidth) + 1;

        for (let i = 0; i < amount; i++) {
          this._createClone();
        }
      }
    }

    static refresh(index) {
      MARQUEES[index]._refresh();
    }

    static pause(index) {
      MARQUEES[index].paused = true;
    }

    static play(index) {
      MARQUEES[index].paused = false;
    }

    static toggle(index) {
      MARQUEES[index].paused = !MARQUEES[index].paused;
    }

    static refreshAll() {
      for (let i = 0; i < MARQUEES.length; i++) {
        MARQUEES[i]._refresh();
      }
    }

    static pauseAll() {
      for (let i = 0; i < MARQUEES.length; i++) {
        MARQUEES[i].paused = true;
      }
    }

    static playAll() {
      for (let i = 0; i < MARQUEES.length; i++) {
        MARQUEES[i].paused = false;
      }
    }

    static toggleAll() {
      for (let i = 0; i < MARQUEES.length; i++) {
        MARQUEES[i].paused = !MARQUEES[i].paused;
      }
    }

    static init(options = { selector: 'marquee3k' }) {
      if (animationId) window.cancelAnimationFrame(animationId);

      window.MARQUEES = [];
      const marquees = Array.from(document.querySelectorAll(`.${options.selector}`));
      let previousWidth = window.innerWidth;
      let timer;

      for (let i = 0; i < marquees.length; i++) {
        const marquee = marquees[i];
        const instance = new Marquee3k(marquee, options);
        MARQUEES.push(instance);
      }

      animate();

      function animate() {
        for (let i = 0; i < MARQUEES.length; i++) {
          MARQUEES[i].animate();
        }
        animationId = window.requestAnimationFrame(animate);
      }

      window.addEventListener('resize', () => {
        clearTimeout(timer);

        timer = setTimeout(() => {
          const isLarger = previousWidth < window.innerWidth;
          const difference = window.innerWidth - previousWidth;

          for (let i = 0; i < MARQUEES.length; i++) {
            MARQUEES[i].repopulate(difference, isLarger);
          }

          previousWidth = this.innerWidth;
        }, 250);
      });
    }
  }

  return Marquee3k;

}));
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.LazyLoad = factory());
  }(this, (function () { 'use strict';
  
    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
  
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
  
        return target;
      };
  
      return _extends.apply(this, arguments);
    }
  
    var runningOnBrowser = typeof window !== "undefined";
    var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent);
    var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
    var supportsClassList = runningOnBrowser && "classList" in document.createElement("p");
    var isHiDpi = runningOnBrowser && window.devicePixelRatio > 1;
  
    var defaultSettings = {
      elements_selector: ".lazy",
      container: isBot || runningOnBrowser ? document : null,
      threshold: 300,
      thresholds: null,
      data_src: "src",
      data_srcset: "srcset",
      data_sizes: "sizes",
      data_bg: "bg",
      data_bg_hidpi: "bg-hidpi",
      data_bg_multi: "bg-multi",
      data_bg_multi_hidpi: "bg-multi-hidpi",
      data_poster: "poster",
      class_applied: "applied",
      class_loading: "loading",
      class_loaded: "loaded",
      class_error: "error",
      class_entered: "entered",
      class_exited: "exited",
      unobserve_completed: true,
      unobserve_entered: false,
      cancel_on_exit: true,
      callback_enter: null,
      callback_exit: null,
      callback_applied: null,
      callback_loading: null,
      callback_loaded: null,
      callback_error: null,
      callback_finish: null,
      callback_cancel: null,
      use_native: false
    };
    var getExtendedSettings = function getExtendedSettings(customSettings) {
      return _extends({}, defaultSettings, customSettings);
    };
  
    /* Creates instance and notifies it through the window element */
    var createInstance = function createInstance(classObj, options) {
      var event;
      var eventString = "LazyLoad::Initialized";
      var instance = new classObj(options);
  
      try {
        // Works in modern browsers
        event = new CustomEvent(eventString, {
          detail: {
            instance: instance
          }
        });
      } catch (err) {
        // Works in Internet Explorer (all versions)
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(eventString, false, false, {
          instance: instance
        });
      }
  
      window.dispatchEvent(event);
    };
    /* Auto initialization of one or more instances of lazyload, depending on the 
        options passed in (plain object or an array) */
  
  
    var autoInitialize = function autoInitialize(classObj, options) {
      if (!options) {
        return;
      }
  
      if (!options.length) {
        // Plain object
        createInstance(classObj, options);
      } else {
        // Array of objects
        for (var i = 0, optionsItem; optionsItem = options[i]; i += 1) {
          createInstance(classObj, optionsItem);
        }
      }
    };
  
    var statusLoading = "loading";
    var statusLoaded = "loaded";
    var statusApplied = "applied";
    var statusEntered = "entered";
    var statusError = "error";
    var statusNative = "native";
  
    var dataPrefix = "data-";
    var statusDataName = "ll-status";
    var getData = function getData(element, attribute) {
      return element.getAttribute(dataPrefix + attribute);
    };
    var setData = function setData(element, attribute, value) {
      var attrName = dataPrefix + attribute;
  
      if (value === null) {
        element.removeAttribute(attrName);
        return;
      }
  
      element.setAttribute(attrName, value);
    };
    var getStatus = function getStatus(element) {
      return getData(element, statusDataName);
    };
    var setStatus = function setStatus(element, status) {
      return setData(element, statusDataName, status);
    };
    var resetStatus = function resetStatus(element) {
      return setStatus(element, null);
    };
    var hasEmptyStatus = function hasEmptyStatus(element) {
      return getStatus(element) === null;
    };
    var hasStatusLoading = function hasStatusLoading(element) {
      return getStatus(element) === statusLoading;
    };
    var hasStatusError = function hasStatusError(element) {
      return getStatus(element) === statusError;
    };
    var hasStatusNative = function hasStatusNative(element) {
      return getStatus(element) === statusNative;
    };
    var statusesAfterLoading = [statusLoading, statusLoaded, statusApplied, statusError];
    var hadStartedLoading = function hadStartedLoading(element) {
      return statusesAfterLoading.indexOf(getStatus(element)) >= 0;
    };
  
    var safeCallback = function safeCallback(callback, arg1, arg2, arg3) {
      if (!callback) {
        return;
      }
  
      if (arg3 !== undefined) {
        callback(arg1, arg2, arg3);
        return;
      }
  
      if (arg2 !== undefined) {
        callback(arg1, arg2);
        return;
      }
  
      callback(arg1);
    };
  
    var addClass = function addClass(element, className) {
      if (supportsClassList) {
        element.classList.add(className);
        return;
      }
  
      element.className += (element.className ? " " : "") + className;
    };
    var removeClass = function removeClass(element, className) {
      if (supportsClassList) {
        element.classList.remove(className);
        return;
      }
  
      element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
    };
  
    var addTempImage = function addTempImage(element) {
      element.llTempImage = document.createElement("IMG");
    };
    var deleteTempImage = function deleteTempImage(element) {
      delete element.llTempImage;
    };
    var getTempImage = function getTempImage(element) {
      return element.llTempImage;
    };
  
    var unobserve = function unobserve(element, instance) {
      if (!instance) return;
      var observer = instance._observer;
      if (!observer) return;
      observer.unobserve(element);
    };
    var resetObserver = function resetObserver(observer) {
      observer.disconnect();
    };
    var unobserveEntered = function unobserveEntered(element, settings, instance) {
      if (settings.unobserve_entered) unobserve(element, instance);
    };
  
    var updateLoadingCount = function updateLoadingCount(instance, delta) {
      if (!instance) return;
      instance.loadingCount += delta;
    };
    var decreaseToLoadCount = function decreaseToLoadCount(instance) {
      if (!instance) return;
      instance.toLoadCount -= 1;
    };
    var setToLoadCount = function setToLoadCount(instance, value) {
      if (!instance) return;
      instance.toLoadCount = value;
    };
    var isSomethingLoading = function isSomethingLoading(instance) {
      return instance.loadingCount > 0;
    };
    var haveElementsToLoad = function haveElementsToLoad(instance) {
      return instance.toLoadCount > 0;
    };
  
    var getSourceTags = function getSourceTags(parentTag) {
      var sourceTags = [];
  
      for (var i = 0, childTag; childTag = parentTag.children[i]; i += 1) {
        if (childTag.tagName === "SOURCE") {
          sourceTags.push(childTag);
        }
      }
  
      return sourceTags;
    };
    var setAttributeIfValue = function setAttributeIfValue(element, attrName, value) {
      if (!value) {
        return;
      }
  
      element.setAttribute(attrName, value);
    };
    var resetAttribute = function resetAttribute(element, attrName) {
      element.removeAttribute(attrName);
    };
    var hasOriginalAttributes = function hasOriginalAttributes(element) {
      return !!element.llOriginalAttrs;
    };
    var saveOriginalImageAttributes = function saveOriginalImageAttributes(element) {
      if (hasOriginalAttributes(element)) {
        return;
      }
  
      var originalAttributes = {};
      originalAttributes["src"] = element.getAttribute("src");
      originalAttributes["srcset"] = element.getAttribute("srcset");
      originalAttributes["sizes"] = element.getAttribute("sizes");
      element.llOriginalAttrs = originalAttributes;
    };
    var restoreOriginalImageAttributes = function restoreOriginalImageAttributes(element) {
      if (!hasOriginalAttributes(element)) {
        return;
      }
  
      var originalAttributes = element.llOriginalAttrs;
      setAttributeIfValue(element, "src", originalAttributes["src"]);
      setAttributeIfValue(element, "srcset", originalAttributes["srcset"]);
      setAttributeIfValue(element, "sizes", originalAttributes["sizes"]);
    };
    var setImageAttributes = function setImageAttributes(element, settings) {
      setAttributeIfValue(element, "sizes", getData(element, settings.data_sizes));
      setAttributeIfValue(element, "srcset", getData(element, settings.data_srcset));
      setAttributeIfValue(element, "src", getData(element, settings.data_src));
    };
    var resetImageAttributes = function resetImageAttributes(element) {
      resetAttribute(element, "src");
      resetAttribute(element, "srcset");
      resetAttribute(element, "sizes");
    };
    var forEachPictureSource = function forEachPictureSource(element, fn) {
      var parent = element.parentNode;
  
      if (!parent || parent.tagName !== "PICTURE") {
        return;
      }
  
      var sourceTags = getSourceTags(parent);
      sourceTags.forEach(fn);
    };
    var forEachVideoSource = function forEachVideoSource(element, fn) {
      var sourceTags = getSourceTags(element);
      sourceTags.forEach(fn);
    };
    var restoreOriginalAttributesImg = function restoreOriginalAttributesImg(element) {
      forEachPictureSource(element, function (sourceTag) {
        restoreOriginalImageAttributes(sourceTag);
      });
      restoreOriginalImageAttributes(element);
    };
    var setSourcesImg = function setSourcesImg(element, settings) {
      forEachPictureSource(element, function (sourceTag) {
        saveOriginalImageAttributes(sourceTag);
        setImageAttributes(sourceTag, settings);
      });
      saveOriginalImageAttributes(element);
      setImageAttributes(element, settings);
    };
    var resetSourcesImg = function resetSourcesImg(element) {
      forEachPictureSource(element, function (sourceTag) {
        resetImageAttributes(sourceTag);
      });
      resetImageAttributes(element);
    };
    var setSourcesIframe = function setSourcesIframe(element, settings) {
      setAttributeIfValue(element, "src", getData(element, settings.data_src));
    };
    var setSourcesVideo = function setSourcesVideo(element, settings) {
      forEachVideoSource(element, function (sourceTag) {
        setAttributeIfValue(sourceTag, "src", getData(sourceTag, settings.data_src));
      });
      setAttributeIfValue(element, "poster", getData(element, settings.data_poster));
      setAttributeIfValue(element, "src", getData(element, settings.data_src));
      element.load();
    };
    var setSourcesFunctions = {
      IMG: setSourcesImg,
      IFRAME: setSourcesIframe,
      VIDEO: setSourcesVideo
    };
    var setBackground = function setBackground(element, settings, instance) {
      var bg1xValue = getData(element, settings.data_bg);
      var bgHiDpiValue = getData(element, settings.data_bg_hidpi);
      var bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
      if (!bgDataValue) return;
      element.style.backgroundImage = "url(\"".concat(bgDataValue, "\")");
      getTempImage(element).setAttribute("src", bgDataValue);
      manageLoading(element, settings, instance);
    }; // NOTE: THE TEMP IMAGE TRICK CANNOT BE DONE WITH data-multi-bg
    // BECAUSE INSIDE ITS VALUES MUST BE WRAPPED WITH URL() AND ONE OF THEM
    // COULD BE A GRADIENT BACKGROUND IMAGE
  
    var setMultiBackground = function setMultiBackground(element, settings, instance) {
      var bg1xValue = getData(element, settings.data_bg_multi);
      var bgHiDpiValue = getData(element, settings.data_bg_multi_hidpi);
      var bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
  
      if (!bgDataValue) {
        return;
      }
  
      element.style.backgroundImage = bgDataValue;
      manageApplied(element, settings, instance);
    };
    var setSources = function setSources(element, settings) {
      var setSourcesFunction = setSourcesFunctions[element.tagName];
  
      if (!setSourcesFunction) {
        return;
      }
  
      setSourcesFunction(element, settings);
    };
    var manageApplied = function manageApplied(element, settings, instance) {
      addClass(element, settings.class_applied);
      setStatus(element, statusApplied);
  
      if (settings.unobserve_completed) {
        // Unobserve now because we can't do it on load
        unobserve(element, settings);
      }
  
      safeCallback(settings.callback_applied, element, instance);
    };
    var manageLoading = function manageLoading(element, settings, instance) {
      updateLoadingCount(instance, +1);
      addClass(element, settings.class_loading);
      setStatus(element, statusLoading);
      safeCallback(settings.callback_loading, element, instance);
    };
  
    var elementsWithLoadEvent = ["IMG", "IFRAME", "VIDEO"];
    var hasLoadEvent = function hasLoadEvent(element) {
      return elementsWithLoadEvent.indexOf(element.tagName) > -1;
    };
    var checkFinish = function checkFinish(settings, instance) {
      if (instance && !isSomethingLoading(instance) && !haveElementsToLoad(instance)) {
        safeCallback(settings.callback_finish, instance);
      }
    };
    var addEventListener = function addEventListener(element, eventName, handler) {
      element.addEventListener(eventName, handler);
      element.llEvLisnrs[eventName] = handler;
    };
    var removeEventListener = function removeEventListener(element, eventName, handler) {
      element.removeEventListener(eventName, handler);
    };
    var hasEventListeners = function hasEventListeners(element) {
      return !!element.llEvLisnrs;
    };
    var addEventListeners = function addEventListeners(element, loadHandler, errorHandler) {
      if (!hasEventListeners(element)) element.llEvLisnrs = {};
      var loadEventName = element.tagName === "VIDEO" ? "loadeddata" : "load";
      addEventListener(element, loadEventName, loadHandler);
      addEventListener(element, "error", errorHandler);
    };
    var removeEventListeners = function removeEventListeners(element) {
      if (!hasEventListeners(element)) {
        return;
      }
  
      var eventListeners = element.llEvLisnrs;
  
      for (var eventName in eventListeners) {
        var handler = eventListeners[eventName];
        removeEventListener(element, eventName, handler);
      }
  
      delete element.llEvLisnrs;
    };
    var doneHandler = function doneHandler(element, settings, instance) {
      deleteTempImage(element);
      updateLoadingCount(instance, -1);
      decreaseToLoadCount(instance);
      removeClass(element, settings.class_loading);
  
      if (settings.unobserve_completed) {
        unobserve(element, instance);
      }
    };
    var loadHandler = function loadHandler(event, element, settings, instance) {
      var goingNative = hasStatusNative(element);
      doneHandler(element, settings, instance);
      addClass(element, settings.class_loaded);
      setStatus(element, statusLoaded);
      safeCallback(settings.callback_loaded, element, instance);
      if (!goingNative) checkFinish(settings, instance);
    };
    var errorHandler = function errorHandler(event, element, settings, instance) {
      var goingNative = hasStatusNative(element);
      doneHandler(element, settings, instance);
      addClass(element, settings.class_error);
      setStatus(element, statusError);
      safeCallback(settings.callback_error, element, instance);
      if (!goingNative) checkFinish(settings, instance);
    };
    var addOneShotEventListeners = function addOneShotEventListeners(element, settings, instance) {
      var elementToListenTo = getTempImage(element) || element;
  
      if (hasEventListeners(elementToListenTo)) {
        // This happens when loading is retried twice
        return;
      }
  
      var _loadHandler = function _loadHandler(event) {
        loadHandler(event, element, settings, instance);
        removeEventListeners(elementToListenTo);
      };
  
      var _errorHandler = function _errorHandler(event) {
        errorHandler(event, element, settings, instance);
        removeEventListeners(elementToListenTo);
      };
  
      addEventListeners(elementToListenTo, _loadHandler, _errorHandler);
    };
  
    var loadBackground = function loadBackground(element, settings, instance) {
      addTempImage(element);
      addOneShotEventListeners(element, settings, instance);
      setBackground(element, settings, instance);
      setMultiBackground(element, settings, instance);
    };
  
    var loadRegular = function loadRegular(element, settings, instance) {
      addOneShotEventListeners(element, settings, instance);
      setSources(element, settings);
      manageLoading(element, settings, instance);
    };
  
    var load = function load(element, settings, instance) {
      if (hasLoadEvent(element)) {
        loadRegular(element, settings, instance);
      } else {
        loadBackground(element, settings, instance);
      }
    };
    var loadNative = function loadNative(element, settings, instance) {
      element.setAttribute("loading", "lazy");
      addOneShotEventListeners(element, settings, instance);
      setSources(element, settings);
      setStatus(element, statusNative);
    };
  
    var cancelLoading = function cancelLoading(element, entry, settings, instance) {
      if (!settings.cancel_on_exit) return;
      if (!hasStatusLoading(element)) return;
      if (element.tagName !== "IMG") return; //Works only on images
  
      removeEventListeners(element);
      resetSourcesImg(element);
      restoreOriginalAttributesImg(element);
      removeClass(element, settings.class_loading);
      updateLoadingCount(instance, -1);
      resetStatus(element);
      safeCallback(settings.callback_cancel, element, entry, instance);
    };
  
    var onEnter = function onEnter(element, entry, settings, instance) {
      var dontLoad = hadStartedLoading(element);
      /* Save status 
      before setting it, to prevent loading it again. Fixes #526. */
  
      setStatus(element, statusEntered);
      addClass(element, settings.class_entered);
      removeClass(element, settings.class_exited);
      unobserveEntered(element, settings, instance);
      safeCallback(settings.callback_enter, element, entry, instance);
      if (dontLoad) return;
      load(element, settings, instance);
    };
    var onExit = function onExit(element, entry, settings, instance) {
      if (hasEmptyStatus(element)) return; //Ignore the first pass, at landing
  
      addClass(element, settings.class_exited);
      cancelLoading(element, entry, settings, instance);
      safeCallback(settings.callback_exit, element, entry, instance);
    };
  
    var tagsWithNativeLazy = ["IMG", "IFRAME", "VIDEO"];
    var shouldUseNative = function shouldUseNative(settings) {
      return settings.use_native && "loading" in HTMLImageElement.prototype;
    };
    var loadAllNative = function loadAllNative(elements, settings, instance) {
      elements.forEach(function (element) {
        if (tagsWithNativeLazy.indexOf(element.tagName) === -1) {
          return;
        }
  
        loadNative(element, settings, instance);
      });
      setToLoadCount(instance, 0);
    };
  
    var isIntersecting = function isIntersecting(entry) {
      return entry.isIntersecting || entry.intersectionRatio > 0;
    };
  
    var getObserverSettings = function getObserverSettings(settings) {
      return {
        root: settings.container === document ? null : settings.container,
        rootMargin: settings.thresholds || settings.threshold + "px"
      };
    };
  
    var intersectionHandler = function intersectionHandler(entries, settings, instance) {
      entries.forEach(function (entry) {
        return isIntersecting(entry) ? onEnter(entry.target, entry, settings, instance) : onExit(entry.target, entry, settings, instance);
      });
    };
  
    var observeElements = function observeElements(observer, elements) {
      elements.forEach(function (element) {
        observer.observe(element);
      });
    };
    var updateObserver = function updateObserver(observer, elementsToObserve) {
      resetObserver(observer);
      observeElements(observer, elementsToObserve);
    };
    var setObserver = function setObserver(settings, instance) {
      if (!supportsIntersectionObserver || shouldUseNative(settings)) {
        return;
      }
  
      instance._observer = new IntersectionObserver(function (entries) {
        intersectionHandler(entries, settings, instance);
      }, getObserverSettings(settings));
    };
  
    var toArray = function toArray(nodeSet) {
      return Array.prototype.slice.call(nodeSet);
    };
    var queryElements = function queryElements(settings) {
      return settings.container.querySelectorAll(settings.elements_selector);
    };
    var excludeManagedElements = function excludeManagedElements(elements) {
      return toArray(elements).filter(hasEmptyStatus);
    };
    var hasError = function hasError(element) {
      return hasStatusError(element);
    };
    var filterErrorElements = function filterErrorElements(elements) {
      return toArray(elements).filter(hasError);
    };
    var getElementsToLoad = function getElementsToLoad(elements, settings) {
      return excludeManagedElements(elements || queryElements(settings));
    };
  
    var retryLazyLoad = function retryLazyLoad(settings, instance) {
      var errorElements = filterErrorElements(queryElements(settings));
      errorElements.forEach(function (element) {
        removeClass(element, settings.class_error);
        resetStatus(element);
      });
      instance.update();
    };
    var setOnlineCheck = function setOnlineCheck(settings, instance) {
      if (!runningOnBrowser) {
        return;
      }
  
      window.addEventListener("online", function () {
        retryLazyLoad(settings, instance);
      });
    };
  
    var LazyLoad = function LazyLoad(customSettings, elements) {
      var settings = getExtendedSettings(customSettings);
      this._settings = settings;
      this.loadingCount = 0;
      setObserver(settings, this);
      setOnlineCheck(settings, this);
      this.update(elements);
    };
  
    LazyLoad.prototype = {
      update: function update(givenNodeset) {
        var settings = this._settings;
        var elementsToLoad = getElementsToLoad(givenNodeset, settings);
        setToLoadCount(this, elementsToLoad.length);
  
        if (isBot || !supportsIntersectionObserver) {
          this.loadAll(elementsToLoad);
          return;
        }
  
        if (shouldUseNative(settings)) {
          loadAllNative(elementsToLoad, settings, this);
          return;
        }
  
        updateObserver(this._observer, elementsToLoad);
      },
      destroy: function destroy() {
        // Observer
        if (this._observer) {
          this._observer.disconnect();
        } // Clean custom attributes on elements
  
  
        queryElements(this._settings).forEach(function (element) {
          delete element.llOriginalAttrs;
        }); // Delete all internal props
  
        delete this._observer;
        delete this._settings;
        delete this.loadingCount;
        delete this.toLoadCount;
      },
      loadAll: function loadAll(elements) {
        var _this = this;
  
        var settings = this._settings;
        var elementsToLoad = getElementsToLoad(elements, settings);
        elementsToLoad.forEach(function (element) {
          unobserve(element, _this);
          load(element, settings, _this);
        });
      }
    };
  
    LazyLoad.load = function (element, customSettings) {
      var settings = getExtendedSettings(customSettings);
      load(element, settings);
    };
  
    LazyLoad.resetStatus = function (element) {
      resetStatus(element);
    }; // Automatic instances creation if required (useful for async script loading)
  
  
    if (runningOnBrowser) {
      autoInitialize(LazyLoad, window.lazyLoadOptions);
    }
  
    return LazyLoad;
  
  })));
typeof navigator === "object" && (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define('Plyr', factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Plyr = factory());
  })(this, (function () { 'use strict';
  
    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
  
      return obj;
    }
  
    function _classCallCheck(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
  
    function _defineProperties(e, t) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
      }
    }
  
    function _createClass(e, t, n) {
      return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e;
    }
  
    function _defineProperty(e, t, n) {
      return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[t] = n, e;
    }
  
    function ownKeys(e, t) {
      var n = Object.keys(e);
  
      if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function (t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })), n.push.apply(n, r);
      }
  
      return n;
    }
  
    function _objectSpread2(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? ownKeys(Object(n), !0).forEach(function (t) {
          _defineProperty(e, t, n[t]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ownKeys(Object(n)).forEach(function (t) {
          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
        });
      }
  
      return e;
    }
  
    var defaults$1 = {
      addCSS: !0,
      thumbWidth: 15,
      watch: !0
    };
  
    function matches$1(e, t) {
      return function () {
        return Array.from(document.querySelectorAll(t)).includes(this);
      }.call(e, t);
    }
  
    function trigger(e, t) {
      if (e && t) {
        var n = new Event(t, {
          bubbles: !0
        });
        e.dispatchEvent(n);
      }
    }
  
    var getConstructor$1 = function (e) {
      return null != e ? e.constructor : null;
    },
        instanceOf$1 = function (e, t) {
      return !!(e && t && e instanceof t);
    },
        isNullOrUndefined$1 = function (e) {
      return null == e;
    },
        isObject$1 = function (e) {
      return getConstructor$1(e) === Object;
    },
        isNumber$1 = function (e) {
      return getConstructor$1(e) === Number && !Number.isNaN(e);
    },
        isString$1 = function (e) {
      return getConstructor$1(e) === String;
    },
        isBoolean$1 = function (e) {
      return getConstructor$1(e) === Boolean;
    },
        isFunction$1 = function (e) {
      return getConstructor$1(e) === Function;
    },
        isArray$1 = function (e) {
      return Array.isArray(e);
    },
        isNodeList$1 = function (e) {
      return instanceOf$1(e, NodeList);
    },
        isElement$1 = function (e) {
      return instanceOf$1(e, Element);
    },
        isEvent$1 = function (e) {
      return instanceOf$1(e, Event);
    },
        isEmpty$1 = function (e) {
      return isNullOrUndefined$1(e) || (isString$1(e) || isArray$1(e) || isNodeList$1(e)) && !e.length || isObject$1(e) && !Object.keys(e).length;
    },
        is$1 = {
      nullOrUndefined: isNullOrUndefined$1,
      object: isObject$1,
      number: isNumber$1,
      string: isString$1,
      boolean: isBoolean$1,
      function: isFunction$1,
      array: isArray$1,
      nodeList: isNodeList$1,
      element: isElement$1,
      event: isEvent$1,
      empty: isEmpty$1
    };
  
    function getDecimalPlaces(e) {
      var t = "".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
      return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0;
    }
  
    function round(e, t) {
      if (1 > t) {
        var n = getDecimalPlaces(t);
        return parseFloat(e.toFixed(n));
      }
  
      return Math.round(e / t) * t;
    }
  
    var RangeTouch = function () {
      function e(t, n) {
        _classCallCheck(this, e), is$1.element(t) ? this.element = t : is$1.string(t) && (this.element = document.querySelector(t)), is$1.element(this.element) && is$1.empty(this.element.rangeTouch) && (this.config = _objectSpread2({}, defaults$1, {}, n), this.init());
      }
  
      return _createClass(e, [{
        key: "init",
        value: function () {
          e.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this);
        }
      }, {
        key: "destroy",
        value: function () {
          e.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null);
        }
      }, {
        key: "listeners",
        value: function (e) {
          var t = this,
              n = e ? "addEventListener" : "removeEventListener";
          ["touchstart", "touchmove", "touchend"].forEach(function (e) {
            t.element[n](e, function (e) {
              return t.set(e);
            }, !1);
          });
        }
      }, {
        key: "get",
        value: function (t) {
          if (!e.enabled || !is$1.event(t)) return null;
          var n,
              r = t.target,
              i = t.changedTouches[0],
              o = parseFloat(r.getAttribute("min")) || 0,
              s = parseFloat(r.getAttribute("max")) || 100,
              u = parseFloat(r.getAttribute("step")) || 1,
              c = r.getBoundingClientRect(),
              a = 100 / c.width * (this.config.thumbWidth / 2) / 100;
          return 0 > (n = 100 / c.width * (i.clientX - c.left)) ? n = 0 : 100 < n && (n = 100), 50 > n ? n -= (100 - 2 * n) * a : 50 < n && (n += 2 * (n - 50) * a), o + round(n / 100 * (s - o), u);
        }
      }, {
        key: "set",
        value: function (t) {
          e.enabled && is$1.event(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), trigger(t.target, "touchend" === t.type ? "change" : "input"));
        }
      }], [{
        key: "setup",
        value: function (t) {
          var n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
              r = null;
          if (is$1.empty(t) || is$1.string(t) ? r = Array.from(document.querySelectorAll(is$1.string(t) ? t : 'input[type="range"]')) : is$1.element(t) ? r = [t] : is$1.nodeList(t) ? r = Array.from(t) : is$1.array(t) && (r = t.filter(is$1.element)), is$1.empty(r)) return null;
  
          var i = _objectSpread2({}, defaults$1, {}, n);
  
          if (is$1.string(t) && i.watch) {
            var o = new MutationObserver(function (n) {
              Array.from(n).forEach(function (n) {
                Array.from(n.addedNodes).forEach(function (n) {
                  is$1.element(n) && matches$1(n, t) && new e(n, i);
                });
              });
            });
            o.observe(document.body, {
              childList: !0,
              subtree: !0
            });
          }
  
          return r.map(function (t) {
            return new e(t, n);
          });
        }
      }, {
        key: "enabled",
        get: function () {
          return "ontouchstart" in document.documentElement;
        }
      }]), e;
    }();
  
    // ==========================================================================
    // Type checking utils
    // ==========================================================================
    const getConstructor = input => input !== null && typeof input !== 'undefined' ? input.constructor : null;
  
    const instanceOf = (input, constructor) => Boolean(input && constructor && input instanceof constructor);
  
    const isNullOrUndefined = input => input === null || typeof input === 'undefined';
  
    const isObject = input => getConstructor(input) === Object;
  
    const isNumber = input => getConstructor(input) === Number && !Number.isNaN(input);
  
    const isString = input => getConstructor(input) === String;
  
    const isBoolean = input => getConstructor(input) === Boolean;
  
    const isFunction = input => getConstructor(input) === Function;
  
    const isArray = input => Array.isArray(input);
  
    const isWeakMap = input => instanceOf(input, WeakMap);
  
    const isNodeList = input => instanceOf(input, NodeList);
  
    const isTextNode = input => getConstructor(input) === Text;
  
    const isEvent = input => instanceOf(input, Event);
  
    const isKeyboardEvent = input => instanceOf(input, KeyboardEvent);
  
    const isCue = input => instanceOf(input, window.TextTrackCue) || instanceOf(input, window.VTTCue);
  
    const isTrack = input => instanceOf(input, TextTrack) || !isNullOrUndefined(input) && isString(input.kind);
  
    const isPromise = input => instanceOf(input, Promise) && isFunction(input.then);
  
    const isElement = input => input !== null && typeof input === 'object' && input.nodeType === 1 && typeof input.style === 'object' && typeof input.ownerDocument === 'object';
  
    const isEmpty = input => isNullOrUndefined(input) || (isString(input) || isArray(input) || isNodeList(input)) && !input.length || isObject(input) && !Object.keys(input).length;
  
    const isUrl = input => {
      // Accept a URL object
      if (instanceOf(input, window.URL)) {
        return true;
      } // Must be string from here
  
  
      if (!isString(input)) {
        return false;
      } // Add the protocol if required
  
  
      let string = input;
  
      if (!input.startsWith('http://') || !input.startsWith('https://')) {
        string = `http://${input}`;
      }
  
      try {
        return !isEmpty(new URL(string).hostname);
      } catch (_) {
        return false;
      }
    };
  
    var is = {
      nullOrUndefined: isNullOrUndefined,
      object: isObject,
      number: isNumber,
      string: isString,
      boolean: isBoolean,
      function: isFunction,
      array: isArray,
      weakMap: isWeakMap,
      nodeList: isNodeList,
      element: isElement,
      textNode: isTextNode,
      event: isEvent,
      keyboardEvent: isKeyboardEvent,
      cue: isCue,
      track: isTrack,
      promise: isPromise,
      url: isUrl,
      empty: isEmpty
    };
  
    // ==========================================================================
    const transitionEndEvent = (() => {
      const element = document.createElement('span');
      const events = {
        WebkitTransition: 'webkitTransitionEnd',
        MozTransition: 'transitionend',
        OTransition: 'oTransitionEnd otransitionend',
        transition: 'transitionend'
      };
      const type = Object.keys(events).find(event => element.style[event] !== undefined);
      return is.string(type) ? events[type] : false;
    })(); // Force repaint of element
  
    function repaint(element, delay) {
      setTimeout(() => {
        try {
          // eslint-disable-next-line no-param-reassign
          element.hidden = true; // eslint-disable-next-line no-unused-expressions
  
          element.offsetHeight; // eslint-disable-next-line no-param-reassign
  
          element.hidden = false;
        } catch (_) {// Do nothing
        }
      }, delay);
    }
  
    // ==========================================================================
    // Browser sniffing
    // Unfortunately, due to mixed support, UA sniffing is required
    // ==========================================================================
    const browser = {
      isIE: Boolean(window.document.documentMode),
      isEdge: window.navigator.userAgent.includes('Edge'),
      isWebkit: 'WebkitAppearance' in document.documentElement.style && !/Edge/.test(navigator.userAgent),
      isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),
      isIos: navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 || /(iPad|iPhone|iPod)/gi.test(navigator.platform)
    };
  
    // ==========================================================================
  
    function cloneDeep(object) {
      return JSON.parse(JSON.stringify(object));
    } // Get a nested value in an object
  
    function getDeep(object, path) {
      return path.split('.').reduce((obj, key) => obj && obj[key], object);
    } // Deep extend destination object with N more objects
  
    function extend(target = {}, ...sources) {
      if (!sources.length) {
        return target;
      }
  
      const source = sources.shift();
  
      if (!is.object(source)) {
        return target;
      }
  
      Object.keys(source).forEach(key => {
        if (is.object(source[key])) {
          if (!Object.keys(target).includes(key)) {
            Object.assign(target, {
              [key]: {}
            });
          }
  
          extend(target[key], source[key]);
        } else {
          Object.assign(target, {
            [key]: source[key]
          });
        }
      });
      return extend(target, ...sources);
    }
  
    // ==========================================================================
  
    function wrap(elements, wrapper) {
      // Convert `elements` to an array, if necessary.
      const targets = elements.length ? elements : [elements]; // Loops backwards to prevent having to clone the wrapper on the
      // first element (see `child` below).
  
      Array.from(targets).reverse().forEach((element, index) => {
        const child = index > 0 ? wrapper.cloneNode(true) : wrapper; // Cache the current parent and sibling.
  
        const parent = element.parentNode;
        const sibling = element.nextSibling; // Wrap the element (is automatically removed from its current
        // parent).
  
        child.appendChild(element); // If the element had a sibling, insert the wrapper before
        // the sibling to maintain the HTML structure; otherwise, just
        // append it to the parent.
  
        if (sibling) {
          parent.insertBefore(child, sibling);
        } else {
          parent.appendChild(child);
        }
      });
    } // Set attributes
  
    function setAttributes(element, attributes) {
      if (!is.element(element) || is.empty(attributes)) {
        return;
      } // Assume null and undefined attributes should be left out,
      // Setting them would otherwise convert them to "null" and "undefined"
  
  
      Object.entries(attributes).filter(([, value]) => !is.nullOrUndefined(value)).forEach(([key, value]) => element.setAttribute(key, value));
    } // Create a DocumentFragment
  
    function createElement(type, attributes, text) {
      // Create a new <element>
      const element = document.createElement(type); // Set all passed attributes
  
      if (is.object(attributes)) {
        setAttributes(element, attributes);
      } // Add text node
  
  
      if (is.string(text)) {
        element.innerText = text;
      } // Return built element
  
  
      return element;
    } // Inaert an element after another
  
    function insertAfter(element, target) {
      if (!is.element(element) || !is.element(target)) {
        return;
      }
  
      target.parentNode.insertBefore(element, target.nextSibling);
    } // Insert a DocumentFragment
  
    function insertElement(type, parent, attributes, text) {
      if (!is.element(parent)) {
        return;
      }
  
      parent.appendChild(createElement(type, attributes, text));
    } // Remove element(s)
  
    function removeElement(element) {
      if (is.nodeList(element) || is.array(element)) {
        Array.from(element).forEach(removeElement);
        return;
      }
  
      if (!is.element(element) || !is.element(element.parentNode)) {
        return;
      }
  
      element.parentNode.removeChild(element);
    } // Remove all child elements
  
    function emptyElement(element) {
      if (!is.element(element)) {
        return;
      }
  
      let {
        length
      } = element.childNodes;
  
      while (length > 0) {
        element.removeChild(element.lastChild);
        length -= 1;
      }
    } // Replace element
  
    function replaceElement(newChild, oldChild) {
      if (!is.element(oldChild) || !is.element(oldChild.parentNode) || !is.element(newChild)) {
        return null;
      }
  
      oldChild.parentNode.replaceChild(newChild, oldChild);
      return newChild;
    } // Get an attribute object from a string selector
  
    function getAttributesFromSelector(sel, existingAttributes) {
      // For example:
      // '.test' to { class: 'test' }
      // '#test' to { id: 'test' }
      // '[data-test="test"]' to { 'data-test': 'test' }
      if (!is.string(sel) || is.empty(sel)) {
        return {};
      }
  
      const attributes = {};
      const existing = extend({}, existingAttributes);
      sel.split(',').forEach(s => {
        // Remove whitespace
        const selector = s.trim();
        const className = selector.replace('.', '');
        const stripped = selector.replace(/[[\]]/g, ''); // Get the parts and value
  
        const parts = stripped.split('=');
        const [key] = parts;
        const value = parts.length > 1 ? parts[1].replace(/["']/g, '') : ''; // Get the first character
  
        const start = selector.charAt(0);
  
        switch (start) {
          case '.':
            // Add to existing classname
            if (is.string(existing.class)) {
              attributes.class = `${existing.class} ${className}`;
            } else {
              attributes.class = className;
            }
  
            break;
  
          case '#':
            // ID selector
            attributes.id = selector.replace('#', '');
            break;
  
          case '[':
            // Attribute selector
            attributes[key] = value;
            break;
        }
      });
      return extend(existing, attributes);
    } // Toggle hidden
  
    function toggleHidden(element, hidden) {
      if (!is.element(element)) {
        return;
      }
  
      let hide = hidden;
  
      if (!is.boolean(hide)) {
        hide = !element.hidden;
      } // eslint-disable-next-line no-param-reassign
  
  
      element.hidden = hide;
    } // Mirror Element.classList.toggle, with IE compatibility for "force" argument
  
    function toggleClass(element, className, force) {
      if (is.nodeList(element)) {
        return Array.from(element).map(e => toggleClass(e, className, force));
      }
  
      if (is.element(element)) {
        let method = 'toggle';
  
        if (typeof force !== 'undefined') {
          method = force ? 'add' : 'remove';
        }
  
        element.classList[method](className);
        return element.classList.contains(className);
      }
  
      return false;
    } // Has class name
  
    function hasClass(element, className) {
      return is.element(element) && element.classList.contains(className);
    } // Element matches selector
  
    function matches(element, selector) {
      const {
        prototype
      } = Element;
  
      function match() {
        return Array.from(document.querySelectorAll(selector)).includes(this);
      }
  
      const method = prototype.matches || prototype.webkitMatchesSelector || prototype.mozMatchesSelector || prototype.msMatchesSelector || match;
      return method.call(element, selector);
    } // Closest ancestor element matching selector (also tests element itself)
  
    function closest$1(element, selector) {
      const {
        prototype
      } = Element; // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
  
      function closestElement() {
        let el = this;
  
        do {
          if (matches.matches(el, selector)) return el;
          el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
  
        return null;
      }
  
      const method = prototype.closest || closestElement;
      return method.call(element, selector);
    } // Find all elements
  
    function getElements(selector) {
      return this.elements.container.querySelectorAll(selector);
    } // Find a single element
  
    function getElement(selector) {
      return this.elements.container.querySelector(selector);
    } // Set focus and tab focus class
  
    function setFocus(element = null, tabFocus = false) {
      if (!is.element(element)) {
        return;
      } // Set regular focus
  
  
      element.focus({
        preventScroll: true
      }); // If we want to mimic keyboard focus via tab
  
      if (tabFocus) {
        toggleClass(element, this.config.classNames.tabFocus);
      }
    }
  
    // ==========================================================================
  
    const defaultCodecs = {
      'audio/ogg': 'vorbis',
      'audio/wav': '1',
      'video/webm': 'vp8, vorbis',
      'video/mp4': 'avc1.42E01E, mp4a.40.2',
      'video/ogg': 'theora'
    }; // Check for feature support
  
    const support = {
      // Basic support
      audio: 'canPlayType' in document.createElement('audio'),
      video: 'canPlayType' in document.createElement('video'),
  
      // Check for support
      // Basic functionality vs full UI
      check(type, provider, playsinline) {
        const canPlayInline = browser.isIPhone && playsinline && support.playsinline;
        const api = support[type] || provider !== 'html5';
        const ui = api && support.rangeInput && (type !== 'video' || !browser.isIPhone || canPlayInline);
        return {
          api,
          ui
        };
      },
  
      // Picture-in-picture support
      // Safari & Chrome only currently
      pip: (() => {
        if (browser.isIPhone) {
          return false;
        } // Safari
        // https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls
  
  
        if (is.function(createElement('video').webkitSetPresentationMode)) {
          return true;
        } // Chrome
        // https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture
  
  
        if (document.pictureInPictureEnabled && !createElement('video').disablePictureInPicture) {
          return true;
        }
  
        return false;
      })(),
      // Airplay support
      // Safari only currently
      airplay: is.function(window.WebKitPlaybackTargetAvailabilityEvent),
      // Inline playback support
      // https://webkit.org/blog/6784/new-video-policies-for-ios/
      playsinline: 'playsInline' in document.createElement('video'),
  
      // Check for mime type support against a player instance
      // Credits: http://diveintohtml5.info/everything.html
      // Related: http://www.leanbackplayer.com/test/h5mt.html
      mime(input) {
        if (is.empty(input)) {
          return false;
        }
  
        const [mediaType] = input.split('/');
        let type = input; // Verify we're using HTML5 and there's no media type mismatch
  
        if (!this.isHTML5 || mediaType !== this.type) {
          return false;
        } // Add codec if required
  
  
        if (Object.keys(defaultCodecs).includes(type)) {
          type += `; codecs="${defaultCodecs[input]}"`;
        }
  
        try {
          return Boolean(type && this.media.canPlayType(type).replace(/no/, ''));
        } catch (_) {
          return false;
        }
      },
  
      // Check for textTracks support
      textTracks: 'textTracks' in document.createElement('video'),
      // <input type="range"> Sliders
      rangeInput: (() => {
        const range = document.createElement('input');
        range.type = 'range';
        return range.type === 'range';
      })(),
      // Touch
      // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event
      touch: 'ontouchstart' in document.documentElement,
      // Detect transitions support
      transitions: transitionEndEvent !== false,
      // Reduced motion iOS & MacOS setting
      // https://webkit.org/blog/7551/responsive-design-for-motion/
      reducedMotion: 'matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches
    };
  
    // ==========================================================================
    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // https://www.youtube.com/watch?v=NPM6172J22g
  
    const supportsPassiveListeners = (() => {
      // Test via a getter in the options object to see if the passive property is accessed
      let supported = false;
  
      try {
        const options = Object.defineProperty({}, 'passive', {
          get() {
            supported = true;
            return null;
          }
  
        });
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
      } catch (_) {// Do nothing
      }
  
      return supported;
    })(); // Toggle event listener
  
  
    function toggleListener(element, event, callback, toggle = false, passive = true, capture = false) {
      // Bail if no element, event, or callback
      if (!element || !('addEventListener' in element) || is.empty(event) || !is.function(callback)) {
        return;
      } // Allow multiple events
  
  
      const events = event.split(' '); // Build options
      // Default to just the capture boolean for browsers with no passive listener support
  
      let options = capture; // If passive events listeners are supported
  
      if (supportsPassiveListeners) {
        options = {
          // Whether the listener can be passive (i.e. default never prevented)
          passive,
          // Whether the listener is a capturing listener or not
          capture
        };
      } // If a single node is passed, bind the event listener
  
  
      events.forEach(type => {
        if (this && this.eventListeners && toggle) {
          // Cache event listener
          this.eventListeners.push({
            element,
            type,
            callback,
            options
          });
        }
  
        element[toggle ? 'addEventListener' : 'removeEventListener'](type, callback, options);
      });
    } // Bind event handler
  
    function on(element, events = '', callback, passive = true, capture = false) {
      toggleListener.call(this, element, events, callback, true, passive, capture);
    } // Unbind event handler
  
    function off(element, events = '', callback, passive = true, capture = false) {
      toggleListener.call(this, element, events, callback, false, passive, capture);
    } // Bind once-only event handler
  
    function once(element, events = '', callback, passive = true, capture = false) {
      const onceCallback = (...args) => {
        off(element, events, onceCallback, passive, capture);
        callback.apply(this, args);
      };
  
      toggleListener.call(this, element, events, onceCallback, true, passive, capture);
    } // Trigger event
  
    function triggerEvent(element, type = '', bubbles = false, detail = {}) {
      // Bail if no element
      if (!is.element(element) || is.empty(type)) {
        return;
      } // Create and dispatch the event
  
  
      const event = new CustomEvent(type, {
        bubbles,
        detail: { ...detail,
          plyr: this
        }
      }); // Dispatch the event
  
      element.dispatchEvent(event);
    } // Unbind all cached event listeners
  
    function unbindListeners() {
      if (this && this.eventListeners) {
        this.eventListeners.forEach(item => {
          const {
            element,
            type,
            callback,
            options
          } = item;
          element.removeEventListener(type, callback, options);
        });
        this.eventListeners = [];
      }
    } // Run method when / if player is ready
  
    function ready() {
      return new Promise(resolve => this.ready ? setTimeout(resolve, 0) : on.call(this, this.elements.container, 'ready', resolve)).then(() => {});
    }
  
    /**
     * Silence a Promise-like object.
     * This is useful for avoiding non-harmful, but potentially confusing "uncaught
     * play promise" rejection error messages.
     * @param  {Object} value An object that may or may not be `Promise`-like.
     */
  
    function silencePromise(value) {
      if (is.promise(value)) {
        value.then(null, () => {});
      }
    }
  
    // ==========================================================================
  
    function dedupe(array) {
      if (!is.array(array)) {
        return array;
      }
  
      return array.filter((item, index) => array.indexOf(item) === index);
    } // Get the closest value in an array
  
    function closest(array, value) {
      if (!is.array(array) || !array.length) {
        return null;
      }
  
      return array.reduce((prev, curr) => Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
    }
  
    // ==========================================================================
  
    function supportsCSS(declaration) {
      if (!window || !window.CSS) {
        return false;
      }
  
      return window.CSS.supports(declaration);
    } // Standard/common aspect ratios
  
    const standardRatios = [[1, 1], [4, 3], [3, 4], [5, 4], [4, 5], [3, 2], [2, 3], [16, 10], [10, 16], [16, 9], [9, 16], [21, 9], [9, 21], [32, 9], [9, 32]].reduce((out, [x, y]) => ({ ...out,
      [x / y]: [x, y]
    }), {}); // Validate an aspect ratio
  
    function validateAspectRatio(input) {
      if (!is.array(input) && (!is.string(input) || !input.includes(':'))) {
        return false;
      }
  
      const ratio = is.array(input) ? input : input.split(':');
      return ratio.map(Number).every(is.number);
    } // Reduce an aspect ratio to it's lowest form
  
    function reduceAspectRatio(ratio) {
      if (!is.array(ratio) || !ratio.every(is.number)) {
        return null;
      }
  
      const [width, height] = ratio;
  
      const getDivider = (w, h) => h === 0 ? w : getDivider(h, w % h);
  
      const divider = getDivider(width, height);
      return [width / divider, height / divider];
    } // Calculate an aspect ratio
  
    function getAspectRatio(input) {
      const parse = ratio => validateAspectRatio(ratio) ? ratio.split(':').map(Number) : null; // Try provided ratio
  
  
      let ratio = parse(input); // Get from config
  
      if (ratio === null) {
        ratio = parse(this.config.ratio);
      } // Get from embed
  
  
      if (ratio === null && !is.empty(this.embed) && is.array(this.embed.ratio)) {
        ({
          ratio
        } = this.embed);
      } // Get from HTML5 video
  
  
      if (ratio === null && this.isHTML5) {
        const {
          videoWidth,
          videoHeight
        } = this.media;
        ratio = [videoWidth, videoHeight];
      }
  
      return reduceAspectRatio(ratio);
    } // Set aspect ratio for responsive container
  
    function setAspectRatio(input) {
      if (!this.isVideo) {
        return {};
      }
  
      const {
        wrapper
      } = this.elements;
      const ratio = getAspectRatio.call(this, input);
  
      if (!is.array(ratio)) {
        return {};
      }
  
      const [x, y] = reduceAspectRatio(ratio);
      const useNative = supportsCSS(`aspect-ratio: ${x}/${y}`);
      const padding = 100 / x * y;
  
      if (useNative) {
        wrapper.style.aspectRatio = `${x}/${y}`;
      } else {
        wrapper.style.paddingBottom = `${padding}%`;
      } // For Vimeo we have an extra <div> to hide the standard controls and UI
  
  
      if (this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
        const height = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10);
        const offset = (height - padding) / (height / 50);
  
        if (this.fullscreen.active) {
          wrapper.style.paddingBottom = null;
        } else {
          this.media.style.transform = `translateY(-${offset}%)`;
        }
      } else if (this.isHTML5) {
        wrapper.classList.add(this.config.classNames.videoFixedRatio);
      }
  
      return {
        padding,
        ratio
      };
    } // Round an aspect ratio to closest standard ratio
  
    function roundAspectRatio(x, y, tolerance = 0.05) {
      const ratio = x / y;
      const closestRatio = closest(Object.keys(standardRatios), ratio); // Check match is within tolerance
  
      if (Math.abs(closestRatio - ratio) <= tolerance) {
        return standardRatios[closestRatio];
      } // No match
  
  
      return [x, y];
    } // Get the size of the viewport
    // https://stackoverflow.com/questions/1248081/how-to-get-the-browser-viewport-dimensions
  
    function getViewportSize() {
      const width = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
      const height = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
      return [width, height];
    }
  
    // ==========================================================================
    const html5 = {
      getSources() {
        if (!this.isHTML5) {
          return [];
        }
  
        const sources = Array.from(this.media.querySelectorAll('source')); // Filter out unsupported sources (if type is specified)
  
        return sources.filter(source => {
          const type = source.getAttribute('type');
  
          if (is.empty(type)) {
            return true;
          }
  
          return support.mime.call(this, type);
        });
      },
  
      // Get quality levels
      getQualityOptions() {
        // Whether we're forcing all options (e.g. for streaming)
        if (this.config.quality.forced) {
          return this.config.quality.options;
        } // Get sizes from <source> elements
  
  
        return html5.getSources.call(this).map(source => Number(source.getAttribute('size'))).filter(Boolean);
      },
  
      setup() {
        if (!this.isHTML5) {
          return;
        }
  
        const player = this; // Set speed options from config
  
        player.options.speed = player.config.speed.options; // Set aspect ratio if fixed
  
        if (!is.empty(this.config.ratio)) {
          setAspectRatio.call(player);
        } // Quality
  
  
        Object.defineProperty(player.media, 'quality', {
          get() {
            // Get sources
            const sources = html5.getSources.call(player);
            const source = sources.find(s => s.getAttribute('src') === player.source); // Return size, if match is found
  
            return source && Number(source.getAttribute('size'));
          },
  
          set(input) {
            if (player.quality === input) {
              return;
            } // If we're using an external handler...
  
  
            if (player.config.quality.forced && is.function(player.config.quality.onChange)) {
              player.config.quality.onChange(input);
            } else {
              // Get sources
              const sources = html5.getSources.call(player); // Get first match for requested size
  
              const source = sources.find(s => Number(s.getAttribute('size')) === input); // No matching source found
  
              if (!source) {
                return;
              } // Get current state
  
  
              const {
                currentTime,
                paused,
                preload,
                readyState,
                playbackRate
              } = player.media; // Set new source
  
              player.media.src = source.getAttribute('src'); // Prevent loading if preload="none" and the current source isn't loaded (#1044)
  
              if (preload !== 'none' || readyState) {
                // Restore time
                player.once('loadedmetadata', () => {
                  player.speed = playbackRate;
                  player.currentTime = currentTime; // Resume playing
  
                  if (!paused) {
                    silencePromise(player.play());
                  }
                }); // Load new source
  
                player.media.load();
              }
            } // Trigger change event
  
  
            triggerEvent.call(player, player.media, 'qualitychange', false, {
              quality: input
            });
          }
  
        });
      },
  
      // Cancel current network requests
      // See https://github.com/sampotts/plyr/issues/174
      cancelRequests() {
        if (!this.isHTML5) {
          return;
        } // Remove child sources
  
  
        removeElement(html5.getSources.call(this)); // Set blank video src attribute
        // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error
        // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection
  
        this.media.setAttribute('src', this.config.blankVideo); // Load the new empty source
        // This will cancel existing requests
        // See https://github.com/sampotts/plyr/issues/174
  
        this.media.load(); // Debugging
  
        this.debug.log('Cancelled network requests');
      }
  
    };
  
    // ==========================================================================
  
    function generateId(prefix) {
      return `${prefix}-${Math.floor(Math.random() * 10000)}`;
    } // Format string
  
    function format(input, ...args) {
      if (is.empty(input)) return input;
      return input.toString().replace(/{(\d+)}/g, (match, i) => args[i].toString());
    } // Get percentage
  
    function getPercentage(current, max) {
      if (current === 0 || max === 0 || Number.isNaN(current) || Number.isNaN(max)) {
        return 0;
      }
  
      return (current / max * 100).toFixed(2);
    } // Replace all occurrences of a string in a string
  
    const replaceAll = (input = '', find = '', replace = '') => input.replace(new RegExp(find.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'), 'g'), replace.toString()); // Convert to title case
  
    const toTitleCase = (input = '') => input.toString().replace(/\w\S*/g, text => text.charAt(0).toUpperCase() + text.slice(1).toLowerCase()); // Convert string to pascalCase
  
    function toPascalCase(input = '') {
      let string = input.toString(); // Convert kebab case
  
      string = replaceAll(string, '-', ' '); // Convert snake case
  
      string = replaceAll(string, '_', ' '); // Convert to title case
  
      string = toTitleCase(string); // Convert to pascal case
  
      return replaceAll(string, ' ', '');
    } // Convert string to pascalCase
  
    function toCamelCase(input = '') {
      let string = input.toString(); // Convert to pascal case
  
      string = toPascalCase(string); // Convert first character to lowercase
  
      return string.charAt(0).toLowerCase() + string.slice(1);
    } // Remove HTML from a string
  
    function stripHTML(source) {
      const fragment = document.createDocumentFragment();
      const element = document.createElement('div');
      fragment.appendChild(element);
      element.innerHTML = source;
      return fragment.firstChild.innerText;
    } // Like outerHTML, but also works for DocumentFragment
  
    function getHTML(element) {
      const wrapper = document.createElement('div');
      wrapper.appendChild(element);
      return wrapper.innerHTML;
    }
  
    // ==========================================================================
  
    const resources = {
      pip: 'PIP',
      airplay: 'AirPlay',
      html5: 'HTML5',
      vimeo: 'Vimeo',
      youtube: 'YouTube'
    };
    const i18n = {
      get(key = '', config = {}) {
        if (is.empty(key) || is.empty(config)) {
          return '';
        }
  
        let string = getDeep(config.i18n, key);
  
        if (is.empty(string)) {
          if (Object.keys(resources).includes(key)) {
            return resources[key];
          }
  
          return '';
        }
  
        const replace = {
          '{seektime}': config.seekTime,
          '{title}': config.title
        };
        Object.entries(replace).forEach(([k, v]) => {
          string = replaceAll(string, k, v);
        });
        return string;
      }
  
    };
  
    class Storage {
      constructor(player) {
        _defineProperty$1(this, "get", key => {
          if (!Storage.supported || !this.enabled) {
            return null;
          }
  
          const store = window.localStorage.getItem(this.key);
  
          if (is.empty(store)) {
            return null;
          }
  
          const json = JSON.parse(store);
          return is.string(key) && key.length ? json[key] : json;
        });
  
        _defineProperty$1(this, "set", object => {
          // Bail if we don't have localStorage support or it's disabled
          if (!Storage.supported || !this.enabled) {
            return;
          } // Can only store objectst
  
  
          if (!is.object(object)) {
            return;
          } // Get current storage
  
  
          let storage = this.get(); // Default to empty object
  
          if (is.empty(storage)) {
            storage = {};
          } // Update the working copy of the values
  
  
          extend(storage, object); // Update storage
  
          try {
            window.localStorage.setItem(this.key, JSON.stringify(storage));
          } catch (_) {// Do nothing
          }
        });
  
        this.enabled = player.config.storage.enabled;
        this.key = player.config.storage.key;
      } // Check for actual support (see if we can use it)
  
  
      static get supported() {
        try {
          if (!('localStorage' in window)) {
            return false;
          }
  
          const test = '___test'; // Try to use it (it might be disabled, e.g. user is in private mode)
          // see: https://github.com/sampotts/plyr/issues/131
  
          window.localStorage.setItem(test, test);
          window.localStorage.removeItem(test);
          return true;
        } catch (_) {
          return false;
        }
      }
  
    }
  
    // ==========================================================================
    // Fetch wrapper
    // Using XHR to avoid issues with older browsers
    // ==========================================================================
    function fetch(url, responseType = 'text') {
      return new Promise((resolve, reject) => {
        try {
          const request = new XMLHttpRequest(); // Check for CORS support
  
          if (!('withCredentials' in request)) {
            return;
          }
  
          request.addEventListener('load', () => {
            if (responseType === 'text') {
              try {
                resolve(JSON.parse(request.responseText));
              } catch (_) {
                resolve(request.responseText);
              }
            } else {
              resolve(request.response);
            }
          });
          request.addEventListener('error', () => {
            throw new Error(request.status);
          });
          request.open('GET', url, true); // Set the required response type
  
          request.responseType = responseType;
          request.send();
        } catch (error) {
          reject(error);
        }
      });
    }
  
    // ==========================================================================
  
    function loadSprite(url, id) {
      if (!is.string(url)) {
        return;
      }
  
      const prefix = 'cache';
      const hasId = is.string(id);
      let isCached = false;
  
      const exists = () => document.getElementById(id) !== null;
  
      const update = (container, data) => {
        // eslint-disable-next-line no-param-reassign
        container.innerHTML = data; // Check again incase of race condition
  
        if (hasId && exists()) {
          return;
        } // Inject the SVG to the body
  
  
        document.body.insertAdjacentElement('afterbegin', container);
      }; // Only load once if ID set
  
  
      if (!hasId || !exists()) {
        const useStorage = Storage.supported; // Create container
  
        const container = document.createElement('div');
        container.setAttribute('hidden', '');
  
        if (hasId) {
          container.setAttribute('id', id);
        } // Check in cache
  
  
        if (useStorage) {
          const cached = window.localStorage.getItem(`${prefix}-${id}`);
          isCached = cached !== null;
  
          if (isCached) {
            const data = JSON.parse(cached);
            update(container, data.content);
          }
        } // Get the sprite
  
  
        fetch(url).then(result => {
          if (is.empty(result)) {
            return;
          }
  
          if (useStorage) {
            try {
              window.localStorage.setItem(`${prefix}-${id}`, JSON.stringify({
                content: result
              }));
            } catch (_) {// Do nothing
            }
          }
  
          update(container, result);
        }).catch(() => {});
      }
    }
  
    // ==========================================================================
  
    const getHours = value => Math.trunc(value / 60 / 60 % 60, 10);
    const getMinutes = value => Math.trunc(value / 60 % 60, 10);
    const getSeconds = value => Math.trunc(value % 60, 10); // Format time to UI friendly string
  
    function formatTime(time = 0, displayHours = false, inverted = false) {
      // Bail if the value isn't a number
      if (!is.number(time)) {
        return formatTime(undefined, displayHours, inverted);
      } // Format time component to add leading zero
  
  
      const format = value => `0${value}`.slice(-2); // Breakdown to hours, mins, secs
  
  
      let hours = getHours(time);
      const mins = getMinutes(time);
      const secs = getSeconds(time); // Do we need to display hours?
  
      if (displayHours || hours > 0) {
        hours = `${hours}:`;
      } else {
        hours = '';
      } // Render
  
  
      return `${inverted && time > 0 ? '-' : ''}${hours}${format(mins)}:${format(secs)}`;
    }
  
    // ==========================================================================
  
    const controls = {
      // Get icon URL
      getIconUrl() {
        const url = new URL(this.config.iconUrl, window.location);
        const host = window.location.host ? window.location.host : window.top.location.host;
        const cors = url.host !== host || browser.isIE && !window.svg4everybody;
        return {
          url: this.config.iconUrl,
          cors
        };
      },
  
      // Find the UI controls
      findElements() {
        try {
          this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper); // Buttons
  
          this.elements.buttons = {
            play: getElements.call(this, this.config.selectors.buttons.play),
            pause: getElement.call(this, this.config.selectors.buttons.pause),
            restart: getElement.call(this, this.config.selectors.buttons.restart),
            rewind: getElement.call(this, this.config.selectors.buttons.rewind),
            fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),
            mute: getElement.call(this, this.config.selectors.buttons.mute),
            pip: getElement.call(this, this.config.selectors.buttons.pip),
            airplay: getElement.call(this, this.config.selectors.buttons.airplay),
            settings: getElement.call(this, this.config.selectors.buttons.settings),
            captions: getElement.call(this, this.config.selectors.buttons.captions),
            fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen)
          }; // Progress
  
          this.elements.progress = getElement.call(this, this.config.selectors.progress); // Inputs
  
          this.elements.inputs = {
            seek: getElement.call(this, this.config.selectors.inputs.seek),
            volume: getElement.call(this, this.config.selectors.inputs.volume)
          }; // Display
  
          this.elements.display = {
            buffer: getElement.call(this, this.config.selectors.display.buffer),
            currentTime: getElement.call(this, this.config.selectors.display.currentTime),
            duration: getElement.call(this, this.config.selectors.display.duration)
          }; // Seek tooltip
  
          if (is.element(this.elements.progress)) {
            this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`);
          }
  
          return true;
        } catch (error) {
          // Log it
          this.debug.warn('It looks like there is a problem with your custom controls HTML', error); // Restore native video controls
  
          this.toggleNativeControls(true);
          return false;
        }
      },
  
      // Create <svg> icon
      createIcon(type, attributes) {
        const namespace = 'http://www.w3.org/2000/svg';
        const iconUrl = controls.getIconUrl.call(this);
        const iconPath = `${!iconUrl.cors ? iconUrl.url : ''}#${this.config.iconPrefix}`; // Create <svg>
  
        const icon = document.createElementNS(namespace, 'svg');
        setAttributes(icon, extend(attributes, {
          'aria-hidden': 'true',
          focusable: 'false'
        })); // Create the <use> to reference sprite
  
        const use = document.createElementNS(namespace, 'use');
        const path = `${iconPath}-${type}`; // Set `href` attributes
        // https://github.com/sampotts/plyr/issues/460
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href
  
        if ('href' in use) {
          use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
        } // Always set the older attribute even though it's "deprecated" (it'll be around for ages)
  
  
        use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path); // Add <use> to <svg>
  
        icon.appendChild(use);
        return icon;
      },
  
      // Create hidden text label
      createLabel(key, attr = {}) {
        const text = i18n.get(key, this.config);
        const attributes = { ...attr,
          class: [attr.class, this.config.classNames.hidden].filter(Boolean).join(' ')
        };
        return createElement('span', attributes, text);
      },
  
      // Create a badge
      createBadge(text) {
        if (is.empty(text)) {
          return null;
        }
  
        const badge = createElement('span', {
          class: this.config.classNames.menu.value
        });
        badge.appendChild(createElement('span', {
          class: this.config.classNames.menu.badge
        }, text));
        return badge;
      },
  
      // Create a <button>
      createButton(buttonType, attr) {
        const attributes = extend({}, attr);
        let type = toCamelCase(buttonType);
        const props = {
          element: 'button',
          toggle: false,
          label: null,
          icon: null,
          labelPressed: null,
          iconPressed: null
        };
        ['element', 'icon', 'label'].forEach(key => {
          if (Object.keys(attributes).includes(key)) {
            props[key] = attributes[key];
            delete attributes[key];
          }
        }); // Default to 'button' type to prevent form submission
  
        if (props.element === 'button' && !Object.keys(attributes).includes('type')) {
          attributes.type = 'button';
        } // Set class name
  
  
        if (Object.keys(attributes).includes('class')) {
          if (!attributes.class.split(' ').some(c => c === this.config.classNames.control)) {
            extend(attributes, {
              class: `${attributes.class} ${this.config.classNames.control}`
            });
          }
        } else {
          attributes.class = this.config.classNames.control;
        } // Large play button
  
  
        switch (buttonType) {
          case 'play':
            props.toggle = true;
            props.label = 'play';
            props.labelPressed = 'pause';
            props.icon = 'play';
            props.iconPressed = 'pause';
            break;
  
          case 'mute':
            props.toggle = true;
            props.label = 'mute';
            props.labelPressed = 'unmute';
            props.icon = 'volume';
            props.iconPressed = 'muted';
            break;
  
          case 'captions':
            props.toggle = true;
            props.label = 'enableCaptions';
            props.labelPressed = 'disableCaptions';
            props.icon = 'captions-off';
            props.iconPressed = 'captions-on';
            break;
  
          case 'fullscreen':
            props.toggle = true;
            props.label = 'enterFullscreen';
            props.labelPressed = 'exitFullscreen';
            props.icon = 'enter-fullscreen';
            props.iconPressed = 'exit-fullscreen';
            break;
  
          case 'play-large':
            attributes.class += ` ${this.config.classNames.control}--overlaid`;
            type = 'play';
            props.label = 'play';
            props.icon = 'play';
            break;
  
          default:
            if (is.empty(props.label)) {
              props.label = type;
            }
  
            if (is.empty(props.icon)) {
              props.icon = buttonType;
            }
  
        }
  
        const button = createElement(props.element); // Setup toggle icon and labels
  
        if (props.toggle) {
          // Icon
          button.appendChild(controls.createIcon.call(this, props.iconPressed, {
            class: 'icon--pressed'
          }));
          button.appendChild(controls.createIcon.call(this, props.icon, {
            class: 'icon--not-pressed'
          })); // Label/Tooltip
  
          button.appendChild(controls.createLabel.call(this, props.labelPressed, {
            class: 'label--pressed'
          }));
          button.appendChild(controls.createLabel.call(this, props.label, {
            class: 'label--not-pressed'
          }));
        } else {
          button.appendChild(controls.createIcon.call(this, props.icon));
          button.appendChild(controls.createLabel.call(this, props.label));
        } // Merge and set attributes
  
  
        extend(attributes, getAttributesFromSelector(this.config.selectors.buttons[type], attributes));
        setAttributes(button, attributes); // We have multiple play buttons
  
        if (type === 'play') {
          if (!is.array(this.elements.buttons[type])) {
            this.elements.buttons[type] = [];
          }
  
          this.elements.buttons[type].push(button);
        } else {
          this.elements.buttons[type] = button;
        }
  
        return button;
      },
  
      // Create an <input type='range'>
      createRange(type, attributes) {
        // Seek input
        const input = createElement('input', extend(getAttributesFromSelector(this.config.selectors.inputs[type]), {
          type: 'range',
          min: 0,
          max: 100,
          step: 0.01,
          value: 0,
          autocomplete: 'off',
          // A11y fixes for https://github.com/sampotts/plyr/issues/905
          role: 'slider',
          'aria-label': i18n.get(type, this.config),
          'aria-valuemin': 0,
          'aria-valuemax': 100,
          'aria-valuenow': 0
        }, attributes));
        this.elements.inputs[type] = input; // Set the fill for webkit now
  
        controls.updateRangeFill.call(this, input); // Improve support on touch devices
  
        RangeTouch.setup(input);
        return input;
      },
  
      // Create a <progress>
      createProgress(type, attributes) {
        const progress = createElement('progress', extend(getAttributesFromSelector(this.config.selectors.display[type]), {
          min: 0,
          max: 100,
          value: 0,
          role: 'progressbar',
          'aria-hidden': true
        }, attributes)); // Create the label inside
  
        if (type !== 'volume') {
          progress.appendChild(createElement('span', null, '0'));
          const suffixKey = {
            played: 'played',
            buffer: 'buffered'
          }[type];
          const suffix = suffixKey ? i18n.get(suffixKey, this.config) : '';
          progress.innerText = `% ${suffix.toLowerCase()}`;
        }
  
        this.elements.display[type] = progress;
        return progress;
      },
  
      // Create time display
      createTime(type, attrs) {
        const attributes = getAttributesFromSelector(this.config.selectors.display[type], attrs);
        const container = createElement('div', extend(attributes, {
          class: `${attributes.class ? attributes.class : ''} ${this.config.classNames.display.time} `.trim(),
          'aria-label': i18n.get(type, this.config)
        }), '00:00'); // Reference for updates
  
        this.elements.display[type] = container;
        return container;
      },
  
      // Bind keyboard shortcuts for a menu item
      // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
      bindMenuItemShortcuts(menuItem, type) {
        // Navigate through menus via arrow keys and space
        on.call(this, menuItem, 'keydown keyup', event => {
          // We only care about space and ⬆️ ⬇️️ ➡️
          if (!['Space', 'ArrowUp', 'ArrowDown', 'ArrowRight'].includes(event.key)) {
            return;
          } // Prevent play / seek
  
  
          event.preventDefault();
          event.stopPropagation(); // We're just here to prevent the keydown bubbling
  
          if (event.type === 'keydown') {
            return;
          }
  
          const isRadioButton = matches(menuItem, '[role="menuitemradio"]'); // Show the respective menu
  
          if (!isRadioButton && ['Space', 'ArrowRight'].includes(event.key)) {
            controls.showMenuPanel.call(this, type, true);
          } else {
            let target;
  
            if (event.key !== 'Space') {
              if (event.key === 'ArrowDown' || isRadioButton && event.key === 'ArrowRight') {
                target = menuItem.nextElementSibling;
  
                if (!is.element(target)) {
                  target = menuItem.parentNode.firstElementChild;
                }
              } else {
                target = menuItem.previousElementSibling;
  
                if (!is.element(target)) {
                  target = menuItem.parentNode.lastElementChild;
                }
              }
  
              setFocus.call(this, target, true);
            }
          }
        }, false); // Enter will fire a `click` event but we still need to manage focus
        // So we bind to keyup which fires after and set focus here
  
        on.call(this, menuItem, 'keyup', event => {
          if (event.key !== 'Return') return;
          controls.focusFirstMenuItem.call(this, null, true);
        });
      },
  
      // Create a settings menu item
      createMenuItem({
        value,
        list,
        type,
        title,
        badge = null,
        checked = false
      }) {
        const attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);
        const menuItem = createElement('button', extend(attributes, {
          type: 'button',
          role: 'menuitemradio',
          class: `${this.config.classNames.control} ${attributes.class ? attributes.class : ''}`.trim(),
          'aria-checked': checked,
          value
        }));
        const flex = createElement('span'); // We have to set as HTML incase of special characters
  
        flex.innerHTML = title;
  
        if (is.element(badge)) {
          flex.appendChild(badge);
        }
  
        menuItem.appendChild(flex); // Replicate radio button behavior
  
        Object.defineProperty(menuItem, 'checked', {
          enumerable: true,
  
          get() {
            return menuItem.getAttribute('aria-checked') === 'true';
          },
  
          set(check) {
            // Ensure exclusivity
            if (check) {
              Array.from(menuItem.parentNode.children).filter(node => matches(node, '[role="menuitemradio"]')).forEach(node => node.setAttribute('aria-checked', 'false'));
            }
  
            menuItem.setAttribute('aria-checked', check ? 'true' : 'false');
          }
  
        });
        this.listeners.bind(menuItem, 'click keyup', event => {
          if (is.keyboardEvent(event) && event.key !== 'Space') {
            return;
          }
  
          event.preventDefault();
          event.stopPropagation();
          menuItem.checked = true;
  
          switch (type) {
            case 'language':
              this.currentTrack = Number(value);
              break;
  
            case 'quality':
              this.quality = value;
              break;
  
            case 'speed':
              this.speed = parseFloat(value);
              break;
          }
  
          controls.showMenuPanel.call(this, 'home', is.keyboardEvent(event));
        }, type, false);
        controls.bindMenuItemShortcuts.call(this, menuItem, type);
        list.appendChild(menuItem);
      },
  
      // Format a time for display
      formatTime(time = 0, inverted = false) {
        // Bail if the value isn't a number
        if (!is.number(time)) {
          return time;
        } // Always display hours if duration is over an hour
  
  
        const forceHours = getHours(this.duration) > 0;
        return formatTime(time, forceHours, inverted);
      },
  
      // Update the displayed time
      updateTimeDisplay(target = null, time = 0, inverted = false) {
        // Bail if there's no element to display or the value isn't a number
        if (!is.element(target) || !is.number(time)) {
          return;
        } // eslint-disable-next-line no-param-reassign
  
  
        target.innerText = controls.formatTime(time, inverted);
      },
  
      // Update volume UI and storage
      updateVolume() {
        if (!this.supported.ui) {
          return;
        } // Update range
  
  
        if (is.element(this.elements.inputs.volume)) {
          controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume);
        } // Update mute state
  
  
        if (is.element(this.elements.buttons.mute)) {
          this.elements.buttons.mute.pressed = this.muted || this.volume === 0;
        }
      },
  
      // Update seek value and lower fill
      setRange(target, value = 0) {
        if (!is.element(target)) {
          return;
        } // eslint-disable-next-line
  
  
        target.value = value; // Webkit range fill
  
        controls.updateRangeFill.call(this, target);
      },
  
      // Update <progress> elements
      updateProgress(event) {
        if (!this.supported.ui || !is.event(event)) {
          return;
        }
  
        let value = 0;
  
        const setProgress = (target, input) => {
          const val = is.number(input) ? input : 0;
          const progress = is.element(target) ? target : this.elements.display.buffer; // Update value and label
  
          if (is.element(progress)) {
            progress.value = val; // Update text label inside
  
            const label = progress.getElementsByTagName('span')[0];
  
            if (is.element(label)) {
              label.childNodes[0].nodeValue = val;
            }
          }
        };
  
        if (event) {
          switch (event.type) {
            // Video playing
            case 'timeupdate':
            case 'seeking':
            case 'seeked':
              value = getPercentage(this.currentTime, this.duration); // Set seek range value only if it's a 'natural' time event
  
              if (event.type === 'timeupdate') {
                controls.setRange.call(this, this.elements.inputs.seek, value);
              }
  
              break;
            // Check buffer status
  
            case 'playing':
            case 'progress':
              setProgress(this.elements.display.buffer, this.buffered * 100);
              break;
          }
        }
      },
  
      // Webkit polyfill for lower fill range
      updateRangeFill(target) {
        // Get range from event if event passed
        const range = is.event(target) ? target.target : target; // Needs to be a valid <input type='range'>
  
        if (!is.element(range) || range.getAttribute('type') !== 'range') {
          return;
        } // Set aria values for https://github.com/sampotts/plyr/issues/905
  
  
        if (matches(range, this.config.selectors.inputs.seek)) {
          range.setAttribute('aria-valuenow', this.currentTime);
          const currentTime = controls.formatTime(this.currentTime);
          const duration = controls.formatTime(this.duration);
          const format = i18n.get('seekLabel', this.config);
          range.setAttribute('aria-valuetext', format.replace('{currentTime}', currentTime).replace('{duration}', duration));
        } else if (matches(range, this.config.selectors.inputs.volume)) {
          const percent = range.value * 100;
          range.setAttribute('aria-valuenow', percent);
          range.setAttribute('aria-valuetext', `${percent.toFixed(1)}%`);
        } else {
          range.setAttribute('aria-valuenow', range.value);
        } // WebKit only
  
  
        if (!browser.isWebkit) {
          return;
        } // Set CSS custom property
  
  
        range.style.setProperty('--value', `${range.value / range.max * 100}%`);
      },
  
      // Update hover tooltip for seeking
      updateSeekTooltip(event) {
        var _this$config$markers, _this$config$markers$;
  
        // Bail if setting not true
        if (!this.config.tooltips.seek || !is.element(this.elements.inputs.seek) || !is.element(this.elements.display.seekTooltip) || this.duration === 0) {
          return;
        }
  
        const tipElement = this.elements.display.seekTooltip;
        const visible = `${this.config.classNames.tooltip}--visible`;
  
        const toggle = show => toggleClass(tipElement, visible, show); // Hide on touch
  
  
        if (this.touch) {
          toggle(false);
          return;
        } // Determine percentage, if already visible
  
  
        let percent = 0;
        const clientRect = this.elements.progress.getBoundingClientRect();
  
        if (is.event(event)) {
          percent = 100 / clientRect.width * (event.pageX - clientRect.left);
        } else if (hasClass(tipElement, visible)) {
          percent = parseFloat(tipElement.style.left, 10);
        } else {
          return;
        } // Set bounds
  
  
        if (percent < 0) {
          percent = 0;
        } else if (percent > 100) {
          percent = 100;
        }
  
        const time = this.duration / 100 * percent; // Display the time a click would seek to
  
        tipElement.innerText = controls.formatTime(time); // Get marker point for time
  
        const point = (_this$config$markers = this.config.markers) === null || _this$config$markers === void 0 ? void 0 : (_this$config$markers$ = _this$config$markers.points) === null || _this$config$markers$ === void 0 ? void 0 : _this$config$markers$.find(({
          time: t
        }) => t === Math.round(time)); // Append the point label to the tooltip
  
        if (point) {
          tipElement.insertAdjacentHTML('afterbegin', `${point.label}<br>`);
        } // Set position
  
  
        tipElement.style.left = `${percent}%`; // Show/hide the tooltip
        // If the event is a moues in/out and percentage is inside bounds
  
        if (is.event(event) && ['mouseenter', 'mouseleave'].includes(event.type)) {
          toggle(event.type === 'mouseenter');
        }
      },
  
      // Handle time change event
      timeUpdate(event) {
        // Only invert if only one time element is displayed and used for both duration and currentTime
        const invert = !is.element(this.elements.display.duration) && this.config.invertTime; // Duration
  
        controls.updateTimeDisplay.call(this, this.elements.display.currentTime, invert ? this.duration - this.currentTime : this.currentTime, invert); // Ignore updates while seeking
  
        if (event && event.type === 'timeupdate' && this.media.seeking) {
          return;
        } // Playing progress
  
  
        controls.updateProgress.call(this, event);
      },
  
      // Show the duration on metadataloaded or durationchange events
      durationUpdate() {
        // Bail if no UI or durationchange event triggered after playing/seek when invertTime is false
        if (!this.supported.ui || !this.config.invertTime && this.currentTime) {
          return;
        } // If duration is the 2**32 (shaka), Infinity (HLS), DASH-IF (Number.MAX_SAFE_INTEGER || Number.MAX_VALUE) indicating live we hide the currentTime and progressbar.
        // https://github.com/video-dev/hls.js/blob/5820d29d3c4c8a46e8b75f1e3afa3e68c1a9a2db/src/controller/buffer-controller.js#L415
        // https://github.com/google/shaka-player/blob/4d889054631f4e1cf0fbd80ddd2b71887c02e232/lib/media/streaming_engine.js#L1062
        // https://github.com/Dash-Industry-Forum/dash.js/blob/69859f51b969645b234666800d4cb596d89c602d/src/dash/models/DashManifestModel.js#L338
  
  
        if (this.duration >= 2 ** 32) {
          toggleHidden(this.elements.display.currentTime, true);
          toggleHidden(this.elements.progress, true);
          return;
        } // Update ARIA values
  
  
        if (is.element(this.elements.inputs.seek)) {
          this.elements.inputs.seek.setAttribute('aria-valuemax', this.duration);
        } // If there's a spot to display duration
  
  
        const hasDuration = is.element(this.elements.display.duration); // If there's only one time display, display duration there
  
        if (!hasDuration && this.config.displayDuration && this.paused) {
          controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration);
        } // If there's a duration element, update content
  
  
        if (hasDuration) {
          controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration);
        }
  
        if (this.config.markers.enabled) {
          controls.setMarkers.call(this);
        } // Update the tooltip (if visible)
  
  
        controls.updateSeekTooltip.call(this);
      },
  
      // Hide/show a tab
      toggleMenuButton(setting, toggle) {
        toggleHidden(this.elements.settings.buttons[setting], !toggle);
      },
  
      // Update the selected setting
      updateSetting(setting, container, input) {
        const pane = this.elements.settings.panels[setting];
        let value = null;
        let list = container;
  
        if (setting === 'captions') {
          value = this.currentTrack;
        } else {
          value = !is.empty(input) ? input : this[setting]; // Get default
  
          if (is.empty(value)) {
            value = this.config[setting].default;
          } // Unsupported value
  
  
          if (!is.empty(this.options[setting]) && !this.options[setting].includes(value)) {
            this.debug.warn(`Unsupported value of '${value}' for ${setting}`);
            return;
          } // Disabled value
  
  
          if (!this.config[setting].options.includes(value)) {
            this.debug.warn(`Disabled value of '${value}' for ${setting}`);
            return;
          }
        } // Get the list if we need to
  
  
        if (!is.element(list)) {
          list = pane && pane.querySelector('[role="menu"]');
        } // If there's no list it means it's not been rendered...
  
  
        if (!is.element(list)) {
          return;
        } // Update the label
  
  
        const label = this.elements.settings.buttons[setting].querySelector(`.${this.config.classNames.menu.value}`);
        label.innerHTML = controls.getLabel.call(this, setting, value); // Find the radio option and check it
  
        const target = list && list.querySelector(`[value="${value}"]`);
  
        if (is.element(target)) {
          target.checked = true;
        }
      },
  
      // Translate a value into a nice label
      getLabel(setting, value) {
        switch (setting) {
          case 'speed':
            return value === 1 ? i18n.get('normal', this.config) : `${value}&times;`;
  
          case 'quality':
            if (is.number(value)) {
              const label = i18n.get(`qualityLabel.${value}`, this.config);
  
              if (!label.length) {
                return `${value}p`;
              }
  
              return label;
            }
  
            return toTitleCase(value);
  
          case 'captions':
            return captions.getLabel.call(this);
  
          default:
            return null;
        }
      },
  
      // Set the quality menu
      setQualityMenu(options) {
        // Menu required
        if (!is.element(this.elements.settings.panels.quality)) {
          return;
        }
  
        const type = 'quality';
        const list = this.elements.settings.panels.quality.querySelector('[role="menu"]'); // Set options if passed and filter based on uniqueness and config
  
        if (is.array(options)) {
          this.options.quality = dedupe(options).filter(quality => this.config.quality.options.includes(quality));
        } // Toggle the pane and tab
  
  
        const toggle = !is.empty(this.options.quality) && this.options.quality.length > 1;
        controls.toggleMenuButton.call(this, type, toggle); // Empty the menu
  
        emptyElement(list); // Check if we need to toggle the parent
  
        controls.checkMenu.call(this); // If we're hiding, nothing more to do
  
        if (!toggle) {
          return;
        } // Get the badge HTML for HD, 4K etc
  
  
        const getBadge = quality => {
          const label = i18n.get(`qualityBadge.${quality}`, this.config);
  
          if (!label.length) {
            return null;
          }
  
          return controls.createBadge.call(this, label);
        }; // Sort options by the config and then render options
  
  
        this.options.quality.sort((a, b) => {
          const sorting = this.config.quality.options;
          return sorting.indexOf(a) > sorting.indexOf(b) ? 1 : -1;
        }).forEach(quality => {
          controls.createMenuItem.call(this, {
            value: quality,
            list,
            type,
            title: controls.getLabel.call(this, 'quality', quality),
            badge: getBadge(quality)
          });
        });
        controls.updateSetting.call(this, type, list);
      },
  
      // Set the looping options
  
      /* setLoopMenu() {
            // Menu required
            if (!is.element(this.elements.settings.panels.loop)) {
                return;
            }
             const options = ['start', 'end', 'all', 'reset'];
            const list = this.elements.settings.panels.loop.querySelector('[role="menu"]');
             // Show the pane and tab
            toggleHidden(this.elements.settings.buttons.loop, false);
            toggleHidden(this.elements.settings.panels.loop, false);
             // Toggle the pane and tab
            const toggle = !is.empty(this.loop.options);
            controls.toggleMenuButton.call(this, 'loop', toggle);
             // Empty the menu
            emptyElement(list);
             options.forEach(option => {
                const item = createElement('li');
                 const button = createElement(
                    'button',
                    extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {
                        type: 'button',
                        class: this.config.classNames.control,
                        'data-plyr-loop-action': option,
                    }),
                    i18n.get(option, this.config)
                );
                 if (['start', 'end'].includes(option)) {
                    const badge = controls.createBadge.call(this, '00:00');
                    button.appendChild(badge);
                }
                 item.appendChild(button);
                list.appendChild(item);
            });
        }, */
      // Get current selected caption language
      // TODO: rework this to user the getter in the API?
      // Set a list of available captions languages
      setCaptionsMenu() {
        // Menu required
        if (!is.element(this.elements.settings.panels.captions)) {
          return;
        } // TODO: Captions or language? Currently it's mixed
  
  
        const type = 'captions';
        const list = this.elements.settings.panels.captions.querySelector('[role="menu"]');
        const tracks = captions.getTracks.call(this);
        const toggle = Boolean(tracks.length); // Toggle the pane and tab
  
        controls.toggleMenuButton.call(this, type, toggle); // Empty the menu
  
        emptyElement(list); // Check if we need to toggle the parent
  
        controls.checkMenu.call(this); // If there's no captions, bail
  
        if (!toggle) {
          return;
        } // Generate options data
  
  
        const options = tracks.map((track, value) => ({
          value,
          checked: this.captions.toggled && this.currentTrack === value,
          title: captions.getLabel.call(this, track),
          badge: track.language && controls.createBadge.call(this, track.language.toUpperCase()),
          list,
          type: 'language'
        })); // Add the "Disabled" option to turn off captions
  
        options.unshift({
          value: -1,
          checked: !this.captions.toggled,
          title: i18n.get('disabled', this.config),
          list,
          type: 'language'
        }); // Generate options
  
        options.forEach(controls.createMenuItem.bind(this));
        controls.updateSetting.call(this, type, list);
      },
  
      // Set a list of available captions languages
      setSpeedMenu() {
        // Menu required
        if (!is.element(this.elements.settings.panels.speed)) {
          return;
        }
  
        const type = 'speed';
        const list = this.elements.settings.panels.speed.querySelector('[role="menu"]'); // Filter out invalid speeds
  
        this.options.speed = this.options.speed.filter(o => o >= this.minimumSpeed && o <= this.maximumSpeed); // Toggle the pane and tab
  
        const toggle = !is.empty(this.options.speed) && this.options.speed.length > 1;
        controls.toggleMenuButton.call(this, type, toggle); // Empty the menu
  
        emptyElement(list); // Check if we need to toggle the parent
  
        controls.checkMenu.call(this); // If we're hiding, nothing more to do
  
        if (!toggle) {
          return;
        } // Create items
  
  
        this.options.speed.forEach(speed => {
          controls.createMenuItem.call(this, {
            value: speed,
            list,
            type,
            title: controls.getLabel.call(this, 'speed', speed)
          });
        });
        controls.updateSetting.call(this, type, list);
      },
  
      // Check if we need to hide/show the settings menu
      checkMenu() {
        const {
          buttons
        } = this.elements.settings;
        const visible = !is.empty(buttons) && Object.values(buttons).some(button => !button.hidden);
        toggleHidden(this.elements.settings.menu, !visible);
      },
  
      // Focus the first menu item in a given (or visible) menu
      focusFirstMenuItem(pane, tabFocus = false) {
        if (this.elements.settings.popup.hidden) {
          return;
        }
  
        let target = pane;
  
        if (!is.element(target)) {
          target = Object.values(this.elements.settings.panels).find(p => !p.hidden);
        }
  
        const firstItem = target.querySelector('[role^="menuitem"]');
        setFocus.call(this, firstItem, tabFocus);
      },
  
      // Show/hide menu
      toggleMenu(input) {
        const {
          popup
        } = this.elements.settings;
        const button = this.elements.buttons.settings; // Menu and button are required
  
        if (!is.element(popup) || !is.element(button)) {
          return;
        } // True toggle by default
  
  
        const {
          hidden
        } = popup;
        let show = hidden;
  
        if (is.boolean(input)) {
          show = input;
        } else if (is.keyboardEvent(input) && input.key === 'Escape') {
          show = false;
        } else if (is.event(input)) {
          // If Plyr is in a shadowDOM, the event target is set to the component, instead of the
          // Element in the shadowDOM. The path, if available, is complete.
          const target = is.function(input.composedPath) ? input.composedPath()[0] : input.target;
          const isMenuItem = popup.contains(target); // If the click was inside the menu or if the click
          // wasn't the button or menu item and we're trying to
          // show the menu (a doc click shouldn't show the menu)
  
          if (isMenuItem || !isMenuItem && input.target !== button && show) {
            return;
          }
        } // Set button attributes
  
  
        button.setAttribute('aria-expanded', show); // Show the actual popup
  
        toggleHidden(popup, !show); // Add class hook
  
        toggleClass(this.elements.container, this.config.classNames.menu.open, show); // Focus the first item if key interaction
  
        if (show && is.keyboardEvent(input)) {
          controls.focusFirstMenuItem.call(this, null, true);
        } else if (!show && !hidden) {
          // If closing, re-focus the button
          setFocus.call(this, button, is.keyboardEvent(input));
        }
      },
  
      // Get the natural size of a menu panel
      getMenuSize(tab) {
        const clone = tab.cloneNode(true);
        clone.style.position = 'absolute';
        clone.style.opacity = 0;
        clone.removeAttribute('hidden'); // Append to parent so we get the "real" size
  
        tab.parentNode.appendChild(clone); // Get the sizes before we remove
  
        const width = clone.scrollWidth;
        const height = clone.scrollHeight; // Remove from the DOM
  
        removeElement(clone);
        return {
          width,
          height
        };
      },
  
      // Show a panel in the menu
      showMenuPanel(type = '', tabFocus = false) {
        const target = this.elements.container.querySelector(`#plyr-settings-${this.id}-${type}`); // Nothing to show, bail
  
        if (!is.element(target)) {
          return;
        } // Hide all other panels
  
  
        const container = target.parentNode;
        const current = Array.from(container.children).find(node => !node.hidden); // If we can do fancy animations, we'll animate the height/width
  
        if (support.transitions && !support.reducedMotion) {
          // Set the current width as a base
          container.style.width = `${current.scrollWidth}px`;
          container.style.height = `${current.scrollHeight}px`; // Get potential sizes
  
          const size = controls.getMenuSize.call(this, target); // Restore auto height/width
  
          const restore = event => {
            // We're only bothered about height and width on the container
            if (event.target !== container || !['width', 'height'].includes(event.propertyName)) {
              return;
            } // Revert back to auto
  
  
            container.style.width = '';
            container.style.height = ''; // Only listen once
  
            off.call(this, container, transitionEndEvent, restore);
          }; // Listen for the transition finishing and restore auto height/width
  
  
          on.call(this, container, transitionEndEvent, restore); // Set dimensions to target
  
          container.style.width = `${size.width}px`;
          container.style.height = `${size.height}px`;
        } // Set attributes on current tab
  
  
        toggleHidden(current, true); // Set attributes on target
  
        toggleHidden(target, false); // Focus the first item
  
        controls.focusFirstMenuItem.call(this, target, tabFocus);
      },
  
      // Set the download URL
      setDownloadUrl() {
        const button = this.elements.buttons.download; // Bail if no button
  
        if (!is.element(button)) {
          return;
        } // Set attribute
  
  
        button.setAttribute('href', this.download);
      },
  
      // Build the default HTML
      create(data) {
        const {
          bindMenuItemShortcuts,
          createButton,
          createProgress,
          createRange,
          createTime,
          setQualityMenu,
          setSpeedMenu,
          showMenuPanel
        } = controls;
        this.elements.controls = null; // Larger overlaid play button
  
        if (is.array(this.config.controls) && this.config.controls.includes('play-large')) {
          this.elements.container.appendChild(createButton.call(this, 'play-large'));
        } // Create the container
  
  
        const container = createElement('div', getAttributesFromSelector(this.config.selectors.controls.wrapper));
        this.elements.controls = container; // Default item attributes
  
        const defaultAttributes = {
          class: 'plyr__controls__item'
        }; // Loop through controls in order
  
        dedupe(is.array(this.config.controls) ? this.config.controls : []).forEach(control => {
          // Restart button
          if (control === 'restart') {
            container.appendChild(createButton.call(this, 'restart', defaultAttributes));
          } // Rewind button
  
  
          if (control === 'rewind') {
            container.appendChild(createButton.call(this, 'rewind', defaultAttributes));
          } // Play/Pause button
  
  
          if (control === 'play') {
            container.appendChild(createButton.call(this, 'play', defaultAttributes));
          } // Fast forward button
  
  
          if (control === 'fast-forward') {
            container.appendChild(createButton.call(this, 'fast-forward', defaultAttributes));
          } // Progress
  
  
          if (control === 'progress') {
            const progressContainer = createElement('div', {
              class: `${defaultAttributes.class} plyr__progress__container`
            });
            const progress = createElement('div', getAttributesFromSelector(this.config.selectors.progress)); // Seek range slider
  
            progress.appendChild(createRange.call(this, 'seek', {
              id: `plyr-seek-${data.id}`
            })); // Buffer progress
  
            progress.appendChild(createProgress.call(this, 'buffer')); // TODO: Add loop display indicator
            // Seek tooltip
  
            if (this.config.tooltips.seek) {
              const tooltip = createElement('span', {
                class: this.config.classNames.tooltip
              }, '00:00');
              progress.appendChild(tooltip);
              this.elements.display.seekTooltip = tooltip;
            }
  
            this.elements.progress = progress;
            progressContainer.appendChild(this.elements.progress);
            container.appendChild(progressContainer);
          } // Media current time display
  
  
          if (control === 'current-time') {
            container.appendChild(createTime.call(this, 'currentTime', defaultAttributes));
          } // Media duration display
  
  
          if (control === 'duration') {
            container.appendChild(createTime.call(this, 'duration', defaultAttributes));
          } // Volume controls
  
  
          if (control === 'mute' || control === 'volume') {
            let {
              volume
            } = this.elements; // Create the volume container if needed
  
            if (!is.element(volume) || !container.contains(volume)) {
              volume = createElement('div', extend({}, defaultAttributes, {
                class: `${defaultAttributes.class} plyr__volume`.trim()
              }));
              this.elements.volume = volume;
              container.appendChild(volume);
            } // Toggle mute button
  
  
            if (control === 'mute') {
              volume.appendChild(createButton.call(this, 'mute'));
            } // Volume range control
            // Ignored on iOS as it's handled globally
            // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html
  
  
            if (control === 'volume' && !browser.isIos) {
              // Set the attributes
              const attributes = {
                max: 1,
                step: 0.05,
                value: this.config.volume
              }; // Create the volume range slider
  
              volume.appendChild(createRange.call(this, 'volume', extend(attributes, {
                id: `plyr-volume-${data.id}`
              })));
            }
          } // Toggle captions button
  
  
          if (control === 'captions') {
            container.appendChild(createButton.call(this, 'captions', defaultAttributes));
          } // Settings button / menu
  
  
          if (control === 'settings' && !is.empty(this.config.settings)) {
            const wrapper = createElement('div', extend({}, defaultAttributes, {
              class: `${defaultAttributes.class} plyr__menu`.trim(),
              hidden: ''
            }));
            wrapper.appendChild(createButton.call(this, 'settings', {
              'aria-haspopup': true,
              'aria-controls': `plyr-settings-${data.id}`,
              'aria-expanded': false
            }));
            const popup = createElement('div', {
              class: 'plyr__menu__container',
              id: `plyr-settings-${data.id}`,
              hidden: ''
            });
            const inner = createElement('div');
            const home = createElement('div', {
              id: `plyr-settings-${data.id}-home`
            }); // Create the menu
  
            const menu = createElement('div', {
              role: 'menu'
            });
            home.appendChild(menu);
            inner.appendChild(home);
            this.elements.settings.panels.home = home; // Build the menu items
  
            this.config.settings.forEach(type => {
              // TODO: bundle this with the createMenuItem helper and bindings
              const menuItem = createElement('button', extend(getAttributesFromSelector(this.config.selectors.buttons.settings), {
                type: 'button',
                class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,
                role: 'menuitem',
                'aria-haspopup': true,
                hidden: ''
              })); // Bind menu shortcuts for keyboard users
  
              bindMenuItemShortcuts.call(this, menuItem, type); // Show menu on click
  
              on.call(this, menuItem, 'click', () => {
                showMenuPanel.call(this, type, false);
              });
              const flex = createElement('span', null, i18n.get(type, this.config));
              const value = createElement('span', {
                class: this.config.classNames.menu.value
              }); // Speed contains HTML entities
  
              value.innerHTML = data[type];
              flex.appendChild(value);
              menuItem.appendChild(flex);
              menu.appendChild(menuItem); // Build the panes
  
              const pane = createElement('div', {
                id: `plyr-settings-${data.id}-${type}`,
                hidden: ''
              }); // Back button
  
              const backButton = createElement('button', {
                type: 'button',
                class: `${this.config.classNames.control} ${this.config.classNames.control}--back`
              }); // Visible label
  
              backButton.appendChild(createElement('span', {
                'aria-hidden': true
              }, i18n.get(type, this.config))); // Screen reader label
  
              backButton.appendChild(createElement('span', {
                class: this.config.classNames.hidden
              }, i18n.get('menuBack', this.config))); // Go back via keyboard
  
              on.call(this, pane, 'keydown', event => {
                if (event.key !== 'ArrowLeft') return; // Prevent seek
  
                event.preventDefault();
                event.stopPropagation(); // Show the respective menu
  
                showMenuPanel.call(this, 'home', true);
              }, false); // Go back via button click
  
              on.call(this, backButton, 'click', () => {
                showMenuPanel.call(this, 'home', false);
              }); // Add to pane
  
              pane.appendChild(backButton); // Menu
  
              pane.appendChild(createElement('div', {
                role: 'menu'
              }));
              inner.appendChild(pane);
              this.elements.settings.buttons[type] = menuItem;
              this.elements.settings.panels[type] = pane;
            });
            popup.appendChild(inner);
            wrapper.appendChild(popup);
            container.appendChild(wrapper);
            this.elements.settings.popup = popup;
            this.elements.settings.menu = wrapper;
          } // Picture in picture button
  
  
          if (control === 'pip' && support.pip) {
            container.appendChild(createButton.call(this, 'pip', defaultAttributes));
          } // Airplay button
  
  
          if (control === 'airplay' && support.airplay) {
            container.appendChild(createButton.call(this, 'airplay', defaultAttributes));
          } // Download button
  
  
          if (control === 'download') {
            const attributes = extend({}, defaultAttributes, {
              element: 'a',
              href: this.download,
              target: '_blank'
            }); // Set download attribute for HTML5 only
  
            if (this.isHTML5) {
              attributes.download = '';
            }
  
            const {
              download
            } = this.config.urls;
  
            if (!is.url(download) && this.isEmbed) {
              extend(attributes, {
                icon: `logo-${this.provider}`,
                label: this.provider
              });
            }
  
            container.appendChild(createButton.call(this, 'download', attributes));
          } // Toggle fullscreen button
  
  
          if (control === 'fullscreen') {
            container.appendChild(createButton.call(this, 'fullscreen', defaultAttributes));
          }
        }); // Set available quality levels
  
        if (this.isHTML5) {
          setQualityMenu.call(this, html5.getQualityOptions.call(this));
        }
  
        setSpeedMenu.call(this);
        return container;
      },
  
      // Insert controls
      inject() {
        // Sprite
        if (this.config.loadSprite) {
          const icon = controls.getIconUrl.call(this); // Only load external sprite using AJAX
  
          if (icon.cors) {
            loadSprite(icon.url, 'sprite-plyr');
          }
        } // Create a unique ID
  
  
        this.id = Math.floor(Math.random() * 10000); // Null by default
  
        let container = null;
        this.elements.controls = null; // Set template properties
  
        const props = {
          id: this.id,
          seektime: this.config.seekTime,
          title: this.config.title
        };
        let update = true; // If function, run it and use output
  
        if (is.function(this.config.controls)) {
          this.config.controls = this.config.controls.call(this, props);
        } // Convert falsy controls to empty array (primarily for empty strings)
  
  
        if (!this.config.controls) {
          this.config.controls = [];
        }
  
        if (is.element(this.config.controls) || is.string(this.config.controls)) {
          // HTMLElement or Non-empty string passed as the option
          container = this.config.controls;
        } else {
          // Create controls
          container = controls.create.call(this, {
            id: this.id,
            seektime: this.config.seekTime,
            speed: this.speed,
            quality: this.quality,
            captions: captions.getLabel.call(this) // TODO: Looping
            // loop: 'None',
  
          });
          update = false;
        } // Replace props with their value
  
  
        const replace = input => {
          let result = input;
          Object.entries(props).forEach(([key, value]) => {
            result = replaceAll(result, `{${key}}`, value);
          });
          return result;
        }; // Update markup
  
  
        if (update) {
          if (is.string(this.config.controls)) {
            container = replace(container);
          }
        } // Controls container
  
  
        let target; // Inject to custom location
  
        if (is.string(this.config.selectors.controls.container)) {
          target = document.querySelector(this.config.selectors.controls.container);
        } // Inject into the container by default
  
  
        if (!is.element(target)) {
          target = this.elements.container;
        } // Inject controls HTML (needs to be before captions, hence "afterbegin")
  
  
        const insertMethod = is.element(container) ? 'insertAdjacentElement' : 'insertAdjacentHTML';
        target[insertMethod]('afterbegin', container); // Find the elements if need be
  
        if (!is.element(this.elements.controls)) {
          controls.findElements.call(this);
        } // Add pressed property to buttons
  
  
        if (!is.empty(this.elements.buttons)) {
          const addProperty = button => {
            const className = this.config.classNames.controlPressed;
            Object.defineProperty(button, 'pressed', {
              enumerable: true,
  
              get() {
                return hasClass(button, className);
              },
  
              set(pressed = false) {
                toggleClass(button, className, pressed);
              }
  
            });
          }; // Toggle classname when pressed property is set
  
  
          Object.values(this.elements.buttons).filter(Boolean).forEach(button => {
            if (is.array(button) || is.nodeList(button)) {
              Array.from(button).filter(Boolean).forEach(addProperty);
            } else {
              addProperty(button);
            }
          });
        } // Edge sometimes doesn't finish the paint so force a repaint
  
  
        if (browser.isEdge) {
          repaint(target);
        } // Setup tooltips
  
  
        if (this.config.tooltips.controls) {
          const {
            classNames,
            selectors
          } = this.config;
          const selector = `${selectors.controls.wrapper} ${selectors.labels} .${classNames.hidden}`;
          const labels = getElements.call(this, selector);
          Array.from(labels).forEach(label => {
            toggleClass(label, this.config.classNames.hidden, false);
            toggleClass(label, this.config.classNames.tooltip, true);
          });
        }
      },
  
      // Set media metadata
      setMediaMetadata() {
        try {
          if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata = new window.MediaMetadata({
              title: this.config.mediaMetadata.title,
              artist: this.config.mediaMetadata.artist,
              album: this.config.mediaMetadata.album,
              artwork: this.config.mediaMetadata.artwork
            });
          }
        } catch (_) {// Do nothing
        }
      },
  
      // Add markers
      setMarkers() {
        var _this$config$markers2, _this$config$markers3;
  
        if (!this.duration || this.elements.markers) return; // Get valid points
  
        const points = (_this$config$markers2 = this.config.markers) === null || _this$config$markers2 === void 0 ? void 0 : (_this$config$markers3 = _this$config$markers2.points) === null || _this$config$markers3 === void 0 ? void 0 : _this$config$markers3.filter(({
          time
        }) => time > 0 && time < this.duration);
        if (!(points !== null && points !== void 0 && points.length)) return;
        const containerFragment = document.createDocumentFragment();
        const pointsFragment = document.createDocumentFragment();
        let tipElement = null;
        const tipVisible = `${this.config.classNames.tooltip}--visible`;
  
        const toggleTip = show => toggleClass(tipElement, tipVisible, show); // Inject markers to progress container
  
  
        points.forEach(point => {
          const markerElement = createElement('span', {
            class: this.config.classNames.marker
          }, '');
          const left = `${point.time / this.duration * 100}%`;
  
          if (tipElement) {
            // Show on hover
            markerElement.addEventListener('mouseenter', () => {
              if (point.label) return;
              tipElement.style.left = left;
              tipElement.innerHTML = point.label;
              toggleTip(true);
            }); // Hide on leave
  
            markerElement.addEventListener('mouseleave', () => {
              toggleTip(false);
            });
          }
  
          markerElement.addEventListener('click', () => {
            this.currentTime = point.time;
          });
          markerElement.style.left = left;
          pointsFragment.appendChild(markerElement);
        });
        containerFragment.appendChild(pointsFragment); // Inject a tooltip if needed
  
        if (!this.config.tooltips.seek) {
          tipElement = createElement('span', {
            class: this.config.classNames.tooltip
          }, '');
          containerFragment.appendChild(tipElement);
        }
  
        this.elements.markers = {
          points: pointsFragment,
          tip: tipElement
        };
        this.elements.progress.appendChild(containerFragment);
      }
  
    };
  
    // ==========================================================================
    /**
     * Parse a string to a URL object
     * @param {String} input - the URL to be parsed
     * @param {Boolean} safe - failsafe parsing
     */
  
    function parseUrl(input, safe = true) {
      let url = input;
  
      if (safe) {
        const parser = document.createElement('a');
        parser.href = url;
        url = parser.href;
      }
  
      try {
        return new URL(url);
      } catch (_) {
        return null;
      }
    } // Convert object to URLSearchParams
  
    function buildUrlParams(input) {
      const params = new URLSearchParams();
  
      if (is.object(input)) {
        Object.entries(input).forEach(([key, value]) => {
          params.set(key, value);
        });
      }
  
      return params;
    }
  
    // ==========================================================================
    const captions = {
      // Setup captions
      setup() {
        // Requires UI support
        if (!this.supported.ui) {
          return;
        } // Only Vimeo and HTML5 video supported at this point
  
  
        if (!this.isVideo || this.isYouTube || this.isHTML5 && !support.textTracks) {
          // Clear menu and hide
          if (is.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {
            controls.setCaptionsMenu.call(this);
          }
  
          return;
        } // Inject the container
  
  
        if (!is.element(this.elements.captions)) {
          this.elements.captions = createElement('div', getAttributesFromSelector(this.config.selectors.captions));
          insertAfter(this.elements.captions, this.elements.wrapper);
        } // Fix IE captions if CORS is used
        // Fetch captions and inject as blobs instead (data URIs not supported!)
  
  
        if (browser.isIE && window.URL) {
          const elements = this.media.querySelectorAll('track');
          Array.from(elements).forEach(track => {
            const src = track.getAttribute('src');
            const url = parseUrl(src);
  
            if (url !== null && url.hostname !== window.location.href.hostname && ['http:', 'https:'].includes(url.protocol)) {
              fetch(src, 'blob').then(blob => {
                track.setAttribute('src', window.URL.createObjectURL(blob));
              }).catch(() => {
                removeElement(track);
              });
            }
          });
        } // Get and set initial data
        // The "preferred" options are not realized unless / until the wanted language has a match
        // * languages: Array of user's browser languages.
        // * language:  The language preferred by user settings or config
        // * active:    The state preferred by user settings or config
        // * toggled:   The real captions state
  
  
        const browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage || 'en'];
        const languages = dedupe(browserLanguages.map(language => language.split('-')[0]));
        let language = (this.storage.get('language') || this.config.captions.language || 'auto').toLowerCase(); // Use first browser language when language is 'auto'
  
        if (language === 'auto') {
          [language] = languages;
        }
  
        let active = this.storage.get('captions');
  
        if (!is.boolean(active)) {
          ({
            active
          } = this.config.captions);
        }
  
        Object.assign(this.captions, {
          toggled: false,
          active,
          language,
          languages
        }); // Watch changes to textTracks and update captions menu
  
        if (this.isHTML5) {
          const trackEvents = this.config.captions.update ? 'addtrack removetrack' : 'removetrack';
          on.call(this, this.media.textTracks, trackEvents, captions.update.bind(this));
        } // Update available languages in list next tick (the event must not be triggered before the listeners)
  
  
        setTimeout(captions.update.bind(this), 0);
      },
  
      // Update available language options in settings based on tracks
      update() {
        const tracks = captions.getTracks.call(this, true); // Get the wanted language
  
        const {
          active,
          language,
          meta,
          currentTrackNode
        } = this.captions;
        const languageExists = Boolean(tracks.find(track => track.language === language)); // Handle tracks (add event listener and "pseudo"-default)
  
        if (this.isHTML5 && this.isVideo) {
          tracks.filter(track => !meta.get(track)).forEach(track => {
            this.debug.log('Track added', track); // Attempt to store if the original dom element was "default"
  
            meta.set(track, {
              default: track.mode === 'showing'
            }); // Turn off native caption rendering to avoid double captions
            // Note: mode='hidden' forces a track to download. To ensure every track
            // isn't downloaded at once, only 'showing' tracks should be reassigned
            // eslint-disable-next-line no-param-reassign
  
            if (track.mode === 'showing') {
              // eslint-disable-next-line no-param-reassign
              track.mode = 'hidden';
            } // Add event listener for cue changes
  
  
            on.call(this, track, 'cuechange', () => captions.updateCues.call(this));
          });
        } // Update language first time it matches, or if the previous matching track was removed
  
  
        if (languageExists && this.language !== language || !tracks.includes(currentTrackNode)) {
          captions.setLanguage.call(this, language);
          captions.toggle.call(this, active && languageExists);
        } // Enable or disable captions based on track length
  
  
        if (this.elements) {
          toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is.empty(tracks));
        } // Update available languages in list
  
  
        if (is.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {
          controls.setCaptionsMenu.call(this);
        }
      },
  
      // Toggle captions display
      // Used internally for the toggleCaptions method, with the passive option forced to false
      toggle(input, passive = true) {
        // If there's no full support
        if (!this.supported.ui) {
          return;
        }
  
        const {
          toggled
        } = this.captions; // Current state
  
        const activeClass = this.config.classNames.captions.active; // Get the next state
        // If the method is called without parameter, toggle based on current value
  
        const active = is.nullOrUndefined(input) ? !toggled : input; // Update state and trigger event
  
        if (active !== toggled) {
          // When passive, don't override user preferences
          if (!passive) {
            this.captions.active = active;
            this.storage.set({
              captions: active
            });
          } // Force language if the call isn't passive and there is no matching language to toggle to
  
  
          if (!this.language && active && !passive) {
            const tracks = captions.getTracks.call(this);
            const track = captions.findTrack.call(this, [this.captions.language, ...this.captions.languages], true); // Override user preferences to avoid switching languages if a matching track is added
  
            this.captions.language = track.language; // Set caption, but don't store in localStorage as user preference
  
            captions.set.call(this, tracks.indexOf(track));
            return;
          } // Toggle button if it's enabled
  
  
          if (this.elements.buttons.captions) {
            this.elements.buttons.captions.pressed = active;
          } // Add class hook
  
  
          toggleClass(this.elements.container, activeClass, active);
          this.captions.toggled = active; // Update settings menu
  
          controls.updateSetting.call(this, 'captions'); // Trigger event (not used internally)
  
          triggerEvent.call(this, this.media, active ? 'captionsenabled' : 'captionsdisabled');
        } // Wait for the call stack to clear before setting mode='hidden'
        // on the active track - forcing the browser to download it
  
  
        setTimeout(() => {
          if (active && this.captions.toggled) {
            this.captions.currentTrackNode.mode = 'hidden';
          }
        });
      },
  
      // Set captions by track index
      // Used internally for the currentTrack setter with the passive option forced to false
      set(index, passive = true) {
        const tracks = captions.getTracks.call(this); // Disable captions if setting to -1
  
        if (index === -1) {
          captions.toggle.call(this, false, passive);
          return;
        }
  
        if (!is.number(index)) {
          this.debug.warn('Invalid caption argument', index);
          return;
        }
  
        if (!(index in tracks)) {
          this.debug.warn('Track not found', index);
          return;
        }
  
        if (this.captions.currentTrack !== index) {
          this.captions.currentTrack = index;
          const track = tracks[index];
          const {
            language
          } = track || {}; // Store reference to node for invalidation on remove
  
          this.captions.currentTrackNode = track; // Update settings menu
  
          controls.updateSetting.call(this, 'captions'); // When passive, don't override user preferences
  
          if (!passive) {
            this.captions.language = language;
            this.storage.set({
              language
            });
          } // Handle Vimeo captions
  
  
          if (this.isVimeo) {
            this.embed.enableTextTrack(language);
          } // Trigger event
  
  
          triggerEvent.call(this, this.media, 'languagechange');
        } // Show captions
  
  
        captions.toggle.call(this, true, passive);
  
        if (this.isHTML5 && this.isVideo) {
          // If we change the active track while a cue is already displayed we need to update it
          captions.updateCues.call(this);
        }
      },
  
      // Set captions by language
      // Used internally for the language setter with the passive option forced to false
      setLanguage(input, passive = true) {
        if (!is.string(input)) {
          this.debug.warn('Invalid language argument', input);
          return;
        } // Normalize
  
  
        const language = input.toLowerCase();
        this.captions.language = language; // Set currentTrack
  
        const tracks = captions.getTracks.call(this);
        const track = captions.findTrack.call(this, [language]);
        captions.set.call(this, tracks.indexOf(track), passive);
      },
  
      // Get current valid caption tracks
      // If update is false it will also ignore tracks without metadata
      // This is used to "freeze" the language options when captions.update is false
      getTracks(update = false) {
        // Handle media or textTracks missing or null
        const tracks = Array.from((this.media || {}).textTracks || []); // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)
        // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)
  
        return tracks.filter(track => !this.isHTML5 || update || this.captions.meta.has(track)).filter(track => ['captions', 'subtitles'].includes(track.kind));
      },
  
      // Match tracks based on languages and get the first
      findTrack(languages, force = false) {
        const tracks = captions.getTracks.call(this);
  
        const sortIsDefault = track => Number((this.captions.meta.get(track) || {}).default);
  
        const sorted = Array.from(tracks).sort((a, b) => sortIsDefault(b) - sortIsDefault(a));
        let track;
        languages.every(language => {
          track = sorted.find(t => t.language === language);
          return !track; // Break iteration if there is a match
        }); // If no match is found but is required, get first
  
        return track || (force ? sorted[0] : undefined);
      },
  
      // Get the current track
      getCurrentTrack() {
        return captions.getTracks.call(this)[this.currentTrack];
      },
  
      // Get UI label for track
      getLabel(track) {
        let currentTrack = track;
  
        if (!is.track(currentTrack) && support.textTracks && this.captions.toggled) {
          currentTrack = captions.getCurrentTrack.call(this);
        }
  
        if (is.track(currentTrack)) {
          if (!is.empty(currentTrack.label)) {
            return currentTrack.label;
          }
  
          if (!is.empty(currentTrack.language)) {
            return track.language.toUpperCase();
          }
  
          return i18n.get('enabled', this.config);
        }
  
        return i18n.get('disabled', this.config);
      },
  
      // Update captions using current track's active cues
      // Also optional array argument in case there isn't any track (ex: vimeo)
      updateCues(input) {
        // Requires UI
        if (!this.supported.ui) {
          return;
        }
  
        if (!is.element(this.elements.captions)) {
          this.debug.warn('No captions element to render to');
          return;
        } // Only accept array or empty input
  
  
        if (!is.nullOrUndefined(input) && !Array.isArray(input)) {
          this.debug.warn('updateCues: Invalid input', input);
          return;
        }
  
        let cues = input; // Get cues from track
  
        if (!cues) {
          const track = captions.getCurrentTrack.call(this);
          cues = Array.from((track || {}).activeCues || []).map(cue => cue.getCueAsHTML()).map(getHTML);
        } // Set new caption text
  
  
        const content = cues.map(cueText => cueText.trim()).join('\n');
        const changed = content !== this.elements.captions.innerHTML;
  
        if (changed) {
          // Empty the container and create a new child element
          emptyElement(this.elements.captions);
          const caption = createElement('span', getAttributesFromSelector(this.config.selectors.caption));
          caption.innerHTML = content;
          this.elements.captions.appendChild(caption); // Trigger event
  
          triggerEvent.call(this, this.media, 'cuechange');
        }
      }
  
    };
  
    // ==========================================================================
    // Plyr default config
    // ==========================================================================
    const defaults = {
      // Disable
      enabled: true,
      // Custom media title
      title: '',
      // Logging to console
      debug: false,
      // Auto play (if supported)
      autoplay: false,
      // Only allow one media playing at once (vimeo only)
      autopause: true,
      // Allow inline playback on iOS (this effects YouTube/Vimeo - HTML5 requires the attribute present)
      // TODO: Remove iosNative fullscreen option in favour of this (logic needs work)
      playsinline: true,
      // Default time to skip when rewind/fast forward
      seekTime: 10,
      // Default volume
      volume: 1,
      muted: false,
      // Pass a custom duration
      duration: null,
      // Display the media duration on load in the current time position
      // If you have opted to display both duration and currentTime, this is ignored
      displayDuration: true,
      // Invert the current time to be a countdown
      invertTime: true,
      // Clicking the currentTime inverts it's value to show time left rather than elapsed
      toggleInvert: true,
      // Force an aspect ratio
      // The format must be `'w:h'` (e.g. `'16:9'`)
      ratio: null,
      // Click video container to play/pause
      clickToPlay: true,
      // Auto hide the controls
      hideControls: true,
      // Reset to start when playback ended
      resetOnEnd: false,
      // Disable the standard context menu
      disableContextMenu: true,
      // Sprite (for icons)
      loadSprite: true,
      iconPrefix: 'plyr',
      iconUrl: 'https://cdn.plyr.io/3.7.2/plyr.svg',
      // Blank video (used to prevent errors on source change)
      blankVideo: 'https://cdn.plyr.io/static/blank.mp4',
      // Quality default
      quality: {
        default: 576,
        // The options to display in the UI, if available for the source media
        options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
        forced: false,
        onChange: null
      },
      // Set loops
      loop: {
        active: false // start: null,
        // end: null,
  
      },
      // Speed default and options to display
      speed: {
        selected: 1,
        // The options to display in the UI, if available for the source media (e.g. Vimeo and YouTube only support 0.5x-4x)
        options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4]
      },
      // Keyboard shortcut settings
      keyboard: {
        focused: true,
        global: false
      },
      // Display tooltips
      tooltips: {
        controls: false,
        seek: true
      },
      // Captions settings
      captions: {
        active: false,
        language: 'auto',
        // Listen to new tracks added after Plyr is initialized.
        // This is needed for streaming captions, but may result in unselectable options
        update: false
      },
      // Fullscreen settings
      fullscreen: {
        enabled: true,
        // Allow fullscreen?
        fallback: true,
        // Fallback using full viewport/window
        iosNative: false // Use the native fullscreen in iOS (disables custom controls)
        // Selector for the fullscreen container so contextual / non-player content can remain visible in fullscreen mode
        // Non-ancestors of the player element will be ignored
        // container: null, // defaults to the player element
  
      },
      // Local storage
      storage: {
        enabled: true,
        key: 'plyr'
      },
      // Default controls
      controls: ['play-large', // 'restart',
      // 'rewind',
      'play', // 'fast-forward',
      'progress', 'current-time', // 'duration',
      'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', // 'download',
      'fullscreen'],
      settings: ['captions', 'quality', 'speed'],
      // Localisation
      i18n: {
        restart: 'Restart',
        rewind: 'Rewind {seektime}s',
        play: 'Play',
        pause: 'Pause',
        fastForward: 'Forward {seektime}s',
        seek: 'Seek',
        seekLabel: '{currentTime} of {duration}',
        played: 'Played',
        buffered: 'Buffered',
        currentTime: 'Current time',
        duration: 'Duration',
        volume: 'Volume',
        mute: 'Mute',
        unmute: 'Unmute',
        enableCaptions: 'Enable captions',
        disableCaptions: 'Disable captions',
        download: 'Download',
        enterFullscreen: 'Enter fullscreen',
        exitFullscreen: 'Exit fullscreen',
        frameTitle: 'Player for {title}',
        captions: 'Captions',
        settings: 'Settings',
        pip: 'PIP',
        menuBack: 'Go back to previous menu',
        speed: 'Speed',
        normal: 'Normal',
        quality: 'Quality',
        loop: 'Loop',
        start: 'Start',
        end: 'End',
        all: 'All',
        reset: 'Reset',
        disabled: 'Disabled',
        enabled: 'Enabled',
        advertisement: 'Ad',
        qualityBadge: {
          2160: '4K',
          1440: 'HD',
          1080: 'HD',
          720: 'HD',
          576: 'SD',
          480: 'SD'
        }
      },
      // URLs
      urls: {
        download: null,
        vimeo: {
          sdk: 'https://player.vimeo.com/api/player.js',
          iframe: 'https://player.vimeo.com/video/{0}?{1}',
          api: 'https://vimeo.com/api/oembed.json?url={0}'
        },
        youtube: {
          sdk: 'https://www.youtube.com/iframe_api',
          api: 'https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}'
        },
        googleIMA: {
          sdk: 'https://imasdk.googleapis.com/js/sdkloader/ima3.js'
        }
      },
      // Custom control listeners
      listeners: {
        seek: null,
        play: null,
        pause: null,
        restart: null,
        rewind: null,
        fastForward: null,
        mute: null,
        volume: null,
        captions: null,
        download: null,
        fullscreen: null,
        pip: null,
        airplay: null,
        speed: null,
        quality: null,
        loop: null,
        language: null
      },
      // Events to watch and bubble
      events: [// Events to watch on HTML5 media elements and bubble
      // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events
      'ended', 'progress', 'stalled', 'playing', 'waiting', 'canplay', 'canplaythrough', 'loadstart', 'loadeddata', 'loadedmetadata', 'timeupdate', 'volumechange', 'play', 'pause', 'error', 'seeking', 'seeked', 'emptied', 'ratechange', 'cuechange', // Custom events
      'download', 'enterfullscreen', 'exitfullscreen', 'captionsenabled', 'captionsdisabled', 'languagechange', 'controlshidden', 'controlsshown', 'ready', // YouTube
      'statechange', // Quality
      'qualitychange', // Ads
      'adsloaded', 'adscontentpause', 'adscontentresume', 'adstarted', 'adsmidpoint', 'adscomplete', 'adsallcomplete', 'adsimpression', 'adsclick'],
      // Selectors
      // Change these to match your template if using custom HTML
      selectors: {
        editable: 'input, textarea, select, [contenteditable]',
        container: '.plyr',
        controls: {
          container: null,
          wrapper: '.plyr__controls'
        },
        labels: '[data-plyr]',
        buttons: {
          play: '[data-plyr="play"]',
          pause: '[data-plyr="pause"]',
          restart: '[data-plyr="restart"]',
          rewind: '[data-plyr="rewind"]',
          fastForward: '[data-plyr="fast-forward"]',
          mute: '[data-plyr="mute"]',
          captions: '[data-plyr="captions"]',
          download: '[data-plyr="download"]',
          fullscreen: '[data-plyr="fullscreen"]',
          pip: '[data-plyr="pip"]',
          airplay: '[data-plyr="airplay"]',
          settings: '[data-plyr="settings"]',
          loop: '[data-plyr="loop"]'
        },
        inputs: {
          seek: '[data-plyr="seek"]',
          volume: '[data-plyr="volume"]',
          speed: '[data-plyr="speed"]',
          language: '[data-plyr="language"]',
          quality: '[data-plyr="quality"]'
        },
        display: {
          currentTime: '.plyr__time--current',
          duration: '.plyr__time--duration',
          buffer: '.plyr__progress__buffer',
          loop: '.plyr__progress__loop',
          // Used later
          volume: '.plyr__volume--display'
        },
        progress: '.plyr__progress',
        captions: '.plyr__captions',
        caption: '.plyr__caption'
      },
      // Class hooks added to the player in different states
      classNames: {
        type: 'plyr--{0}',
        provider: 'plyr--{0}',
        video: 'plyr__video-wrapper',
        embed: 'plyr__video-embed',
        videoFixedRatio: 'plyr__video-wrapper--fixed-ratio',
        embedContainer: 'plyr__video-embed__container',
        poster: 'plyr__poster',
        posterEnabled: 'plyr__poster-enabled',
        ads: 'plyr__ads',
        control: 'plyr__control',
        controlPressed: 'plyr__control--pressed',
        playing: 'plyr--playing',
        paused: 'plyr--paused',
        stopped: 'plyr--stopped',
        loading: 'plyr--loading',
        hover: 'plyr--hover',
        tooltip: 'plyr__tooltip',
        cues: 'plyr__cues',
        marker: 'plyr__progress__marker',
        hidden: 'plyr__sr-only',
        hideControls: 'plyr--hide-controls',
        isIos: 'plyr--is-ios',
        isTouch: 'plyr--is-touch',
        uiSupported: 'plyr--full-ui',
        noTransition: 'plyr--no-transition',
        display: {
          time: 'plyr__time'
        },
        menu: {
          value: 'plyr__menu__value',
          badge: 'plyr__badge',
          open: 'plyr--menu-open'
        },
        captions: {
          enabled: 'plyr--captions-enabled',
          active: 'plyr--captions-active'
        },
        fullscreen: {
          enabled: 'plyr--fullscreen-enabled',
          fallback: 'plyr--fullscreen-fallback'
        },
        pip: {
          supported: 'plyr--pip-supported',
          active: 'plyr--pip-active'
        },
        airplay: {
          supported: 'plyr--airplay-supported',
          active: 'plyr--airplay-active'
        },
        tabFocus: 'plyr__tab-focus',
        previewThumbnails: {
          // Tooltip thumbs
          thumbContainer: 'plyr__preview-thumb',
          thumbContainerShown: 'plyr__preview-thumb--is-shown',
          imageContainer: 'plyr__preview-thumb__image-container',
          timeContainer: 'plyr__preview-thumb__time-container',
          // Scrubbing
          scrubbingContainer: 'plyr__preview-scrubbing',
          scrubbingContainerShown: 'plyr__preview-scrubbing--is-shown'
        }
      },
      // Embed attributes
      attributes: {
        embed: {
          provider: 'data-plyr-provider',
          id: 'data-plyr-embed-id',
          hash: 'data-plyr-embed-hash'
        }
      },
      // Advertisements plugin
      // Register for an account here: http://vi.ai/publisher-video-monetization/?aid=plyrio
      ads: {
        enabled: false,
        publisherId: '',
        tagUrl: ''
      },
      // Preview Thumbnails plugin
      previewThumbnails: {
        enabled: false,
        src: ''
      },
      // Vimeo plugin
      vimeo: {
        byline: false,
        portrait: false,
        title: false,
        speed: true,
        transparent: false,
        // Custom settings from Plyr
        customControls: true,
        referrerPolicy: null,
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy
        // Whether the owner of the video has a Pro or Business account
        // (which allows us to properly hide controls without CSS hacks, etc)
        premium: false
      },
      // YouTube plugin
      youtube: {
        rel: 0,
        // No related vids
        showinfo: 0,
        // Hide info
        iv_load_policy: 3,
        // Hide annotations
        modestbranding: 1,
        // Hide logos as much as possible (they still show one in the corner when paused)
        // Custom settings from Plyr
        customControls: true,
        noCookie: false // Whether to use an alternative version of YouTube without cookies
  
      },
      // Media Metadata
      mediaMetadata: {
        title: '',
        artist: '',
        album: '',
        artwork: []
      },
      // Markers
      markers: {
        enabled: false,
        points: []
      }
    };
  
    // ==========================================================================
    // Plyr states
    // ==========================================================================
    const pip = {
      active: 'picture-in-picture',
      inactive: 'inline'
    };
  
    // ==========================================================================
    // Plyr supported types and providers
    // ==========================================================================
    const providers = {
      html5: 'html5',
      youtube: 'youtube',
      vimeo: 'vimeo'
    };
    const types = {
      audio: 'audio',
      video: 'video'
    };
    /**
     * Get provider by URL
     * @param {String} url
     */
  
    function getProviderByUrl(url) {
      // YouTube
      if (/^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(url)) {
        return providers.youtube;
      } // Vimeo
  
  
      if (/^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(url)) {
        return providers.vimeo;
      }
  
      return null;
    }
  
    // ==========================================================================
    // Console wrapper
    // ==========================================================================
    const noop = () => {};
  
    class Console {
      constructor(enabled = false) {
        this.enabled = window.console && enabled;
  
        if (this.enabled) {
          this.log('Debugging enabled');
        }
      }
  
      get log() {
        // eslint-disable-next-line no-console
        return this.enabled ? Function.prototype.bind.call(console.log, console) : noop;
      }
  
      get warn() {
        // eslint-disable-next-line no-console
        return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop;
      }
  
      get error() {
        // eslint-disable-next-line no-console
        return this.enabled ? Function.prototype.bind.call(console.error, console) : noop;
      }
  
    }
  
    class Fullscreen {
      constructor(player) {
        _defineProperty$1(this, "onChange", () => {
          if (!this.enabled) {
            return;
          } // Update toggle button
  
  
          const button = this.player.elements.buttons.fullscreen;
  
          if (is.element(button)) {
            button.pressed = this.active;
          } // Always trigger events on the plyr / media element (not a fullscreen container) and let them bubble up
  
  
          const target = this.target === this.player.media ? this.target : this.player.elements.container; // Trigger an event
  
          triggerEvent.call(this.player, target, this.active ? 'enterfullscreen' : 'exitfullscreen', true);
        });
  
        _defineProperty$1(this, "toggleFallback", (toggle = false) => {
          // Store or restore scroll position
          if (toggle) {
            this.scrollPosition = {
              x: window.scrollX || 0,
              y: window.scrollY || 0
            };
          } else {
            window.scrollTo(this.scrollPosition.x, this.scrollPosition.y);
          } // Toggle scroll
  
  
          document.body.style.overflow = toggle ? 'hidden' : ''; // Toggle class hook
  
          toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, toggle); // Force full viewport on iPhone X+
  
          if (browser.isIos) {
            let viewport = document.head.querySelector('meta[name="viewport"]');
            const property = 'viewport-fit=cover'; // Inject the viewport meta if required
  
            if (!viewport) {
              viewport = document.createElement('meta');
              viewport.setAttribute('name', 'viewport');
            } // Check if the property already exists
  
  
            const hasProperty = is.string(viewport.content) && viewport.content.includes(property);
  
            if (toggle) {
              this.cleanupViewport = !hasProperty;
  
              if (!hasProperty) {
                viewport.content += `,${property}`;
              }
            } else if (this.cleanupViewport) {
              viewport.content = viewport.content.split(',').filter(part => part.trim() !== property).join(',');
            }
          } // Toggle button and fire events
  
  
          this.onChange();
        });
  
        _defineProperty$1(this, "trapFocus", event => {
          // Bail if iOS, not active, not the tab key
          if (browser.isIos || !this.active || event.key !== 'Tab') {
            return;
          } // Get the current focused element
  
  
          const focused = document.activeElement;
          const focusable = getElements.call(this.player, 'a[href], button:not(:disabled), input:not(:disabled), [tabindex]');
          const [first] = focusable;
          const last = focusable[focusable.length - 1];
  
          if (focused === last && !event.shiftKey) {
            // Move focus to first element that can be tabbed if Shift isn't used
            first.focus();
            event.preventDefault();
          } else if (focused === first && event.shiftKey) {
            // Move focus to last element that can be tabbed if Shift is used
            last.focus();
            event.preventDefault();
          }
        });
  
        _defineProperty$1(this, "update", () => {
          if (this.enabled) {
            let mode;
  
            if (this.forceFallback) {
              mode = 'Fallback (forced)';
            } else if (Fullscreen.native) {
              mode = 'Native';
            } else {
              mode = 'Fallback';
            }
  
            this.player.debug.log(`${mode} fullscreen enabled`);
          } else {
            this.player.debug.log('Fullscreen not supported and fallback disabled');
          } // Add styling hook to show button
  
  
          toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);
        });
  
        _defineProperty$1(this, "enter", () => {
          if (!this.enabled) {
            return;
          } // iOS native fullscreen doesn't need the request step
  
  
          if (browser.isIos && this.player.config.fullscreen.iosNative) {
            if (this.player.isVimeo) {
              this.player.embed.requestFullscreen();
            } else {
              this.target.webkitEnterFullscreen();
            }
          } else if (!Fullscreen.native || this.forceFallback) {
            this.toggleFallback(true);
          } else if (!this.prefix) {
            this.target.requestFullscreen({
              navigationUI: 'hide'
            });
          } else if (!is.empty(this.prefix)) {
            this.target[`${this.prefix}Request${this.property}`]();
          }
        });
  
        _defineProperty$1(this, "exit", () => {
          if (!this.enabled) {
            return;
          } // iOS native fullscreen
  
  
          if (browser.isIos && this.player.config.fullscreen.iosNative) {
            this.target.webkitExitFullscreen();
            silencePromise(this.player.play());
          } else if (!Fullscreen.native || this.forceFallback) {
            this.toggleFallback(false);
          } else if (!this.prefix) {
            (document.cancelFullScreen || document.exitFullscreen).call(document);
          } else if (!is.empty(this.prefix)) {
            const action = this.prefix === 'moz' ? 'Cancel' : 'Exit';
            document[`${this.prefix}${action}${this.property}`]();
          }
        });
  
        _defineProperty$1(this, "toggle", () => {
          if (!this.active) {
            this.enter();
          } else {
            this.exit();
          }
        });
  
        // Keep reference to parent
        this.player = player; // Get prefix
  
        this.prefix = Fullscreen.prefix;
        this.property = Fullscreen.property; // Scroll position
  
        this.scrollPosition = {
          x: 0,
          y: 0
        }; // Force the use of 'full window/browser' rather than fullscreen
  
        this.forceFallback = player.config.fullscreen.fallback === 'force'; // Get the fullscreen element
        // Checks container is an ancestor, defaults to null
  
        this.player.elements.fullscreen = player.config.fullscreen.container && closest$1(this.player.elements.container, player.config.fullscreen.container); // Register event listeners
        // Handle event (incase user presses escape etc)
  
        on.call(this.player, document, this.prefix === 'ms' ? 'MSFullscreenChange' : `${this.prefix}fullscreenchange`, () => {
          // TODO: Filter for target??
          this.onChange();
        }); // Fullscreen toggle on double click
  
        on.call(this.player, this.player.elements.container, 'dblclick', event => {
          // Ignore double click in controls
          if (is.element(this.player.elements.controls) && this.player.elements.controls.contains(event.target)) {
            return;
          }
  
          this.player.listeners.proxy(event, this.toggle, 'fullscreen');
        }); // Tap focus when in fullscreen
  
        on.call(this, this.player.elements.container, 'keydown', event => this.trapFocus(event)); // Update the UI
  
        this.update(); // this.toggle = this.toggle.bind(this);
      } // Determine if native supported
  
  
      static get native() {
        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
      } // If we're actually using native
  
  
      get usingNative() {
        return Fullscreen.native && !this.forceFallback;
      } // Get the prefix for handlers
  
  
      static get prefix() {
        // No prefix
        if (is.function(document.exitFullscreen)) {
          return '';
        } // Check for fullscreen support by vendor prefix
  
  
        let value = '';
        const prefixes = ['webkit', 'moz', 'ms'];
        prefixes.some(pre => {
          if (is.function(document[`${pre}ExitFullscreen`]) || is.function(document[`${pre}CancelFullScreen`])) {
            value = pre;
            return true;
          }
  
          return false;
        });
        return value;
      }
  
      static get property() {
        return this.prefix === 'moz' ? 'FullScreen' : 'Fullscreen';
      } // Determine if fullscreen is enabled
  
  
      get enabled() {
        return (Fullscreen.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo;
      } // Get active state
  
  
      get active() {
        if (!this.enabled) {
          return false;
        } // Fallback using classname
  
  
        if (!Fullscreen.native || this.forceFallback) {
          return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);
        }
  
        const element = !this.prefix ? this.target.getRootNode().fullscreenElement : this.target.getRootNode()[`${this.prefix}${this.property}Element`];
        return element && element.shadowRoot ? element === this.target.getRootNode().host : element === this.target;
      } // Get target element
  
  
      get target() {
        return browser.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container;
      }
  
    }
  
    // ==========================================================================
    // Load image avoiding xhr/fetch CORS issues
    // Server status can't be obtained this way unfortunately, so this uses "naturalWidth" to determine if the image has loaded
    // By default it checks if it is at least 1px, but you can add a second argument to change this
    // ==========================================================================
    function loadImage(src, minWidth = 1) {
      return new Promise((resolve, reject) => {
        const image = new Image();
  
        const handler = () => {
          delete image.onload;
          delete image.onerror;
          (image.naturalWidth >= minWidth ? resolve : reject)(image);
        };
  
        Object.assign(image, {
          onload: handler,
          onerror: handler,
          src
        });
      });
    }
  
    // ==========================================================================
    const ui = {
      addStyleHook() {
        toggleClass(this.elements.container, this.config.selectors.container.replace('.', ''), true);
        toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);
      },
  
      // Toggle native HTML5 media controls
      toggleNativeControls(toggle = false) {
        if (toggle && this.isHTML5) {
          this.media.setAttribute('controls', '');
        } else {
          this.media.removeAttribute('controls');
        }
      },
  
      // Setup the UI
      build() {
        // Re-attach media element listeners
        // TODO: Use event bubbling?
        this.listeners.media(); // Don't setup interface if no support
  
        if (!this.supported.ui) {
          this.debug.warn(`Basic support only for ${this.provider} ${this.type}`); // Restore native controls
  
          ui.toggleNativeControls.call(this, true); // Bail
  
          return;
        } // Inject custom controls if not present
  
  
        if (!is.element(this.elements.controls)) {
          // Inject custom controls
          controls.inject.call(this); // Re-attach control listeners
  
          this.listeners.controls();
        } // Remove native controls
  
  
        ui.toggleNativeControls.call(this); // Setup captions for HTML5
  
        if (this.isHTML5) {
          captions.setup.call(this);
        } // Reset volume
  
  
        this.volume = null; // Reset mute state
  
        this.muted = null; // Reset loop state
  
        this.loop = null; // Reset quality setting
  
        this.quality = null; // Reset speed
  
        this.speed = null; // Reset volume display
  
        controls.updateVolume.call(this); // Reset time display
  
        controls.timeUpdate.call(this); // Reset duration display
  
        controls.durationUpdate.call(this); // Update the UI
  
        ui.checkPlaying.call(this); // Check for picture-in-picture support
  
        toggleClass(this.elements.container, this.config.classNames.pip.supported, support.pip && this.isHTML5 && this.isVideo); // Check for airplay support
  
        toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5); // Add iOS class
  
        toggleClass(this.elements.container, this.config.classNames.isIos, browser.isIos); // Add touch class
  
        toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch); // Ready for API calls
  
        this.ready = true; // Ready event at end of execution stack
  
        setTimeout(() => {
          triggerEvent.call(this, this.media, 'ready');
        }, 0); // Set the title
  
        ui.setTitle.call(this); // Assure the poster image is set, if the property was added before the element was created
  
        if (this.poster) {
          ui.setPoster.call(this, this.poster, false).catch(() => {});
        } // Manually set the duration if user has overridden it.
        // The event listeners for it doesn't get called if preload is disabled (#701)
  
  
        if (this.config.duration) {
          controls.durationUpdate.call(this);
        } // Media metadata
  
  
        if (this.config.mediaMetadata) {
          controls.setMediaMetadata.call(this);
        }
      },
  
      // Setup aria attribute for play and iframe title
      setTitle() {
        // Find the current text
        let label = i18n.get('play', this.config); // If there's a media title set, use that for the label
  
        if (is.string(this.config.title) && !is.empty(this.config.title)) {
          label += `, ${this.config.title}`;
        } // If there's a play button, set label
  
  
        Array.from(this.elements.buttons.play || []).forEach(button => {
          button.setAttribute('aria-label', label);
        }); // Set iframe title
        // https://github.com/sampotts/plyr/issues/124
  
        if (this.isEmbed) {
          const iframe = getElement.call(this, 'iframe');
  
          if (!is.element(iframe)) {
            return;
          } // Default to media type
  
  
          const title = !is.empty(this.config.title) ? this.config.title : 'video';
          const format = i18n.get('frameTitle', this.config);
          iframe.setAttribute('title', format.replace('{title}', title));
        }
      },
  
      // Toggle poster
      togglePoster(enable) {
        toggleClass(this.elements.container, this.config.classNames.posterEnabled, enable);
      },
  
      // Set the poster image (async)
      // Used internally for the poster setter, with the passive option forced to false
      setPoster(poster, passive = true) {
        // Don't override if call is passive
        if (passive && this.poster) {
          return Promise.reject(new Error('Poster already set'));
        } // Set property synchronously to respect the call order
  
  
        this.media.setAttribute('data-poster', poster); // Show the poster
  
        this.elements.poster.removeAttribute('hidden'); // Wait until ui is ready
  
        return ready.call(this) // Load image
        .then(() => loadImage(poster)).catch(error => {
          // Hide poster on error unless it's been set by another call
          if (poster === this.poster) {
            ui.togglePoster.call(this, false);
          } // Rethrow
  
  
          throw error;
        }).then(() => {
          // Prevent race conditions
          if (poster !== this.poster) {
            throw new Error('setPoster cancelled by later call to setPoster');
          }
        }).then(() => {
          Object.assign(this.elements.poster.style, {
            backgroundImage: `url('${poster}')`,
            // Reset backgroundSize as well (since it can be set to "cover" for padded thumbnails for youtube)
            backgroundSize: ''
          });
          ui.togglePoster.call(this, true);
          return poster;
        });
      },
  
      // Check playing state
      checkPlaying(event) {
        // Class hooks
        toggleClass(this.elements.container, this.config.classNames.playing, this.playing);
        toggleClass(this.elements.container, this.config.classNames.paused, this.paused);
        toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped); // Set state
  
        Array.from(this.elements.buttons.play || []).forEach(target => {
          Object.assign(target, {
            pressed: this.playing
          });
          target.setAttribute('aria-label', i18n.get(this.playing ? 'pause' : 'play', this.config));
        }); // Only update controls on non timeupdate events
  
        if (is.event(event) && event.type === 'timeupdate') {
          return;
        } // Toggle controls
  
  
        ui.toggleControls.call(this);
      },
  
      // Check if media is loading
      checkLoading(event) {
        this.loading = ['stalled', 'waiting'].includes(event.type); // Clear timer
  
        clearTimeout(this.timers.loading); // Timer to prevent flicker when seeking
  
        this.timers.loading = setTimeout(() => {
          // Update progress bar loading class state
          toggleClass(this.elements.container, this.config.classNames.loading, this.loading); // Update controls visibility
  
          ui.toggleControls.call(this);
        }, this.loading ? 250 : 0);
      },
  
      // Toggle controls based on state and `force` argument
      toggleControls(force) {
        const {
          controls: controlsElement
        } = this.elements;
  
        if (controlsElement && this.config.hideControls) {
          // Don't hide controls if a touch-device user recently seeked. (Must be limited to touch devices, or it occasionally prevents desktop controls from hiding.)
          const recentTouchSeek = this.touch && this.lastSeekTime + 2000 > Date.now(); // Show controls if force, loading, paused, button interaction, or recent seek, otherwise hide
  
          this.toggleControls(Boolean(force || this.loading || this.paused || controlsElement.pressed || controlsElement.hover || recentTouchSeek));
        }
      },
  
      // Migrate any custom properties from the media to the parent
      migrateStyles() {
        // Loop through values (as they are the keys when the object is spread 🤔)
        Object.values({ ...this.media.style
        }) // We're only fussed about Plyr specific properties
        .filter(key => !is.empty(key) && is.string(key) && key.startsWith('--plyr')).forEach(key => {
          // Set on the container
          this.elements.container.style.setProperty(key, this.media.style.getPropertyValue(key)); // Clean up from media element
  
          this.media.style.removeProperty(key);
        }); // Remove attribute if empty
  
        if (is.empty(this.media.style)) {
          this.media.removeAttribute('style');
        }
      }
  
    };
  
    class Listeners {
      constructor(_player) {
        _defineProperty$1(this, "firstTouch", () => {
          const {
            player
          } = this;
          const {
            elements
          } = player;
          player.touch = true; // Add touch class
  
          toggleClass(elements.container, player.config.classNames.isTouch, true);
        });
  
        _defineProperty$1(this, "setTabFocus", event => {
          const {
            player
          } = this;
          const {
            elements
          } = player;
          const {
            key,
            type,
            timeStamp
          } = event;
          clearTimeout(this.focusTimer); // Ignore any key other than tab
  
          if (type === 'keydown' && key !== 'Tab') {
            return;
          } // Store reference to event timeStamp
  
  
          if (type === 'keydown') {
            this.lastKeyDown = timeStamp;
          } // Remove current classes
  
  
          const removeCurrent = () => {
            const className = player.config.classNames.tabFocus;
            const current = getElements.call(player, `.${className}`);
            toggleClass(current, className, false);
          }; // Determine if a key was pressed to trigger this event
  
  
          const wasKeyDown = timeStamp - this.lastKeyDown <= 20; // Ignore focus events if a key was pressed prior
  
          if (type === 'focus' && !wasKeyDown) {
            return;
          } // Remove all current
  
  
          removeCurrent(); // Delay the adding of classname until the focus has changed
          // This event fires before the focusin event
  
          if (type !== 'focusout') {
            this.focusTimer = setTimeout(() => {
              const focused = document.activeElement; // Ignore if current focus element isn't inside the player
  
              if (!elements.container.contains(focused)) {
                return;
              }
  
              toggleClass(document.activeElement, player.config.classNames.tabFocus, true);
            }, 10);
          }
        });
  
        _defineProperty$1(this, "global", (toggle = true) => {
          const {
            player
          } = this; // Keyboard shortcuts
  
          if (player.config.keyboard.global) {
            toggleListener.call(player, window, 'keydown keyup', this.handleKey, toggle, false);
          } // Click anywhere closes menu
  
  
          toggleListener.call(player, document.body, 'click', this.toggleMenu, toggle); // Detect touch by events
  
          once.call(player, document.body, 'touchstart', this.firstTouch); // Tab focus detection
  
          toggleListener.call(player, document.body, 'keydown focus blur focusout', this.setTabFocus, toggle, false, true);
        });
  
        _defineProperty$1(this, "container", () => {
          const {
            player
          } = this;
          const {
            config,
            elements,
            timers
          } = player; // Keyboard shortcuts
  
          if (!config.keyboard.global && config.keyboard.focused) {
            on.call(player, elements.container, 'keydown keyup', this.handleKey, false);
          } // Toggle controls on mouse events and entering fullscreen
  
  
          on.call(player, elements.container, 'mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen', event => {
            const {
              controls: controlsElement
            } = elements; // Remove button states for fullscreen
  
            if (controlsElement && event.type === 'enterfullscreen') {
              controlsElement.pressed = false;
              controlsElement.hover = false;
            } // Show, then hide after a timeout unless another control event occurs
  
  
            const show = ['touchstart', 'touchmove', 'mousemove'].includes(event.type);
            let delay = 0;
  
            if (show) {
              ui.toggleControls.call(player, true); // Use longer timeout for touch devices
  
              delay = player.touch ? 3000 : 2000;
            } // Clear timer
  
  
            clearTimeout(timers.controls); // Set new timer to prevent flicker when seeking
  
            timers.controls = setTimeout(() => ui.toggleControls.call(player, false), delay);
          }); // Set a gutter for Vimeo
  
          const setGutter = () => {
            if (!player.isVimeo || player.config.vimeo.premium) {
              return;
            }
  
            const target = elements.wrapper;
            const {
              active
            } = player.fullscreen;
            const [videoWidth, videoHeight] = getAspectRatio.call(player);
            const useNativeAspectRatio = supportsCSS(`aspect-ratio: ${videoWidth} / ${videoHeight}`); // If not active, remove styles
  
            if (!active) {
              if (useNativeAspectRatio) {
                target.style.width = null;
                target.style.height = null;
              } else {
                target.style.maxWidth = null;
                target.style.margin = null;
              }
  
              return;
            } // Determine which dimension will overflow and constrain view
  
  
            const [viewportWidth, viewportHeight] = getViewportSize();
            const overflow = viewportWidth / viewportHeight > videoWidth / videoHeight;
  
            if (useNativeAspectRatio) {
              target.style.width = overflow ? 'auto' : '100%';
              target.style.height = overflow ? '100%' : 'auto';
            } else {
              target.style.maxWidth = overflow ? `${viewportHeight / videoHeight * videoWidth}px` : null;
              target.style.margin = overflow ? '0 auto' : null;
            }
          }; // Handle resizing
  
  
          const resized = () => {
            clearTimeout(timers.resized);
            timers.resized = setTimeout(setGutter, 50);
          };
  
          on.call(player, elements.container, 'enterfullscreen exitfullscreen', event => {
            const {
              target
            } = player.fullscreen; // Ignore events not from target
  
            if (target !== elements.container) {
              return;
            } // If it's not an embed and no ratio specified
  
  
            if (!player.isEmbed && is.empty(player.config.ratio)) {
              return;
            } // Set Vimeo gutter
  
  
            setGutter(); // Watch for resizes
  
            const method = event.type === 'enterfullscreen' ? on : off;
            method.call(player, window, 'resize', resized);
          });
        });
  
        _defineProperty$1(this, "media", () => {
          const {
            player
          } = this;
          const {
            elements
          } = player; // Time change on media
  
          on.call(player, player.media, 'timeupdate seeking seeked', event => controls.timeUpdate.call(player, event)); // Display duration
  
          on.call(player, player.media, 'durationchange loadeddata loadedmetadata', event => controls.durationUpdate.call(player, event)); // Handle the media finishing
  
          on.call(player, player.media, 'ended', () => {
            // Show poster on end
            if (player.isHTML5 && player.isVideo && player.config.resetOnEnd) {
              // Restart
              player.restart(); // Call pause otherwise IE11 will start playing the video again
  
              player.pause();
            }
          }); // Check for buffer progress
  
          on.call(player, player.media, 'progress playing seeking seeked', event => controls.updateProgress.call(player, event)); // Handle volume changes
  
          on.call(player, player.media, 'volumechange', event => controls.updateVolume.call(player, event)); // Handle play/pause
  
          on.call(player, player.media, 'playing play pause ended emptied timeupdate', event => ui.checkPlaying.call(player, event)); // Loading state
  
          on.call(player, player.media, 'waiting canplay seeked playing', event => ui.checkLoading.call(player, event)); // Click video
  
          if (player.supported.ui && player.config.clickToPlay && !player.isAudio) {
            // Re-fetch the wrapper
            const wrapper = getElement.call(player, `.${player.config.classNames.video}`); // Bail if there's no wrapper (this should never happen)
  
            if (!is.element(wrapper)) {
              return;
            } // On click play, pause or restart
  
  
            on.call(player, elements.container, 'click', event => {
              const targets = [elements.container, wrapper]; // Ignore if click if not container or in video wrapper
  
              if (!targets.includes(event.target) && !wrapper.contains(event.target)) {
                return;
              } // Touch devices will just show controls (if hidden)
  
  
              if (player.touch && player.config.hideControls) {
                return;
              }
  
              if (player.ended) {
                this.proxy(event, player.restart, 'restart');
                this.proxy(event, () => {
                  silencePromise(player.play());
                }, 'play');
              } else {
                this.proxy(event, () => {
                  silencePromise(player.togglePlay());
                }, 'play');
              }
            });
          } // Disable right click
  
  
          if (player.supported.ui && player.config.disableContextMenu) {
            on.call(player, elements.wrapper, 'contextmenu', event => {
              event.preventDefault();
            }, false);
          } // Volume change
  
  
          on.call(player, player.media, 'volumechange', () => {
            // Save to storage
            player.storage.set({
              volume: player.volume,
              muted: player.muted
            });
          }); // Speed change
  
          on.call(player, player.media, 'ratechange', () => {
            // Update UI
            controls.updateSetting.call(player, 'speed'); // Save to storage
  
            player.storage.set({
              speed: player.speed
            });
          }); // Quality change
  
          on.call(player, player.media, 'qualitychange', event => {
            // Update UI
            controls.updateSetting.call(player, 'quality', null, event.detail.quality);
          }); // Update download link when ready and if quality changes
  
          on.call(player, player.media, 'ready qualitychange', () => {
            controls.setDownloadUrl.call(player);
          }); // Proxy events to container
          // Bubble up key events for Edge
  
          const proxyEvents = player.config.events.concat(['keyup', 'keydown']).join(' ');
          on.call(player, player.media, proxyEvents, event => {
            let {
              detail = {}
            } = event; // Get error details from media
  
            if (event.type === 'error') {
              detail = player.media.error;
            }
  
            triggerEvent.call(player, elements.container, event.type, true, detail);
          });
        });
  
        _defineProperty$1(this, "proxy", (event, defaultHandler, customHandlerKey) => {
          const {
            player
          } = this;
          const customHandler = player.config.listeners[customHandlerKey];
          const hasCustomHandler = is.function(customHandler);
          let returned = true; // Execute custom handler
  
          if (hasCustomHandler) {
            returned = customHandler.call(player, event);
          } // Only call default handler if not prevented in custom handler
  
  
          if (returned !== false && is.function(defaultHandler)) {
            defaultHandler.call(player, event);
          }
        });
  
        _defineProperty$1(this, "bind", (element, type, defaultHandler, customHandlerKey, passive = true) => {
          const {
            player
          } = this;
          const customHandler = player.config.listeners[customHandlerKey];
          const hasCustomHandler = is.function(customHandler);
          on.call(player, element, type, event => this.proxy(event, defaultHandler, customHandlerKey), passive && !hasCustomHandler);
        });
  
        _defineProperty$1(this, "controls", () => {
          const {
            player
          } = this;
          const {
            elements
          } = player; // IE doesn't support input event, so we fallback to change
  
          const inputEvent = browser.isIE ? 'change' : 'input'; // Play/pause toggle
  
          if (elements.buttons.play) {
            Array.from(elements.buttons.play).forEach(button => {
              this.bind(button, 'click', () => {
                silencePromise(player.togglePlay());
              }, 'play');
            });
          } // Pause
  
  
          this.bind(elements.buttons.restart, 'click', player.restart, 'restart'); // Rewind
  
          this.bind(elements.buttons.rewind, 'click', () => {
            // Record seek time so we can prevent hiding controls for a few seconds after rewind
            player.lastSeekTime = Date.now();
            player.rewind();
          }, 'rewind'); // Rewind
  
          this.bind(elements.buttons.fastForward, 'click', () => {
            // Record seek time so we can prevent hiding controls for a few seconds after fast forward
            player.lastSeekTime = Date.now();
            player.forward();
          }, 'fastForward'); // Mute toggle
  
          this.bind(elements.buttons.mute, 'click', () => {
            player.muted = !player.muted;
          }, 'mute'); // Captions toggle
  
          this.bind(elements.buttons.captions, 'click', () => player.toggleCaptions()); // Download
  
          this.bind(elements.buttons.download, 'click', () => {
            triggerEvent.call(player, player.media, 'download');
          }, 'download'); // Fullscreen toggle
  
          this.bind(elements.buttons.fullscreen, 'click', () => {
            player.fullscreen.toggle();
          }, 'fullscreen'); // Picture-in-Picture
  
          this.bind(elements.buttons.pip, 'click', () => {
            player.pip = 'toggle';
          }, 'pip'); // Airplay
  
          this.bind(elements.buttons.airplay, 'click', player.airplay, 'airplay'); // Settings menu - click toggle
  
          this.bind(elements.buttons.settings, 'click', event => {
            // Prevent the document click listener closing the menu
            event.stopPropagation();
            event.preventDefault();
            controls.toggleMenu.call(player, event);
          }, null, false); // Can't be passive as we're preventing default
          // Settings menu - keyboard toggle
          // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
  
          this.bind(elements.buttons.settings, 'keyup', event => {
            if (!['Space', 'Enter'].includes(event.key)) {
              return;
            } // Because return triggers a click anyway, all we need to do is set focus
  
  
            if (event.key === 'Enter') {
              controls.focusFirstMenuItem.call(player, null, true);
              return;
            } // Prevent scroll
  
  
            event.preventDefault(); // Prevent playing video (Firefox)
  
            event.stopPropagation(); // Toggle menu
  
            controls.toggleMenu.call(player, event);
          }, null, false // Can't be passive as we're preventing default
          ); // Escape closes menu
  
          this.bind(elements.settings.menu, 'keydown', event => {
            if (event.key === 'Escape') {
              controls.toggleMenu.call(player, event);
            }
          }); // Set range input alternative "value", which matches the tooltip time (#954)
  
          this.bind(elements.inputs.seek, 'mousedown mousemove', event => {
            const rect = elements.progress.getBoundingClientRect();
            const percent = 100 / rect.width * (event.pageX - rect.left);
            event.currentTarget.setAttribute('seek-value', percent);
          }); // Pause while seeking
  
          this.bind(elements.inputs.seek, 'mousedown mouseup keydown keyup touchstart touchend', event => {
            const seek = event.currentTarget;
            const attribute = 'play-on-seeked';
  
            if (is.keyboardEvent(event) && !['ArrowLeft', 'ArrowRight'].includes(event.key)) {
              return;
            } // Record seek time so we can prevent hiding controls for a few seconds after seek
  
  
            player.lastSeekTime = Date.now(); // Was playing before?
  
            const play = seek.hasAttribute(attribute); // Done seeking
  
            const done = ['mouseup', 'touchend', 'keyup'].includes(event.type); // If we're done seeking and it was playing, resume playback
  
            if (play && done) {
              seek.removeAttribute(attribute);
              silencePromise(player.play());
            } else if (!done && player.playing) {
              seek.setAttribute(attribute, '');
              player.pause();
            }
          }); // Fix range inputs on iOS
          // Super weird iOS bug where after you interact with an <input type="range">,
          // it takes over further interactions on the page. This is a hack
  
          if (browser.isIos) {
            const inputs = getElements.call(player, 'input[type="range"]');
            Array.from(inputs).forEach(input => this.bind(input, inputEvent, event => repaint(event.target)));
          } // Seek
  
  
          this.bind(elements.inputs.seek, inputEvent, event => {
            const seek = event.currentTarget; // If it exists, use seek-value instead of "value" for consistency with tooltip time (#954)
  
            let seekTo = seek.getAttribute('seek-value');
  
            if (is.empty(seekTo)) {
              seekTo = seek.value;
            }
  
            seek.removeAttribute('seek-value');
            player.currentTime = seekTo / seek.max * player.duration;
          }, 'seek'); // Seek tooltip
  
          this.bind(elements.progress, 'mouseenter mouseleave mousemove', event => controls.updateSeekTooltip.call(player, event)); // Preview thumbnails plugin
          // TODO: Really need to work on some sort of plug-in wide event bus or pub-sub for this
  
          this.bind(elements.progress, 'mousemove touchmove', event => {
            const {
              previewThumbnails
            } = player;
  
            if (previewThumbnails && previewThumbnails.loaded) {
              previewThumbnails.startMove(event);
            }
          }); // Hide thumbnail preview - on mouse click, mouse leave, and video play/seek. All four are required, e.g., for buffering
  
          this.bind(elements.progress, 'mouseleave touchend click', () => {
            const {
              previewThumbnails
            } = player;
  
            if (previewThumbnails && previewThumbnails.loaded) {
              previewThumbnails.endMove(false, true);
            }
          }); // Show scrubbing preview
  
          this.bind(elements.progress, 'mousedown touchstart', event => {
            const {
              previewThumbnails
            } = player;
  
            if (previewThumbnails && previewThumbnails.loaded) {
              previewThumbnails.startScrubbing(event);
            }
          });
          this.bind(elements.progress, 'mouseup touchend', event => {
            const {
              previewThumbnails
            } = player;
  
            if (previewThumbnails && previewThumbnails.loaded) {
              previewThumbnails.endScrubbing(event);
            }
          }); // Polyfill for lower fill in <input type="range"> for webkit
  
          if (browser.isWebkit) {
            Array.from(getElements.call(player, 'input[type="range"]')).forEach(element => {
              this.bind(element, 'input', event => controls.updateRangeFill.call(player, event.target));
            });
          } // Current time invert
          // Only if one time element is used for both currentTime and duration
  
  
          if (player.config.toggleInvert && !is.element(elements.display.duration)) {
            this.bind(elements.display.currentTime, 'click', () => {
              // Do nothing if we're at the start
              if (player.currentTime === 0) {
                return;
              }
  
              player.config.invertTime = !player.config.invertTime;
              controls.timeUpdate.call(player);
            });
          } // Volume
  
  
          this.bind(elements.inputs.volume, inputEvent, event => {
            player.volume = event.target.value;
          }, 'volume'); // Update controls.hover state (used for ui.toggleControls to avoid hiding when interacting)
  
          this.bind(elements.controls, 'mouseenter mouseleave', event => {
            elements.controls.hover = !player.touch && event.type === 'mouseenter';
          }); // Also update controls.hover state for any non-player children of fullscreen element (as above)
  
          if (elements.fullscreen) {
            Array.from(elements.fullscreen.children).filter(c => !c.contains(elements.container)).forEach(child => {
              this.bind(child, 'mouseenter mouseleave', event => {
                if (elements.controls) {
                  elements.controls.hover = !player.touch && event.type === 'mouseenter';
                }
              });
            });
          } // Update controls.pressed state (used for ui.toggleControls to avoid hiding when interacting)
  
  
          this.bind(elements.controls, 'mousedown mouseup touchstart touchend touchcancel', event => {
            elements.controls.pressed = ['mousedown', 'touchstart'].includes(event.type);
          }); // Show controls when they receive focus (e.g., when using keyboard tab key)
  
          this.bind(elements.controls, 'focusin', () => {
            const {
              config,
              timers
            } = player; // Skip transition to prevent focus from scrolling the parent element
  
            toggleClass(elements.controls, config.classNames.noTransition, true); // Toggle
  
            ui.toggleControls.call(player, true); // Restore transition
  
            setTimeout(() => {
              toggleClass(elements.controls, config.classNames.noTransition, false);
            }, 0); // Delay a little more for mouse users
  
            const delay = this.touch ? 3000 : 4000; // Clear timer
  
            clearTimeout(timers.controls); // Hide again after delay
  
            timers.controls = setTimeout(() => ui.toggleControls.call(player, false), delay);
          }); // Mouse wheel for volume
  
          this.bind(elements.inputs.volume, 'wheel', event => {
            // Detect "natural" scroll - supported on OS X Safari only
            // Other browsers on OS X will be inverted until support improves
            const inverted = event.webkitDirectionInvertedFromDevice; // Get delta from event. Invert if `inverted` is true
  
            const [x, y] = [event.deltaX, -event.deltaY].map(value => inverted ? -value : value); // Using the biggest delta, normalize to 1 or -1 (or 0 if no delta)
  
            const direction = Math.sign(Math.abs(x) > Math.abs(y) ? x : y); // Change the volume by 2%
  
            player.increaseVolume(direction / 50); // Don't break page scrolling at max and min
  
            const {
              volume
            } = player.media;
  
            if (direction === 1 && volume < 1 || direction === -1 && volume > 0) {
              event.preventDefault();
            }
          }, 'volume', false);
        });
  
        this.player = _player;
        this.lastKey = null;
        this.focusTimer = null;
        this.lastKeyDown = null;
        this.handleKey = this.handleKey.bind(this);
        this.toggleMenu = this.toggleMenu.bind(this);
        this.setTabFocus = this.setTabFocus.bind(this);
        this.firstTouch = this.firstTouch.bind(this);
      } // Handle key presses
  
  
      handleKey(event) {
        const {
          player
        } = this;
        const {
          elements
        } = player;
        const {
          key,
          type,
          altKey,
          ctrlKey,
          metaKey,
          shiftKey
        } = event;
        const pressed = type === 'keydown';
        const repeat = pressed && key === this.lastKey; // Bail if a modifier key is set
  
        if (altKey || ctrlKey || metaKey || shiftKey) {
          return;
        } // If the event is bubbled from the media element
        // Firefox doesn't get the key for whatever reason
  
  
        if (!key) {
          return;
        } // Seek by increment
  
  
        const seekByIncrement = increment => {
          // Divide the max duration into 10th's and times by the number value
          player.currentTime = player.duration / 10 * increment;
        }; // Handle the key on keydown
        // Reset on keyup
  
  
        if (pressed) {
          // Check focused element
          // and if the focused element is not editable (e.g. text input)
          // and any that accept key input http://webaim.org/techniques/keyboard/
          const focused = document.activeElement;
  
          if (is.element(focused)) {
            const {
              editable
            } = player.config.selectors;
            const {
              seek
            } = elements.inputs;
  
            if (focused !== seek && matches(focused, editable)) {
              return;
            }
  
            if (event.key === 'Space' && matches(focused, 'button, [role^="menuitem"]')) {
              return;
            }
          } // Which keys should we prevent default
  
  
          const preventDefault = ['Space', 'ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'c', 'f', 'k', 'l', 'm']; // If the key is found prevent default (e.g. prevent scrolling for arrows)
  
          if (preventDefault.includes(key)) {
            event.preventDefault();
            event.stopPropagation();
          }
  
          switch (key) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              if (!repeat) {
                seekByIncrement(parseInt(key, 10));
              }
  
              break;
  
            case 'Space':
            case 'k':
              if (!repeat) {
                silencePromise(player.togglePlay());
              }
  
              break;
  
            case 'ArrowUp':
              player.increaseVolume(0.1);
              break;
  
            case 'ArrowDown':
              player.decreaseVolume(0.1);
              break;
  
            case 'm':
              if (!repeat) {
                player.muted = !player.muted;
              }
  
              break;
  
            case 'ArrowRight':
              player.forward();
              break;
  
            case 'ArrowLeft':
              player.rewind();
              break;
  
            case 'f':
              player.fullscreen.toggle();
              break;
  
            case 'c':
              if (!repeat) {
                player.toggleCaptions();
              }
  
              break;
  
            case 'l':
              player.loop = !player.loop;
              break;
          } // Escape is handle natively when in full screen
          // So we only need to worry about non native
  
  
          if (key === 'Escape' && !player.fullscreen.usingNative && player.fullscreen.active) {
            player.fullscreen.toggle();
          } // Store last key for next cycle
  
  
          this.lastKey = key;
        } else {
          this.lastKey = null;
        }
      } // Toggle menu
  
  
      toggleMenu(event) {
        controls.toggleMenu.call(this.player, event);
      } // Device is touch enabled
  
  
    }
  
    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  
    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }
  
    var loadjs_umd = createCommonjsModule(function (module, exports) {
      (function (root, factory) {
        {
          module.exports = factory();
        }
      })(commonjsGlobal, function () {
        /**
         * Global dependencies.
         * @global {Object} document - DOM
         */
        var devnull = function () {},
            bundleIdCache = {},
            bundleResultCache = {},
            bundleCallbackQueue = {};
        /**
         * Subscribe to bundle load event.
         * @param {string[]} bundleIds - Bundle ids
         * @param {Function} callbackFn - The callback function
         */
  
  
        function subscribe(bundleIds, callbackFn) {
          // listify
          bundleIds = bundleIds.push ? bundleIds : [bundleIds];
          var depsNotFound = [],
              i = bundleIds.length,
              numWaiting = i,
              fn,
              bundleId,
              r,
              q; // define callback function
  
          fn = function (bundleId, pathsNotFound) {
            if (pathsNotFound.length) depsNotFound.push(bundleId);
            numWaiting--;
            if (!numWaiting) callbackFn(depsNotFound);
          }; // register callback
  
  
          while (i--) {
            bundleId = bundleIds[i]; // execute callback if in result cache
  
            r = bundleResultCache[bundleId];
  
            if (r) {
              fn(bundleId, r);
              continue;
            } // add to callback queue
  
  
            q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
            q.push(fn);
          }
        }
        /**
         * Publish bundle load event.
         * @param {string} bundleId - Bundle id
         * @param {string[]} pathsNotFound - List of files not found
         */
  
  
        function publish(bundleId, pathsNotFound) {
          // exit if id isn't defined
          if (!bundleId) return;
          var q = bundleCallbackQueue[bundleId]; // cache result
  
          bundleResultCache[bundleId] = pathsNotFound; // exit if queue is empty
  
          if (!q) return; // empty callback queue
  
          while (q.length) {
            q[0](bundleId, pathsNotFound);
            q.splice(0, 1);
          }
        }
        /**
         * Execute callbacks.
         * @param {Object or Function} args - The callback args
         * @param {string[]} depsNotFound - List of dependencies not found
         */
  
  
        function executeCallbacks(args, depsNotFound) {
          // accept function as argument
          if (args.call) args = {
            success: args
          }; // success and error callbacks
  
          if (depsNotFound.length) (args.error || devnull)(depsNotFound);else (args.success || devnull)(args);
        }
        /**
         * Load individual file.
         * @param {string} path - The file path
         * @param {Function} callbackFn - The callback function
         */
  
  
        function loadFile(path, callbackFn, args, numTries) {
          var doc = document,
              async = args.async,
              maxTries = (args.numRetries || 0) + 1,
              beforeCallbackFn = args.before || devnull,
              pathname = path.replace(/[\?|#].*$/, ''),
              pathStripped = path.replace(/^(css|img)!/, ''),
              isLegacyIECss,
              e;
          numTries = numTries || 0;
  
          if (/(^css!|\.css$)/.test(pathname)) {
            // css
            e = doc.createElement('link');
            e.rel = 'stylesheet';
            e.href = pathStripped; // tag IE9+
  
            isLegacyIECss = 'hideFocus' in e; // use preload in IE Edge (to detect load errors)
  
            if (isLegacyIECss && e.relList) {
              isLegacyIECss = 0;
              e.rel = 'preload';
              e.as = 'style';
            }
          } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
            // image
            e = doc.createElement('img');
            e.src = pathStripped;
          } else {
            // javascript
            e = doc.createElement('script');
            e.src = path;
            e.async = async === undefined ? true : async;
          }
  
          e.onload = e.onerror = e.onbeforeload = function (ev) {
            var result = ev.type[0]; // treat empty stylesheets as failures to get around lack of onerror
            // support in IE9-11
  
            if (isLegacyIECss) {
              try {
                if (!e.sheet.cssText.length) result = 'e';
              } catch (x) {
                // sheets objects created from load errors don't allow access to
                // `cssText` (unless error is Code:18 SecurityError)
                if (x.code != 18) result = 'e';
              }
            } // handle retries in case of load failure
  
  
            if (result == 'e') {
              // increment counter
              numTries += 1; // exit function and try again
  
              if (numTries < maxTries) {
                return loadFile(path, callbackFn, args, numTries);
              }
            } else if (e.rel == 'preload' && e.as == 'style') {
              // activate preloaded stylesheets
              return e.rel = 'stylesheet'; // jshint ignore:line
            } // execute callback
  
  
            callbackFn(path, result, ev.defaultPrevented);
          }; // add to document (unless callback returns `false`)
  
  
          if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);
        }
        /**
         * Load multiple files.
         * @param {string[]} paths - The file paths
         * @param {Function} callbackFn - The callback function
         */
  
  
        function loadFiles(paths, callbackFn, args) {
          // listify paths
          paths = paths.push ? paths : [paths];
          var numWaiting = paths.length,
              x = numWaiting,
              pathsNotFound = [],
              fn,
              i; // define callback function
  
          fn = function (path, result, defaultPrevented) {
            // handle error
            if (result == 'e') pathsNotFound.push(path); // handle beforeload event. If defaultPrevented then that means the load
            // will be blocked (ex. Ghostery/ABP on Safari)
  
            if (result == 'b') {
              if (defaultPrevented) pathsNotFound.push(path);else return;
            }
  
            numWaiting--;
            if (!numWaiting) callbackFn(pathsNotFound);
          }; // load scripts
  
  
          for (i = 0; i < x; i++) loadFile(paths[i], fn, args);
        }
        /**
         * Initiate script load and register bundle.
         * @param {(string|string[])} paths - The file paths
         * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success
         *   callback or (3) object literal with success/error arguments, numRetries,
         *   etc.
         * @param {(Function|Object)} [arg2] - The (1) success callback or (2) object
         *   literal with success/error arguments, numRetries, etc.
         */
  
  
        function loadjs(paths, arg1, arg2) {
          var bundleId, args; // bundleId (if string)
  
          if (arg1 && arg1.trim) bundleId = arg1; // args (default is {})
  
          args = (bundleId ? arg2 : arg1) || {}; // throw error if bundle is already defined
  
          if (bundleId) {
            if (bundleId in bundleIdCache) {
              throw "LoadJS";
            } else {
              bundleIdCache[bundleId] = true;
            }
          }
  
          function loadFn(resolve, reject) {
            loadFiles(paths, function (pathsNotFound) {
              // execute callbacks
              executeCallbacks(args, pathsNotFound); // resolve Promise
  
              if (resolve) {
                executeCallbacks({
                  success: resolve,
                  error: reject
                }, pathsNotFound);
              } // publish bundle load event
  
  
              publish(bundleId, pathsNotFound);
            }, args);
          }
  
          if (args.returnPromise) return new Promise(loadFn);else loadFn();
        }
        /**
         * Execute callbacks when dependencies have been satisfied.
         * @param {(string|string[])} deps - List of bundle ids
         * @param {Object} args - success/error arguments
         */
  
  
        loadjs.ready = function ready(deps, args) {
          // subscribe to bundle load event
          subscribe(deps, function (depsNotFound) {
            // execute callbacks
            executeCallbacks(args, depsNotFound);
          });
          return loadjs;
        };
        /**
         * Manually satisfy bundle dependencies.
         * @param {string} bundleId - The bundle id
         */
  
  
        loadjs.done = function done(bundleId) {
          publish(bundleId, []);
        };
        /**
         * Reset loadjs dependencies statuses
         */
  
  
        loadjs.reset = function reset() {
          bundleIdCache = {};
          bundleResultCache = {};
          bundleCallbackQueue = {};
        };
        /**
         * Determine if bundle has already been defined
         * @param String} bundleId - The bundle id
         */
  
  
        loadjs.isDefined = function isDefined(bundleId) {
          return bundleId in bundleIdCache;
        }; // export
  
  
        return loadjs;
      });
    });
  
    // ==========================================================================
    function loadScript(url) {
      return new Promise((resolve, reject) => {
        loadjs_umd(url, {
          success: resolve,
          error: reject
        });
      });
    }
  
    // ==========================================================================
  
    function parseId$1(url) {
      if (is.empty(url)) {
        return null;
      }
  
      if (is.number(Number(url))) {
        return url;
      }
  
      const regex = /^.*(vimeo.com\/|video\/)(\d+).*/;
      return url.match(regex) ? RegExp.$2 : url;
    } // Try to extract a hash for private videos from the URL
  
  
    function parseHash(url) {
      /* This regex matches a hexadecimal hash if given in any of these forms:
       *  - [https://player.]vimeo.com/video/{id}/{hash}[?params]
       *  - [https://player.]vimeo.com/video/{id}?h={hash}[&params]
       *  - [https://player.]vimeo.com/video/{id}?[params]&h={hash}
       *  - video/{id}/{hash}
       * If matched, the hash is available in capture group 4
       */
      const regex = /^.*(vimeo.com\/|video\/)(\d+)(\?.*&*h=|\/)+([\d,a-f]+)/;
      const found = url.match(regex);
      return found && found.length === 5 ? found[4] : null;
    } // Set playback state and trigger change (only on actual change)
  
  
    function assurePlaybackState$1(play) {
      if (play && !this.embed.hasPlayed) {
        this.embed.hasPlayed = true;
      }
  
      if (this.media.paused === play) {
        this.media.paused = !play;
        triggerEvent.call(this, this.media, play ? 'play' : 'pause');
      }
    }
  
    const vimeo = {
      setup() {
        const player = this; // Add embed class for responsive
  
        toggleClass(player.elements.wrapper, player.config.classNames.embed, true); // Set speed options from config
  
        player.options.speed = player.config.speed.options; // Set intial ratio
  
        setAspectRatio.call(player); // Load the SDK if not already
  
        if (!is.object(window.Vimeo)) {
          loadScript(player.config.urls.vimeo.sdk).then(() => {
            vimeo.ready.call(player);
          }).catch(error => {
            player.debug.warn('Vimeo SDK (player.js) failed to load', error);
          });
        } else {
          vimeo.ready.call(player);
        }
      },
  
      // API Ready
      ready() {
        const player = this;
        const config = player.config.vimeo;
        const {
          premium,
          referrerPolicy,
          ...frameParams
        } = config; // Get the source URL or ID
  
        let source = player.media.getAttribute('src');
        let hash = ''; // Get from <div> if needed
  
        if (is.empty(source)) {
          source = player.media.getAttribute(player.config.attributes.embed.id); // hash can also be set as attribute on the <div>
  
          hash = player.media.getAttribute(player.config.attributes.embed.hash);
        } else {
          hash = parseHash(source);
        }
  
        const hashParam = hash ? {
          h: hash
        } : {}; // If the owner has a pro or premium account then we can hide controls etc
  
        if (premium) {
          Object.assign(frameParams, {
            controls: false,
            sidedock: false
          });
        } // Get Vimeo params for the iframe
  
  
        const params = buildUrlParams({
          loop: player.config.loop.active,
          autoplay: player.autoplay,
          muted: player.muted,
          gesture: 'media',
          playsinline: !this.config.fullscreen.iosNative,
          // hash has to be added to iframe-URL
          ...hashParam,
          ...frameParams
        });
        const id = parseId$1(source); // Build an iframe
  
        const iframe = createElement('iframe');
        const src = format(player.config.urls.vimeo.iframe, id, params);
        iframe.setAttribute('src', src);
        iframe.setAttribute('allowfullscreen', '');
        iframe.setAttribute('allow', ['autoplay', 'fullscreen', 'picture-in-picture', 'encrypted-media', 'accelerometer', 'gyroscope'].join('; ')); // Set the referrer policy if required
  
        if (!is.empty(referrerPolicy)) {
          iframe.setAttribute('referrerPolicy', referrerPolicy);
        } // Inject the package
  
  
        if (premium || !config.customControls) {
          iframe.setAttribute('data-poster', player.poster);
          player.media = replaceElement(iframe, player.media);
        } else {
          const wrapper = createElement('div', {
            class: player.config.classNames.embedContainer,
            'data-poster': player.poster
          });
          wrapper.appendChild(iframe);
          player.media = replaceElement(wrapper, player.media);
        } // Get poster image
  
  
        if (!config.customControls) {
          fetch(format(player.config.urls.vimeo.api, src)).then(response => {
            if (is.empty(response) || !response.thumbnail_url) {
              return;
            } // Set and show poster
  
  
            ui.setPoster.call(player, response.thumbnail_url).catch(() => {});
          });
        } // Setup instance
        // https://github.com/vimeo/player.js
  
  
        player.embed = new window.Vimeo.Player(iframe, {
          autopause: player.config.autopause,
          muted: player.muted
        });
        player.media.paused = true;
        player.media.currentTime = 0; // Disable native text track rendering
  
        if (player.supported.ui) {
          player.embed.disableTextTrack();
        } // Create a faux HTML5 API using the Vimeo API
  
  
        player.media.play = () => {
          assurePlaybackState$1.call(player, true);
          return player.embed.play();
        };
  
        player.media.pause = () => {
          assurePlaybackState$1.call(player, false);
          return player.embed.pause();
        };
  
        player.media.stop = () => {
          player.pause();
          player.currentTime = 0;
        }; // Seeking
  
  
        let {
          currentTime
        } = player.media;
        Object.defineProperty(player.media, 'currentTime', {
          get() {
            return currentTime;
          },
  
          set(time) {
            // Vimeo will automatically play on seek if the video hasn't been played before
            // Get current paused state and volume etc
            const {
              embed,
              media,
              paused,
              volume
            } = player;
            const restorePause = paused && !embed.hasPlayed; // Set seeking state and trigger event
  
            media.seeking = true;
            triggerEvent.call(player, media, 'seeking'); // If paused, mute until seek is complete
  
            Promise.resolve(restorePause && embed.setVolume(0)) // Seek
            .then(() => embed.setCurrentTime(time)) // Restore paused
            .then(() => restorePause && embed.pause()) // Restore volume
            .then(() => restorePause && embed.setVolume(volume)).catch(() => {// Do nothing
            });
          }
  
        }); // Playback speed
  
        let speed = player.config.speed.selected;
        Object.defineProperty(player.media, 'playbackRate', {
          get() {
            return speed;
          },
  
          set(input) {
            player.embed.setPlaybackRate(input).then(() => {
              speed = input;
              triggerEvent.call(player, player.media, 'ratechange');
            }).catch(() => {
              // Cannot set Playback Rate, Video is probably not on Pro account
              player.options.speed = [1];
            });
          }
  
        }); // Volume
  
        let {
          volume
        } = player.config;
        Object.defineProperty(player.media, 'volume', {
          get() {
            return volume;
          },
  
          set(input) {
            player.embed.setVolume(input).then(() => {
              volume = input;
              triggerEvent.call(player, player.media, 'volumechange');
            });
          }
  
        }); // Muted
  
        let {
          muted
        } = player.config;
        Object.defineProperty(player.media, 'muted', {
          get() {
            return muted;
          },
  
          set(input) {
            const toggle = is.boolean(input) ? input : false;
            player.embed.setVolume(toggle ? 0 : player.config.volume).then(() => {
              muted = toggle;
              triggerEvent.call(player, player.media, 'volumechange');
            });
          }
  
        }); // Loop
  
        let {
          loop
        } = player.config;
        Object.defineProperty(player.media, 'loop', {
          get() {
            return loop;
          },
  
          set(input) {
            const toggle = is.boolean(input) ? input : player.config.loop.active;
            player.embed.setLoop(toggle).then(() => {
              loop = toggle;
            });
          }
  
        }); // Source
  
        let currentSrc;
        player.embed.getVideoUrl().then(value => {
          currentSrc = value;
          controls.setDownloadUrl.call(player);
        }).catch(error => {
          this.debug.warn(error);
        });
        Object.defineProperty(player.media, 'currentSrc', {
          get() {
            return currentSrc;
          }
  
        }); // Ended
  
        Object.defineProperty(player.media, 'ended', {
          get() {
            return player.currentTime === player.duration;
          }
  
        }); // Set aspect ratio based on video size
  
        Promise.all([player.embed.getVideoWidth(), player.embed.getVideoHeight()]).then(dimensions => {
          const [width, height] = dimensions;
          player.embed.ratio = roundAspectRatio(width, height);
          setAspectRatio.call(this);
        }); // Set autopause
  
        player.embed.setAutopause(player.config.autopause).then(state => {
          player.config.autopause = state;
        }); // Get title
  
        player.embed.getVideoTitle().then(title => {
          player.config.title = title;
          ui.setTitle.call(this);
        }); // Get current time
  
        player.embed.getCurrentTime().then(value => {
          currentTime = value;
          triggerEvent.call(player, player.media, 'timeupdate');
        }); // Get duration
  
        player.embed.getDuration().then(value => {
          player.media.duration = value;
          triggerEvent.call(player, player.media, 'durationchange');
        }); // Get captions
  
        player.embed.getTextTracks().then(tracks => {
          player.media.textTracks = tracks;
          captions.setup.call(player);
        });
        player.embed.on('cuechange', ({
          cues = []
        }) => {
          const strippedCues = cues.map(cue => stripHTML(cue.text));
          captions.updateCues.call(player, strippedCues);
        });
        player.embed.on('loaded', () => {
          // Assure state and events are updated on autoplay
          player.embed.getPaused().then(paused => {
            assurePlaybackState$1.call(player, !paused);
  
            if (!paused) {
              triggerEvent.call(player, player.media, 'playing');
            }
          });
  
          if (is.element(player.embed.element) && player.supported.ui) {
            const frame = player.embed.element; // Fix keyboard focus issues
            // https://github.com/sampotts/plyr/issues/317
  
            frame.setAttribute('tabindex', -1);
          }
        });
        player.embed.on('bufferstart', () => {
          triggerEvent.call(player, player.media, 'waiting');
        });
        player.embed.on('bufferend', () => {
          triggerEvent.call(player, player.media, 'playing');
        });
        player.embed.on('play', () => {
          assurePlaybackState$1.call(player, true);
          triggerEvent.call(player, player.media, 'playing');
        });
        player.embed.on('pause', () => {
          assurePlaybackState$1.call(player, false);
        });
        player.embed.on('timeupdate', data => {
          player.media.seeking = false;
          currentTime = data.seconds;
          triggerEvent.call(player, player.media, 'timeupdate');
        });
        player.embed.on('progress', data => {
          player.media.buffered = data.percent;
          triggerEvent.call(player, player.media, 'progress'); // Check all loaded
  
          if (parseInt(data.percent, 10) === 1) {
            triggerEvent.call(player, player.media, 'canplaythrough');
          } // Get duration as if we do it before load, it gives an incorrect value
          // https://github.com/sampotts/plyr/issues/891
  
  
          player.embed.getDuration().then(value => {
            if (value !== player.media.duration) {
              player.media.duration = value;
              triggerEvent.call(player, player.media, 'durationchange');
            }
          });
        });
        player.embed.on('seeked', () => {
          player.media.seeking = false;
          triggerEvent.call(player, player.media, 'seeked');
        });
        player.embed.on('ended', () => {
          player.media.paused = true;
          triggerEvent.call(player, player.media, 'ended');
        });
        player.embed.on('error', detail => {
          player.media.error = detail;
          triggerEvent.call(player, player.media, 'error');
        }); // Rebuild UI
  
        if (config.customControls) {
          setTimeout(() => ui.build.call(player), 0);
        }
      }
  
    };
  
    // ==========================================================================
  
    function parseId(url) {
      if (is.empty(url)) {
        return null;
      }
  
      const regex = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
      return url.match(regex) ? RegExp.$2 : url;
    } // Set playback state and trigger change (only on actual change)
  
  
    function assurePlaybackState(play) {
      if (play && !this.embed.hasPlayed) {
        this.embed.hasPlayed = true;
      }
  
      if (this.media.paused === play) {
        this.media.paused = !play;
        triggerEvent.call(this, this.media, play ? 'play' : 'pause');
      }
    }
  
    function getHost(config) {
      if (config.noCookie) {
        return 'https://www.youtube-nocookie.com';
      }
  
      if (window.location.protocol === 'http:') {
        return 'http://www.youtube.com';
      } // Use YouTube's default
  
  
      return undefined;
    }
  
    const youtube = {
      setup() {
        // Add embed class for responsive
        toggleClass(this.elements.wrapper, this.config.classNames.embed, true); // Setup API
  
        if (is.object(window.YT) && is.function(window.YT.Player)) {
          youtube.ready.call(this);
        } else {
          // Reference current global callback
          const callback = window.onYouTubeIframeAPIReady; // Set callback to process queue
  
          window.onYouTubeIframeAPIReady = () => {
            // Call global callback if set
            if (is.function(callback)) {
              callback();
            }
  
            youtube.ready.call(this);
          }; // Load the SDK
  
  
          loadScript(this.config.urls.youtube.sdk).catch(error => {
            this.debug.warn('YouTube API failed to load', error);
          });
        }
      },
  
      // Get the media title
      getTitle(videoId) {
        const url = format(this.config.urls.youtube.api, videoId);
        fetch(url).then(data => {
          if (is.object(data)) {
            const {
              title,
              height,
              width
            } = data; // Set title
  
            this.config.title = title;
            ui.setTitle.call(this); // Set aspect ratio
  
            this.embed.ratio = roundAspectRatio(width, height);
          }
  
          setAspectRatio.call(this);
        }).catch(() => {
          // Set aspect ratio
          setAspectRatio.call(this);
        });
      },
  
      // API ready
      ready() {
        const player = this;
        const config = player.config.youtube; // Ignore already setup (race condition)
  
        const currentId = player.media && player.media.getAttribute('id');
  
        if (!is.empty(currentId) && currentId.startsWith('youtube-')) {
          return;
        } // Get the source URL or ID
  
  
        let source = player.media.getAttribute('src'); // Get from <div> if needed
  
        if (is.empty(source)) {
          source = player.media.getAttribute(this.config.attributes.embed.id);
        } // Replace the <iframe> with a <div> due to YouTube API issues
  
  
        const videoId = parseId(source);
        const id = generateId(player.provider); // Replace media element
  
        const container = createElement('div', {
          id,
          'data-poster': config.customControls ? player.poster : undefined
        });
        player.media = replaceElement(container, player.media); // Only load the poster when using custom controls
  
        if (config.customControls) {
          const posterSrc = s => `https://i.ytimg.com/vi/${videoId}/${s}default.jpg`; // Check thumbnail images in order of quality, but reject fallback thumbnails (120px wide)
  
  
          loadImage(posterSrc('maxres'), 121) // Higest quality and unpadded
          .catch(() => loadImage(posterSrc('sd'), 121)) // 480p padded 4:3
          .catch(() => loadImage(posterSrc('hq'))) // 360p padded 4:3. Always exists
          .then(image => ui.setPoster.call(player, image.src)).then(src => {
            // If the image is padded, use background-size "cover" instead (like youtube does too with their posters)
            if (!src.includes('maxres')) {
              player.elements.poster.style.backgroundSize = 'cover';
            }
          }).catch(() => {});
        } // Setup instance
        // https://developers.google.com/youtube/iframe_api_reference
  
  
        player.embed = new window.YT.Player(player.media, {
          videoId,
          host: getHost(config),
          playerVars: extend({}, {
            // Autoplay
            autoplay: player.config.autoplay ? 1 : 0,
            // iframe interface language
            hl: player.config.hl,
            // Only show controls if not fully supported or opted out
            controls: player.supported.ui && config.customControls ? 0 : 1,
            // Disable keyboard as we handle it
            disablekb: 1,
            // Allow iOS inline playback
            playsinline: !player.config.fullscreen.iosNative ? 1 : 0,
            // Captions are flaky on YouTube
            cc_load_policy: player.captions.active ? 1 : 0,
            cc_lang_pref: player.config.captions.language,
            // Tracking for stats
            widget_referrer: window ? window.location.href : null
          }, config),
          events: {
            onError(event) {
              // YouTube may fire onError twice, so only handle it once
              if (!player.media.error) {
                const code = event.data; // Messages copied from https://developers.google.com/youtube/iframe_api_reference#onError
  
                const message = {
                  2: 'The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.',
                  5: 'The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.',
                  100: 'The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.',
                  101: 'The owner of the requested video does not allow it to be played in embedded players.',
                  150: 'The owner of the requested video does not allow it to be played in embedded players.'
                }[code] || 'An unknown error occured';
                player.media.error = {
                  code,
                  message
                };
                triggerEvent.call(player, player.media, 'error');
              }
            },
  
            onPlaybackRateChange(event) {
              // Get the instance
              const instance = event.target; // Get current speed
  
              player.media.playbackRate = instance.getPlaybackRate();
              triggerEvent.call(player, player.media, 'ratechange');
            },
  
            onReady(event) {
              // Bail if onReady has already been called. See issue #1108
              if (is.function(player.media.play)) {
                return;
              } // Get the instance
  
  
              const instance = event.target; // Get the title
  
              youtube.getTitle.call(player, videoId); // Create a faux HTML5 API using the YouTube API
  
              player.media.play = () => {
                assurePlaybackState.call(player, true);
                instance.playVideo();
              };
  
              player.media.pause = () => {
                assurePlaybackState.call(player, false);
                instance.pauseVideo();
              };
  
              player.media.stop = () => {
                instance.stopVideo();
              };
  
              player.media.duration = instance.getDuration();
              player.media.paused = true; // Seeking
  
              player.media.currentTime = 0;
              Object.defineProperty(player.media, 'currentTime', {
                get() {
                  return Number(instance.getCurrentTime());
                },
  
                set(time) {
                  // If paused and never played, mute audio preventively (YouTube starts playing on seek if the video hasn't been played yet).
                  if (player.paused && !player.embed.hasPlayed) {
                    player.embed.mute();
                  } // Set seeking state and trigger event
  
  
                  player.media.seeking = true;
                  triggerEvent.call(player, player.media, 'seeking'); // Seek after events sent
  
                  instance.seekTo(time);
                }
  
              }); // Playback speed
  
              Object.defineProperty(player.media, 'playbackRate', {
                get() {
                  return instance.getPlaybackRate();
                },
  
                set(input) {
                  instance.setPlaybackRate(input);
                }
  
              }); // Volume
  
              let {
                volume
              } = player.config;
              Object.defineProperty(player.media, 'volume', {
                get() {
                  return volume;
                },
  
                set(input) {
                  volume = input;
                  instance.setVolume(volume * 100);
                  triggerEvent.call(player, player.media, 'volumechange');
                }
  
              }); // Muted
  
              let {
                muted
              } = player.config;
              Object.defineProperty(player.media, 'muted', {
                get() {
                  return muted;
                },
  
                set(input) {
                  const toggle = is.boolean(input) ? input : muted;
                  muted = toggle;
                  instance[toggle ? 'mute' : 'unMute']();
                  instance.setVolume(volume * 100);
                  triggerEvent.call(player, player.media, 'volumechange');
                }
  
              }); // Source
  
              Object.defineProperty(player.media, 'currentSrc', {
                get() {
                  return instance.getVideoUrl();
                }
  
              }); // Ended
  
              Object.defineProperty(player.media, 'ended', {
                get() {
                  return player.currentTime === player.duration;
                }
  
              }); // Get available speeds
  
              const speeds = instance.getAvailablePlaybackRates(); // Filter based on config
  
              player.options.speed = speeds.filter(s => player.config.speed.options.includes(s)); // Set the tabindex to avoid focus entering iframe
  
              if (player.supported.ui && config.customControls) {
                player.media.setAttribute('tabindex', -1);
              }
  
              triggerEvent.call(player, player.media, 'timeupdate');
              triggerEvent.call(player, player.media, 'durationchange'); // Reset timer
  
              clearInterval(player.timers.buffering); // Setup buffering
  
              player.timers.buffering = setInterval(() => {
                // Get loaded % from YouTube
                player.media.buffered = instance.getVideoLoadedFraction(); // Trigger progress only when we actually buffer something
  
                if (player.media.lastBuffered === null || player.media.lastBuffered < player.media.buffered) {
                  triggerEvent.call(player, player.media, 'progress');
                } // Set last buffer point
  
  
                player.media.lastBuffered = player.media.buffered; // Bail if we're at 100%
  
                if (player.media.buffered === 1) {
                  clearInterval(player.timers.buffering); // Trigger event
  
                  triggerEvent.call(player, player.media, 'canplaythrough');
                }
              }, 200); // Rebuild UI
  
              if (config.customControls) {
                setTimeout(() => ui.build.call(player), 50);
              }
            },
  
            onStateChange(event) {
              // Get the instance
              const instance = event.target; // Reset timer
  
              clearInterval(player.timers.playing);
              const seeked = player.media.seeking && [1, 2].includes(event.data);
  
              if (seeked) {
                // Unset seeking and fire seeked event
                player.media.seeking = false;
                triggerEvent.call(player, player.media, 'seeked');
              } // Handle events
              // -1   Unstarted
              // 0    Ended
              // 1    Playing
              // 2    Paused
              // 3    Buffering
              // 5    Video cued
  
  
              switch (event.data) {
                case -1:
                  // Update scrubber
                  triggerEvent.call(player, player.media, 'timeupdate'); // Get loaded % from YouTube
  
                  player.media.buffered = instance.getVideoLoadedFraction();
                  triggerEvent.call(player, player.media, 'progress');
                  break;
  
                case 0:
                  assurePlaybackState.call(player, false); // YouTube doesn't support loop for a single video, so mimick it.
  
                  if (player.media.loop) {
                    // YouTube needs a call to `stopVideo` before playing again
                    instance.stopVideo();
                    instance.playVideo();
                  } else {
                    triggerEvent.call(player, player.media, 'ended');
                  }
  
                  break;
  
                case 1:
                  // Restore paused state (YouTube starts playing on seek if the video hasn't been played yet)
                  if (config.customControls && !player.config.autoplay && player.media.paused && !player.embed.hasPlayed) {
                    player.media.pause();
                  } else {
                    assurePlaybackState.call(player, true);
                    triggerEvent.call(player, player.media, 'playing'); // Poll to get playback progress
  
                    player.timers.playing = setInterval(() => {
                      triggerEvent.call(player, player.media, 'timeupdate');
                    }, 50); // Check duration again due to YouTube bug
                    // https://github.com/sampotts/plyr/issues/374
                    // https://code.google.com/p/gdata-issues/issues/detail?id=8690
  
                    if (player.media.duration !== instance.getDuration()) {
                      player.media.duration = instance.getDuration();
                      triggerEvent.call(player, player.media, 'durationchange');
                    }
                  }
  
                  break;
  
                case 2:
                  // Restore audio (YouTube starts playing on seek if the video hasn't been played yet)
                  if (!player.muted) {
                    player.embed.unMute();
                  }
  
                  assurePlaybackState.call(player, false);
                  break;
  
                case 3:
                  // Trigger waiting event to add loading classes to container as the video buffers.
                  triggerEvent.call(player, player.media, 'waiting');
                  break;
              }
  
              triggerEvent.call(player, player.elements.container, 'statechange', false, {
                code: event.data
              });
            }
  
          }
        });
      }
  
    };
  
    // ==========================================================================
    const media = {
      // Setup media
      setup() {
        // If there's no media, bail
        if (!this.media) {
          this.debug.warn('No media element found!');
          return;
        } // Add type class
  
  
        toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', this.type), true); // Add provider class
  
        toggleClass(this.elements.container, this.config.classNames.provider.replace('{0}', this.provider), true); // Add video class for embeds
        // This will require changes if audio embeds are added
  
        if (this.isEmbed) {
          toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', 'video'), true);
        } // Inject the player wrapper
  
  
        if (this.isVideo) {
          // Create the wrapper div
          this.elements.wrapper = createElement('div', {
            class: this.config.classNames.video
          }); // Wrap the video in a container
  
          wrap(this.media, this.elements.wrapper); // Poster image container
  
          this.elements.poster = createElement('div', {
            class: this.config.classNames.poster
          });
          this.elements.wrapper.appendChild(this.elements.poster);
        }
  
        if (this.isHTML5) {
          html5.setup.call(this);
        } else if (this.isYouTube) {
          youtube.setup.call(this);
        } else if (this.isVimeo) {
          vimeo.setup.call(this);
        }
      }
  
    };
  
    const destroy = instance => {
      // Destroy our adsManager
      if (instance.manager) {
        instance.manager.destroy();
      } // Destroy our adsManager
  
  
      if (instance.elements.displayContainer) {
        instance.elements.displayContainer.destroy();
      }
  
      instance.elements.container.remove();
    };
  
    class Ads {
      /**
       * Ads constructor.
       * @param {Object} player
       * @return {Ads}
       */
      constructor(player) {
        _defineProperty$1(this, "load", () => {
          if (!this.enabled) {
            return;
          } // Check if the Google IMA3 SDK is loaded or load it ourselves
  
  
          if (!is.object(window.google) || !is.object(window.google.ima)) {
            loadScript(this.player.config.urls.googleIMA.sdk).then(() => {
              this.ready();
            }).catch(() => {
              // Script failed to load or is blocked
              this.trigger('error', new Error('Google IMA SDK failed to load'));
            });
          } else {
            this.ready();
          }
        });
  
        _defineProperty$1(this, "ready", () => {
          // Double check we're enabled
          if (!this.enabled) {
            destroy(this);
          } // Start ticking our safety timer. If the whole advertisement
          // thing doesn't resolve within our set time; we bail
  
  
          this.startSafetyTimer(12000, 'ready()'); // Clear the safety timer
  
          this.managerPromise.then(() => {
            this.clearSafetyTimer('onAdsManagerLoaded()');
          }); // Set listeners on the Plyr instance
  
          this.listeners(); // Setup the IMA SDK
  
          this.setupIMA();
        });
  
        _defineProperty$1(this, "setupIMA", () => {
          // Create the container for our advertisements
          this.elements.container = createElement('div', {
            class: this.player.config.classNames.ads
          });
          this.player.elements.container.appendChild(this.elements.container); // So we can run VPAID2
  
          google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED); // Set language
  
          google.ima.settings.setLocale(this.player.config.ads.language); // Set playback for iOS10+
  
          google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline); // We assume the adContainer is the video container of the plyr element that will house the ads
  
          this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media); // Create ads loader
  
          this.loader = new google.ima.AdsLoader(this.elements.displayContainer); // Listen and respond to ads loaded and error events
  
          this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, event => this.onAdsManagerLoaded(event), false);
          this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, error => this.onAdError(error), false); // Request video ads to be pre-loaded
  
          this.requestAds();
        });
  
        _defineProperty$1(this, "requestAds", () => {
          const {
            container
          } = this.player.elements;
  
          try {
            // Request video ads
            const request = new google.ima.AdsRequest();
            request.adTagUrl = this.tagUrl; // Specify the linear and nonlinear slot sizes. This helps the SDK
            // to select the correct creative if multiple are returned
  
            request.linearAdSlotWidth = container.offsetWidth;
            request.linearAdSlotHeight = container.offsetHeight;
            request.nonLinearAdSlotWidth = container.offsetWidth;
            request.nonLinearAdSlotHeight = container.offsetHeight; // We only overlay ads as we only support video.
  
            request.forceNonLinearFullSlot = false; // Mute based on current state
  
            request.setAdWillPlayMuted(!this.player.muted);
            this.loader.requestAds(request);
          } catch (error) {
            this.onAdError(error);
          }
        });
  
        _defineProperty$1(this, "pollCountdown", (start = false) => {
          if (!start) {
            clearInterval(this.countdownTimer);
            this.elements.container.removeAttribute('data-badge-text');
            return;
          }
  
          const update = () => {
            const time = formatTime(Math.max(this.manager.getRemainingTime(), 0));
            const label = `${i18n.get('advertisement', this.player.config)} - ${time}`;
            this.elements.container.setAttribute('data-badge-text', label);
          };
  
          this.countdownTimer = setInterval(update, 100);
        });
  
        _defineProperty$1(this, "onAdsManagerLoaded", event => {
          // Load could occur after a source change (race condition)
          if (!this.enabled) {
            return;
          } // Get the ads manager
  
  
          const settings = new google.ima.AdsRenderingSettings(); // Tell the SDK to save and restore content video state on our behalf
  
          settings.restoreCustomPlaybackStateOnAdBreakComplete = true;
          settings.enablePreloading = true; // The SDK is polling currentTime on the contentPlayback. And needs a duration
          // so it can determine when to start the mid- and post-roll
  
          this.manager = event.getAdsManager(this.player, settings); // Get the cue points for any mid-rolls by filtering out the pre- and post-roll
  
          this.cuePoints = this.manager.getCuePoints(); // Add listeners to the required events
          // Advertisement error events
  
          this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, error => this.onAdError(error)); // Advertisement regular events
  
          Object.keys(google.ima.AdEvent.Type).forEach(type => {
            this.manager.addEventListener(google.ima.AdEvent.Type[type], e => this.onAdEvent(e));
          }); // Resolve our adsManager
  
          this.trigger('loaded');
        });
  
        _defineProperty$1(this, "addCuePoints", () => {
          // Add advertisement cue's within the time line if available
          if (!is.empty(this.cuePoints)) {
            this.cuePoints.forEach(cuePoint => {
              if (cuePoint !== 0 && cuePoint !== -1 && cuePoint < this.player.duration) {
                const seekElement = this.player.elements.progress;
  
                if (is.element(seekElement)) {
                  const cuePercentage = 100 / this.player.duration * cuePoint;
                  const cue = createElement('span', {
                    class: this.player.config.classNames.cues
                  });
                  cue.style.left = `${cuePercentage.toString()}%`;
                  seekElement.appendChild(cue);
                }
              }
            });
          }
        });
  
        _defineProperty$1(this, "onAdEvent", event => {
          const {
            container
          } = this.player.elements; // Retrieve the ad from the event. Some events (e.g. ALL_ADS_COMPLETED)
          // don't have ad object associated
  
          const ad = event.getAd();
          const adData = event.getAdData(); // Proxy event
  
          const dispatchEvent = type => {
            triggerEvent.call(this.player, this.player.media, `ads${type.replace(/_/g, '').toLowerCase()}`);
          }; // Bubble the event
  
  
          dispatchEvent(event.type);
  
          switch (event.type) {
            case google.ima.AdEvent.Type.LOADED:
              // This is the first event sent for an ad - it is possible to determine whether the
              // ad is a video ad or an overlay
              this.trigger('loaded'); // Start countdown
  
              this.pollCountdown(true);
  
              if (!ad.isLinear()) {
                // Position AdDisplayContainer correctly for overlay
                ad.width = container.offsetWidth;
                ad.height = container.offsetHeight;
              } // console.info('Ad type: ' + event.getAd().getAdPodInfo().getPodIndex());
              // console.info('Ad time: ' + event.getAd().getAdPodInfo().getTimeOffset());
  
  
              break;
  
            case google.ima.AdEvent.Type.STARTED:
              // Set volume to match player
              this.manager.setVolume(this.player.volume);
              break;
  
            case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
              // All ads for the current videos are done. We can now request new advertisements
              // in case the video is re-played
              // TODO: Example for what happens when a next video in a playlist would be loaded.
              // So here we load a new video when all ads are done.
              // Then we load new ads within a new adsManager. When the video
              // Is started - after - the ads are loaded, then we get ads.
              // You can also easily test cancelling and reloading by running
              // player.ads.cancel() and player.ads.play from the console I guess.
              // this.player.source = {
              //     type: 'video',
              //     title: 'View From A Blue Moon',
              //     sources: [{
              //         src:
              // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.mp4', type:
              // 'video/mp4', }], poster:
              // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.jpg', tracks:
              // [ { kind: 'captions', label: 'English', srclang: 'en', src:
              // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.en.vtt',
              // default: true, }, { kind: 'captions', label: 'French', srclang: 'fr', src:
              // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.fr.vtt', }, ],
              // };
              // TODO: So there is still this thing where a video should only be allowed to start
              // playing when the IMA SDK is ready or has failed
              if (this.player.ended) {
                this.loadAds();
              } else {
                // The SDK won't allow new ads to be called without receiving a contentComplete()
                this.loader.contentComplete();
              }
  
              break;
  
            case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
              // This event indicates the ad has started - the video player can adjust the UI,
              // for example display a pause button and remaining time. Fired when content should
              // be paused. This usually happens right before an ad is about to cover the content
              this.pauseContent();
              break;
  
            case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
              // This event indicates the ad has finished - the video player can perform
              // appropriate UI actions, such as removing the timer for remaining time detection.
              // Fired when content should be resumed. This usually happens when an ad finishes
              // or collapses
              this.pollCountdown();
              this.resumeContent();
              break;
  
            case google.ima.AdEvent.Type.LOG:
              if (adData.adError) {
                this.player.debug.warn(`Non-fatal ad error: ${adData.adError.getMessage()}`);
              }
  
              break;
          }
        });
  
        _defineProperty$1(this, "onAdError", event => {
          this.cancel();
          this.player.debug.warn('Ads error', event);
        });
  
        _defineProperty$1(this, "listeners", () => {
          const {
            container
          } = this.player.elements;
          let time;
          this.player.on('canplay', () => {
            this.addCuePoints();
          });
          this.player.on('ended', () => {
            this.loader.contentComplete();
          });
          this.player.on('timeupdate', () => {
            time = this.player.currentTime;
          });
          this.player.on('seeked', () => {
            const seekedTime = this.player.currentTime;
  
            if (is.empty(this.cuePoints)) {
              return;
            }
  
            this.cuePoints.forEach((cuePoint, index) => {
              if (time < cuePoint && cuePoint < seekedTime) {
                this.manager.discardAdBreak();
                this.cuePoints.splice(index, 1);
              }
            });
          }); // Listen to the resizing of the window. And resize ad accordingly
          // TODO: eventually implement ResizeObserver
  
          window.addEventListener('resize', () => {
            if (this.manager) {
              this.manager.resize(container.offsetWidth, container.offsetHeight, google.ima.ViewMode.NORMAL);
            }
          });
        });
  
        _defineProperty$1(this, "play", () => {
          const {
            container
          } = this.player.elements;
  
          if (!this.managerPromise) {
            this.resumeContent();
          } // Play the requested advertisement whenever the adsManager is ready
  
  
          this.managerPromise.then(() => {
            // Set volume to match player
            this.manager.setVolume(this.player.volume); // Initialize the container. Must be done via a user action on mobile devices
  
            this.elements.displayContainer.initialize();
  
            try {
              if (!this.initialized) {
                // Initialize the ads manager. Ad rules playlist will start at this time
                this.manager.init(container.offsetWidth, container.offsetHeight, google.ima.ViewMode.NORMAL); // Call play to start showing the ad. Single video and overlay ads will
                // start at this time; the call will be ignored for ad rules
  
                this.manager.start();
              }
  
              this.initialized = true;
            } catch (adError) {
              // An error may be thrown if there was a problem with the
              // VAST response
              this.onAdError(adError);
            }
          }).catch(() => {});
        });
  
        _defineProperty$1(this, "resumeContent", () => {
          // Hide the advertisement container
          this.elements.container.style.zIndex = ''; // Ad is stopped
  
          this.playing = false; // Play video
  
          silencePromise(this.player.media.play());
        });
  
        _defineProperty$1(this, "pauseContent", () => {
          // Show the advertisement container
          this.elements.container.style.zIndex = 3; // Ad is playing
  
          this.playing = true; // Pause our video.
  
          this.player.media.pause();
        });
  
        _defineProperty$1(this, "cancel", () => {
          // Pause our video
          if (this.initialized) {
            this.resumeContent();
          } // Tell our instance that we're done for now
  
  
          this.trigger('error'); // Re-create our adsManager
  
          this.loadAds();
        });
  
        _defineProperty$1(this, "loadAds", () => {
          // Tell our adsManager to go bye bye
          this.managerPromise.then(() => {
            // Destroy our adsManager
            if (this.manager) {
              this.manager.destroy();
            } // Re-set our adsManager promises
  
  
            this.managerPromise = new Promise(resolve => {
              this.on('loaded', resolve);
              this.player.debug.log(this.manager);
            }); // Now that the manager has been destroyed set it to also be un-initialized
  
            this.initialized = false; // Now request some new advertisements
  
            this.requestAds();
          }).catch(() => {});
        });
  
        _defineProperty$1(this, "trigger", (event, ...args) => {
          const handlers = this.events[event];
  
          if (is.array(handlers)) {
            handlers.forEach(handler => {
              if (is.function(handler)) {
                handler.apply(this, args);
              }
            });
          }
        });
  
        _defineProperty$1(this, "on", (event, callback) => {
          if (!is.array(this.events[event])) {
            this.events[event] = [];
          }
  
          this.events[event].push(callback);
          return this;
        });
  
        _defineProperty$1(this, "startSafetyTimer", (time, from) => {
          this.player.debug.log(`Safety timer invoked from: ${from}`);
          this.safetyTimer = setTimeout(() => {
            this.cancel();
            this.clearSafetyTimer('startSafetyTimer()');
          }, time);
        });
  
        _defineProperty$1(this, "clearSafetyTimer", from => {
          if (!is.nullOrUndefined(this.safetyTimer)) {
            this.player.debug.log(`Safety timer cleared from: ${from}`);
            clearTimeout(this.safetyTimer);
            this.safetyTimer = null;
          }
        });
  
        this.player = player;
        this.config = player.config.ads;
        this.playing = false;
        this.initialized = false;
        this.elements = {
          container: null,
          displayContainer: null
        };
        this.manager = null;
        this.loader = null;
        this.cuePoints = null;
        this.events = {};
        this.safetyTimer = null;
        this.countdownTimer = null; // Setup a promise to resolve when the IMA manager is ready
  
        this.managerPromise = new Promise((resolve, reject) => {
          // The ad is loaded and ready
          this.on('loaded', resolve); // Ads failed
  
          this.on('error', reject);
        });
        this.load();
      }
  
      get enabled() {
        const {
          config
        } = this;
        return this.player.isHTML5 && this.player.isVideo && config.enabled && (!is.empty(config.publisherId) || is.url(config.tagUrl));
      }
      /**
       * Load the IMA SDK
       */
  
  
      // Build the tag URL
      get tagUrl() {
        const {
          config
        } = this;
  
        if (is.url(config.tagUrl)) {
          return config.tagUrl;
        }
  
        const params = {
          AV_PUBLISHERID: '58c25bb0073ef448b1087ad6',
          AV_CHANNELID: '5a0458dc28a06145e4519d21',
          AV_URL: window.location.hostname,
          cb: Date.now(),
          AV_WIDTH: 640,
          AV_HEIGHT: 480,
          AV_CDIM2: config.publisherId
        };
        const base = 'https://go.aniview.com/api/adserver6/vast/';
        return `${base}?${buildUrlParams(params)}`;
      }
      /**
       * In order for the SDK to display ads for our video, we need to tell it where to put them,
       * so here we define our ad container. This div is set up to render on top of the video player.
       * Using the code below, we tell the SDK to render ads within that div. We also provide a
       * handle to the content video player - the SDK will poll the current time of our player to
       * properly place mid-rolls. After we create the ad display container, we initialize it. On
       * mobile devices, this initialization is done as the result of a user action.
       */
  
  
    }
  
    /**
     * Returns a number whose value is limited to the given range.
     *
     * Example: limit the output of this computation to between 0 and 255
     * (x * 255).clamp(0, 255)
     *
     * @param {Number} input
     * @param {Number} min The lower boundary of the output range
     * @param {Number} max The upper boundary of the output range
     * @returns A number within the bounds of min and max
     * @type Number
     */
    function clamp(input = 0, min = 0, max = 255) {
      return Math.min(Math.max(input, min), max);
    }
  
    const parseVtt = vttDataString => {
      const processedList = [];
      const frames = vttDataString.split(/\r\n\r\n|\n\n|\r\r/);
      frames.forEach(frame => {
        const result = {};
        const lines = frame.split(/\r\n|\n|\r/);
        lines.forEach(line => {
          if (!is.number(result.startTime)) {
            // The line with start and end times on it is the first line of interest
            const matchTimes = line.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/); // Note that this currently ignores caption formatting directives that are optionally on the end of this line - fine for non-captions VTT
  
            if (matchTimes) {
              result.startTime = Number(matchTimes[1] || 0) * 60 * 60 + Number(matchTimes[2]) * 60 + Number(matchTimes[3]) + Number(`0.${matchTimes[4]}`);
              result.endTime = Number(matchTimes[6] || 0) * 60 * 60 + Number(matchTimes[7]) * 60 + Number(matchTimes[8]) + Number(`0.${matchTimes[9]}`);
            }
          } else if (!is.empty(line.trim()) && is.empty(result.text)) {
            // If we already have the startTime, then we're definitely up to the text line(s)
            const lineSplit = line.trim().split('#xywh=');
            [result.text] = lineSplit; // If there's content in lineSplit[1], then we have sprites. If not, then it's just one frame per image
  
            if (lineSplit[1]) {
              [result.x, result.y, result.w, result.h] = lineSplit[1].split(',');
            }
          }
        });
  
        if (result.text) {
          processedList.push(result);
        }
      });
      return processedList;
    };
    /**
     * Preview thumbnails for seek hover and scrubbing
     * Seeking: Hover over the seek bar (desktop only): shows a small preview container above the seek bar
     * Scrubbing: Click and drag the seek bar (desktop and mobile): shows the preview image over the entire video, as if the video is scrubbing at very high speed
     *
     * Notes:
     * - Thumbs are set via JS settings on Plyr init, not HTML5 'track' property. Using the track property would be a bit gross, because it doesn't support custom 'kinds'. kind=metadata might be used for something else, and we want to allow multiple thumbnails tracks. Tracks must have a unique combination of 'kind' and 'label'. We would have to do something like kind=metadata,label=thumbnails1 / kind=metadata,label=thumbnails2. Square peg, round hole
     * - VTT info: the image URL is relative to the VTT, not the current document. But if the url starts with a slash, it will naturally be relative to the current domain. https://support.jwplayer.com/articles/how-to-add-preview-thumbnails
     * - This implementation uses multiple separate img elements. Other implementations use background-image on one element. This would be nice and simple, but Firefox and Safari have flickering issues with replacing backgrounds of larger images. It seems that YouTube perhaps only avoids this because they don't have the option for high-res previews (even the fullscreen ones, when mousedown/seeking). Images appear over the top of each other, and previous ones are discarded once the new ones have been rendered
     */
  
  
    const fitRatio = (ratio, outer) => {
      const targetRatio = outer.width / outer.height;
      const result = {};
  
      if (ratio > targetRatio) {
        result.width = outer.width;
        result.height = 1 / ratio * outer.width;
      } else {
        result.height = outer.height;
        result.width = ratio * outer.height;
      }
  
      return result;
    };
  
    class PreviewThumbnails {
      /**
       * PreviewThumbnails constructor.
       * @param {Plyr} player
       * @return {PreviewThumbnails}
       */
      constructor(player) {
        _defineProperty$1(this, "load", () => {
          // Toggle the regular seek tooltip
          if (this.player.elements.display.seekTooltip) {
            this.player.elements.display.seekTooltip.hidden = this.enabled;
          }
  
          if (!this.enabled) return;
          this.getThumbnails().then(() => {
            if (!this.enabled) {
              return;
            } // Render DOM elements
  
  
            this.render(); // Check to see if thumb container size was specified manually in CSS
  
            this.determineContainerAutoSizing();
            this.loaded = true;
          });
        });
  
        _defineProperty$1(this, "getThumbnails", () => {
          return new Promise(resolve => {
            const {
              src
            } = this.player.config.previewThumbnails;
  
            if (is.empty(src)) {
              throw new Error('Missing previewThumbnails.src config attribute');
            } // Resolve promise
  
  
            const sortAndResolve = () => {
              // Sort smallest to biggest (e.g., [120p, 480p, 1080p])
              this.thumbnails.sort((x, y) => x.height - y.height);
              this.player.debug.log('Preview thumbnails', this.thumbnails);
              resolve();
            }; // Via callback()
  
  
            if (is.function(src)) {
              src(thumbnails => {
                this.thumbnails = thumbnails;
                sortAndResolve();
              });
            } // VTT urls
            else {
              // If string, convert into single-element list
              const urls = is.string(src) ? [src] : src; // Loop through each src URL. Download and process the VTT file, storing the resulting data in this.thumbnails
  
              const promises = urls.map(u => this.getThumbnail(u)); // Resolve
  
              Promise.all(promises).then(sortAndResolve);
            }
          });
        });
  
        _defineProperty$1(this, "getThumbnail", url => {
          return new Promise(resolve => {
            fetch(url).then(response => {
              const thumbnail = {
                frames: parseVtt(response),
                height: null,
                urlPrefix: ''
              }; // If the URLs don't start with '/', then we need to set their relative path to be the location of the VTT file
              // If the URLs do start with '/', then they obviously don't need a prefix, so it will remain blank
              // If the thumbnail URLs start with with none of '/', 'http://' or 'https://', then we need to set their relative path to be the location of the VTT file
  
              if (!thumbnail.frames[0].text.startsWith('/') && !thumbnail.frames[0].text.startsWith('http://') && !thumbnail.frames[0].text.startsWith('https://')) {
                thumbnail.urlPrefix = url.substring(0, url.lastIndexOf('/') + 1);
              } // Download the first frame, so that we can determine/set the height of this thumbnailsDef
  
  
              const tempImage = new Image();
  
              tempImage.onload = () => {
                thumbnail.height = tempImage.naturalHeight;
                thumbnail.width = tempImage.naturalWidth;
                this.thumbnails.push(thumbnail);
                resolve();
              };
  
              tempImage.src = thumbnail.urlPrefix + thumbnail.frames[0].text;
            });
          });
        });
  
        _defineProperty$1(this, "startMove", event => {
          if (!this.loaded) return;
          if (!is.event(event) || !['touchmove', 'mousemove'].includes(event.type)) return; // Wait until media has a duration
  
          if (!this.player.media.duration) return;
  
          if (event.type === 'touchmove') {
            // Calculate seek hover position as approx video seconds
            this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
          } else {
            var _this$player$config$m, _this$player$config$m2;
  
            // Calculate seek hover position as approx video seconds
            const clientRect = this.player.elements.progress.getBoundingClientRect();
            const percentage = 100 / clientRect.width * (event.pageX - clientRect.left);
            this.seekTime = this.player.media.duration * (percentage / 100);
  
            if (this.seekTime < 0) {
              // The mousemove fires for 10+px out to the left
              this.seekTime = 0;
            }
  
            if (this.seekTime > this.player.media.duration - 1) {
              // Took 1 second off the duration for safety, because different players can disagree on the real duration of a video
              this.seekTime = this.player.media.duration - 1;
            }
  
            this.mousePosX = event.pageX; // Set time text inside image container
  
            this.elements.thumb.time.innerText = formatTime(this.seekTime); // Get marker point for time
  
            const point = (_this$player$config$m = this.player.config.markers) === null || _this$player$config$m === void 0 ? void 0 : (_this$player$config$m2 = _this$player$config$m.points) === null || _this$player$config$m2 === void 0 ? void 0 : _this$player$config$m2.find(({
              time: t
            }) => t === Math.round(this.seekTime)); // Append the point label to the tooltip
  
            if (point) {
              // this.elements.thumb.time.innerText.concat('\n');
              this.elements.thumb.time.insertAdjacentHTML('afterbegin', `${point.label}<br>`);
            }
          } // Download and show image
  
  
          this.showImageAtCurrentTime();
        });
  
        _defineProperty$1(this, "endMove", () => {
          this.toggleThumbContainer(false, true);
        });
  
        _defineProperty$1(this, "startScrubbing", event => {
          // Only act on left mouse button (0), or touch device (event.button does not exist or is false)
          if (is.nullOrUndefined(event.button) || event.button === false || event.button === 0) {
            this.mouseDown = true; // Wait until media has a duration
  
            if (this.player.media.duration) {
              this.toggleScrubbingContainer(true);
              this.toggleThumbContainer(false, true); // Download and show image
  
              this.showImageAtCurrentTime();
            }
          }
        });
  
        _defineProperty$1(this, "endScrubbing", () => {
          this.mouseDown = false; // Hide scrubbing preview. But wait until the video has successfully seeked before hiding the scrubbing preview
  
          if (Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)) {
            // The video was already seeked/loaded at the chosen time - hide immediately
            this.toggleScrubbingContainer(false);
          } else {
            // The video hasn't seeked yet. Wait for that
            once.call(this.player, this.player.media, 'timeupdate', () => {
              // Re-check mousedown - we might have already started scrubbing again
              if (!this.mouseDown) {
                this.toggleScrubbingContainer(false);
              }
            });
          }
        });
  
        _defineProperty$1(this, "listeners", () => {
          // Hide thumbnail preview - on mouse click, mouse leave (in listeners.js for now), and video play/seek. All four are required, e.g., for buffering
          this.player.on('play', () => {
            this.toggleThumbContainer(false, true);
          });
          this.player.on('seeked', () => {
            this.toggleThumbContainer(false);
          });
          this.player.on('timeupdate', () => {
            this.lastTime = this.player.media.currentTime;
          });
        });
  
        _defineProperty$1(this, "render", () => {
          // Create HTML element: plyr__preview-thumbnail-container
          this.elements.thumb.container = createElement('div', {
            class: this.player.config.classNames.previewThumbnails.thumbContainer
          }); // Wrapper for the image for styling
  
          this.elements.thumb.imageContainer = createElement('div', {
            class: this.player.config.classNames.previewThumbnails.imageContainer
          });
          this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer); // Create HTML element, parent+span: time text (e.g., 01:32:00)
  
          const timeContainer = createElement('div', {
            class: this.player.config.classNames.previewThumbnails.timeContainer
          });
          this.elements.thumb.time = createElement('span', {}, '00:00');
          timeContainer.appendChild(this.elements.thumb.time);
          this.elements.thumb.imageContainer.appendChild(timeContainer); // Inject the whole thumb
  
          if (is.element(this.player.elements.progress)) {
            this.player.elements.progress.appendChild(this.elements.thumb.container);
          } // Create HTML element: plyr__preview-scrubbing-container
  
  
          this.elements.scrubbing.container = createElement('div', {
            class: this.player.config.classNames.previewThumbnails.scrubbingContainer
          });
          this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);
        });
  
        _defineProperty$1(this, "destroy", () => {
          if (this.elements.thumb.container) {
            this.elements.thumb.container.remove();
          }
  
          if (this.elements.scrubbing.container) {
            this.elements.scrubbing.container.remove();
          }
        });
  
        _defineProperty$1(this, "showImageAtCurrentTime", () => {
          if (this.mouseDown) {
            this.setScrubbingContainerSize();
          } else {
            this.setThumbContainerSizeAndPos();
          } // Find the desired thumbnail index
          // TODO: Handle a video longer than the thumbs where thumbNum is null
  
  
          const thumbNum = this.thumbnails[0].frames.findIndex(frame => this.seekTime >= frame.startTime && this.seekTime <= frame.endTime);
          const hasThumb = thumbNum >= 0;
          let qualityIndex = 0; // Show the thumb container if we're not scrubbing
  
          if (!this.mouseDown) {
            this.toggleThumbContainer(hasThumb);
          } // No matching thumb found
  
  
          if (!hasThumb) {
            return;
          } // Check to see if we've already downloaded higher quality versions of this image
  
  
          this.thumbnails.forEach((thumbnail, index) => {
            if (this.loadedImages.includes(thumbnail.frames[thumbNum].text)) {
              qualityIndex = index;
            }
          }); // Only proceed if either thumb num or thumbfilename has changed
  
          if (thumbNum !== this.showingThumb) {
            this.showingThumb = thumbNum;
            this.loadImage(qualityIndex);
          }
        });
  
        _defineProperty$1(this, "loadImage", (qualityIndex = 0) => {
          const thumbNum = this.showingThumb;
          const thumbnail = this.thumbnails[qualityIndex];
          const {
            urlPrefix
          } = thumbnail;
          const frame = thumbnail.frames[thumbNum];
          const thumbFilename = thumbnail.frames[thumbNum].text;
          const thumbUrl = urlPrefix + thumbFilename;
  
          if (!this.currentImageElement || this.currentImageElement.dataset.filename !== thumbFilename) {
            // If we're already loading a previous image, remove its onload handler - we don't want it to load after this one
            // Only do this if not using sprites. Without sprites we really want to show as many images as possible, as a best-effort
            if (this.loadingImage && this.usingSprites) {
              this.loadingImage.onload = null;
            } // We're building and adding a new image. In other implementations of similar functionality (YouTube), background image
            // is instead used. But this causes issues with larger images in Firefox and Safari - switching between background
            // images causes a flicker. Putting a new image over the top does not
  
  
            const previewImage = new Image();
            previewImage.src = thumbUrl;
            previewImage.dataset.index = thumbNum;
            previewImage.dataset.filename = thumbFilename;
            this.showingThumbFilename = thumbFilename;
            this.player.debug.log(`Loading image: ${thumbUrl}`); // For some reason, passing the named function directly causes it to execute immediately. So I've wrapped it in an anonymous function...
  
            previewImage.onload = () => this.showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, true);
  
            this.loadingImage = previewImage;
            this.removeOldImages(previewImage);
          } else {
            // Update the existing image
            this.showImage(this.currentImageElement, frame, qualityIndex, thumbNum, thumbFilename, false);
            this.currentImageElement.dataset.index = thumbNum;
            this.removeOldImages(this.currentImageElement);
          }
        });
  
        _defineProperty$1(this, "showImage", (previewImage, frame, qualityIndex, thumbNum, thumbFilename, newImage = true) => {
          this.player.debug.log(`Showing thumb: ${thumbFilename}. num: ${thumbNum}. qual: ${qualityIndex}. newimg: ${newImage}`);
          this.setImageSizeAndOffset(previewImage, frame);
  
          if (newImage) {
            this.currentImageContainer.appendChild(previewImage);
            this.currentImageElement = previewImage;
  
            if (!this.loadedImages.includes(thumbFilename)) {
              this.loadedImages.push(thumbFilename);
            }
          } // Preload images before and after the current one
          // Show higher quality of the same frame
          // Each step here has a short time delay, and only continues if still hovering/seeking the same spot. This is to protect slow connections from overloading
  
  
          this.preloadNearby(thumbNum, true).then(this.preloadNearby(thumbNum, false)).then(this.getHigherQuality(qualityIndex, previewImage, frame, thumbFilename));
        });
  
        _defineProperty$1(this, "removeOldImages", currentImage => {
          // Get a list of all images, convert it from a DOM list to an array
          Array.from(this.currentImageContainer.children).forEach(image => {
            if (image.tagName.toLowerCase() !== 'img') {
              return;
            }
  
            const removeDelay = this.usingSprites ? 500 : 1000;
  
            if (image.dataset.index !== currentImage.dataset.index && !image.dataset.deleting) {
              // Wait 200ms, as the new image can take some time to show on certain browsers (even though it was downloaded before showing). This will prevent flicker, and show some generosity towards slower clients
              // First set attribute 'deleting' to prevent multi-handling of this on repeat firing of this function
              // eslint-disable-next-line no-param-reassign
              image.dataset.deleting = true; // This has to be set before the timeout - to prevent issues switching between hover and scrub
  
              const {
                currentImageContainer
              } = this;
              setTimeout(() => {
                currentImageContainer.removeChild(image);
                this.player.debug.log(`Removing thumb: ${image.dataset.filename}`);
              }, removeDelay);
            }
          });
        });
  
        _defineProperty$1(this, "preloadNearby", (thumbNum, forward = true) => {
          return new Promise(resolve => {
            setTimeout(() => {
              const oldThumbFilename = this.thumbnails[0].frames[thumbNum].text;
  
              if (this.showingThumbFilename === oldThumbFilename) {
                // Find the nearest thumbs with different filenames. Sometimes it'll be the next index, but in the case of sprites, it might be 100+ away
                let thumbnailsClone;
  
                if (forward) {
                  thumbnailsClone = this.thumbnails[0].frames.slice(thumbNum);
                } else {
                  thumbnailsClone = this.thumbnails[0].frames.slice(0, thumbNum).reverse();
                }
  
                let foundOne = false;
                thumbnailsClone.forEach(frame => {
                  const newThumbFilename = frame.text;
  
                  if (newThumbFilename !== oldThumbFilename) {
                    // Found one with a different filename. Make sure it hasn't already been loaded on this page visit
                    if (!this.loadedImages.includes(newThumbFilename)) {
                      foundOne = true;
                      this.player.debug.log(`Preloading thumb filename: ${newThumbFilename}`);
                      const {
                        urlPrefix
                      } = this.thumbnails[0];
                      const thumbURL = urlPrefix + newThumbFilename;
                      const previewImage = new Image();
                      previewImage.src = thumbURL;
  
                      previewImage.onload = () => {
                        this.player.debug.log(`Preloaded thumb filename: ${newThumbFilename}`);
                        if (!this.loadedImages.includes(newThumbFilename)) this.loadedImages.push(newThumbFilename); // We don't resolve until the thumb is loaded
  
                        resolve();
                      };
                    }
                  }
                }); // If there are none to preload then we want to resolve immediately
  
                if (!foundOne) {
                  resolve();
                }
              }
            }, 300);
          });
        });
  
        _defineProperty$1(this, "getHigherQuality", (currentQualityIndex, previewImage, frame, thumbFilename) => {
          if (currentQualityIndex < this.thumbnails.length - 1) {
            // Only use the higher quality version if it's going to look any better - if the current thumb is of a lower pixel density than the thumbnail container
            let previewImageHeight = previewImage.naturalHeight;
  
            if (this.usingSprites) {
              previewImageHeight = frame.h;
            }
  
            if (previewImageHeight < this.thumbContainerHeight) {
              // Recurse back to the loadImage function - show a higher quality one, but only if the viewer is on this frame for a while
              setTimeout(() => {
                // Make sure the mouse hasn't already moved on and started hovering at another image
                if (this.showingThumbFilename === thumbFilename) {
                  this.player.debug.log(`Showing higher quality thumb for: ${thumbFilename}`);
                  this.loadImage(currentQualityIndex + 1);
                }
              }, 300);
            }
          }
        });
  
        _defineProperty$1(this, "toggleThumbContainer", (toggle = false, clearShowing = false) => {
          const className = this.player.config.classNames.previewThumbnails.thumbContainerShown;
          this.elements.thumb.container.classList.toggle(className, toggle);
  
          if (!toggle && clearShowing) {
            this.showingThumb = null;
            this.showingThumbFilename = null;
          }
        });
  
        _defineProperty$1(this, "toggleScrubbingContainer", (toggle = false) => {
          const className = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
          this.elements.scrubbing.container.classList.toggle(className, toggle);
  
          if (!toggle) {
            this.showingThumb = null;
            this.showingThumbFilename = null;
          }
        });
  
        _defineProperty$1(this, "determineContainerAutoSizing", () => {
          if (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) {
            // This will prevent auto sizing in this.setThumbContainerSizeAndPos()
            this.sizeSpecifiedInCSS = true;
          }
        });
  
        _defineProperty$1(this, "setThumbContainerSizeAndPos", () => {
          const {
            imageContainer
          } = this.elements.thumb;
  
          if (!this.sizeSpecifiedInCSS) {
            const thumbWidth = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
            imageContainer.style.height = `${this.thumbContainerHeight}px`;
            imageContainer.style.width = `${thumbWidth}px`;
          } else if (imageContainer.clientHeight > 20 && imageContainer.clientWidth < 20) {
            const thumbWidth = Math.floor(imageContainer.clientHeight * this.thumbAspectRatio);
            imageContainer.style.width = `${thumbWidth}px`;
          } else if (imageContainer.clientHeight < 20 && imageContainer.clientWidth > 20) {
            const thumbHeight = Math.floor(imageContainer.clientWidth / this.thumbAspectRatio);
            imageContainer.style.height = `${thumbHeight}px`;
          }
  
          this.setThumbContainerPos();
        });
  
        _defineProperty$1(this, "setThumbContainerPos", () => {
          const scrubberRect = this.player.elements.progress.getBoundingClientRect();
          const containerRect = this.player.elements.container.getBoundingClientRect();
          const {
            container
          } = this.elements.thumb; // Find the lowest and highest desired left-position, so we don't slide out the side of the video container
  
          const min = containerRect.left - scrubberRect.left + 10;
          const max = containerRect.right - scrubberRect.left - container.clientWidth - 10; // Set preview container position to: mousepos, minus seekbar.left, minus half of previewContainer.clientWidth
  
          const position = this.mousePosX - scrubberRect.left - container.clientWidth / 2;
          const clamped = clamp(position, min, max); // Move the popover position
  
          container.style.left = `${clamped}px`; // The arrow can follow the cursor
  
          container.style.setProperty('--preview-arrow-offset', `${position - clamped}px`);
        });
  
        _defineProperty$1(this, "setScrubbingContainerSize", () => {
          const {
            width,
            height
          } = fitRatio(this.thumbAspectRatio, {
            width: this.player.media.clientWidth,
            height: this.player.media.clientHeight
          });
          this.elements.scrubbing.container.style.width = `${width}px`;
          this.elements.scrubbing.container.style.height = `${height}px`;
        });
  
        _defineProperty$1(this, "setImageSizeAndOffset", (previewImage, frame) => {
          if (!this.usingSprites) return; // Find difference between height and preview container height
  
          const multiplier = this.thumbContainerHeight / frame.h; // eslint-disable-next-line no-param-reassign
  
          previewImage.style.height = `${previewImage.naturalHeight * multiplier}px`; // eslint-disable-next-line no-param-reassign
  
          previewImage.style.width = `${previewImage.naturalWidth * multiplier}px`; // eslint-disable-next-line no-param-reassign
  
          previewImage.style.left = `-${frame.x * multiplier}px`; // eslint-disable-next-line no-param-reassign
  
          previewImage.style.top = `-${frame.y * multiplier}px`;
        });
  
        this.player = player;
        this.thumbnails = [];
        this.loaded = false;
        this.lastMouseMoveTime = Date.now();
        this.mouseDown = false;
        this.loadedImages = [];
        this.elements = {
          thumb: {},
          scrubbing: {}
        };
        this.load();
      }
  
      get enabled() {
        return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;
      }
  
      get currentImageContainer() {
        return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer;
      }
  
      get usingSprites() {
        return Object.keys(this.thumbnails[0].frames[0]).includes('w');
      }
  
      get thumbAspectRatio() {
        if (this.usingSprites) {
          return this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h;
        }
  
        return this.thumbnails[0].width / this.thumbnails[0].height;
      }
  
      get thumbContainerHeight() {
        if (this.mouseDown) {
          const {
            height
          } = fitRatio(this.thumbAspectRatio, {
            width: this.player.media.clientWidth,
            height: this.player.media.clientHeight
          });
          return height;
        } // If css is used this needs to return the css height for sprites to work (see setImageSizeAndOffset)
  
  
        if (this.sizeSpecifiedInCSS) {
          return this.elements.thumb.imageContainer.clientHeight;
        }
  
        return Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);
      }
  
      get currentImageElement() {
        return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement;
      }
  
      set currentImageElement(element) {
        if (this.mouseDown) {
          this.currentScrubbingImageElement = element;
        } else {
          this.currentThumbnailImageElement = element;
        }
      }
  
    }
  
    // ==========================================================================
    const source = {
      // Add elements to HTML5 media (source, tracks, etc)
      insertElements(type, attributes) {
        if (is.string(attributes)) {
          insertElement(type, this.media, {
            src: attributes
          });
        } else if (is.array(attributes)) {
          attributes.forEach(attribute => {
            insertElement(type, this.media, attribute);
          });
        }
      },
  
      // Update source
      // Sources are not checked for support so be careful
      change(input) {
        if (!getDeep(input, 'sources.length')) {
          this.debug.warn('Invalid source format');
          return;
        } // Cancel current network requests
  
  
        html5.cancelRequests.call(this); // Destroy instance and re-setup
  
        this.destroy.call(this, () => {
          // Reset quality options
          this.options.quality = []; // Remove elements
  
          removeElement(this.media);
          this.media = null; // Reset class name
  
          if (is.element(this.elements.container)) {
            this.elements.container.removeAttribute('class');
          } // Set the type and provider
  
  
          const {
            sources,
            type
          } = input;
          const [{
            provider = providers.html5,
            src
          }] = sources;
          const tagName = provider === 'html5' ? type : 'div';
          const attributes = provider === 'html5' ? {} : {
            src
          };
          Object.assign(this, {
            provider,
            type,
            // Check for support
            supported: support.check(type, provider, this.config.playsinline),
            // Create new element
            media: createElement(tagName, attributes)
          }); // Inject the new element
  
          this.elements.container.appendChild(this.media); // Autoplay the new source?
  
          if (is.boolean(input.autoplay)) {
            this.config.autoplay = input.autoplay;
          } // Set attributes for audio and video
  
  
          if (this.isHTML5) {
            if (this.config.crossorigin) {
              this.media.setAttribute('crossorigin', '');
            }
  
            if (this.config.autoplay) {
              this.media.setAttribute('autoplay', '');
            }
  
            if (!is.empty(input.poster)) {
              this.poster = input.poster;
            }
  
            if (this.config.loop.active) {
              this.media.setAttribute('loop', '');
            }
  
            if (this.config.muted) {
              this.media.setAttribute('muted', '');
            }
  
            if (this.config.playsinline) {
              this.media.setAttribute('playsinline', '');
            }
          } // Restore class hook
  
  
          ui.addStyleHook.call(this); // Set new sources for html5
  
          if (this.isHTML5) {
            source.insertElements.call(this, 'source', sources);
          } // Set video title
  
  
          this.config.title = input.title; // Set up from scratch
  
          media.setup.call(this); // HTML5 stuff
  
          if (this.isHTML5) {
            // Setup captions
            if (Object.keys(input).includes('tracks')) {
              source.insertElements.call(this, 'track', input.tracks);
            }
          } // If HTML5 or embed but not fully supported, setupInterface and call ready now
  
  
          if (this.isHTML5 || this.isEmbed && !this.supported.ui) {
            // Setup interface
            ui.build.call(this);
          } // Load HTML5 sources
  
  
          if (this.isHTML5) {
            this.media.load();
          } // Update previewThumbnails config & reload plugin
  
  
          if (!is.empty(input.previewThumbnails)) {
            Object.assign(this.config.previewThumbnails, input.previewThumbnails); // Cleanup previewThumbnails plugin if it was loaded
  
            if (this.previewThumbnails && this.previewThumbnails.loaded) {
              this.previewThumbnails.destroy();
              this.previewThumbnails = null;
            } // Create new instance if it is still enabled
  
  
            if (this.config.previewThumbnails.enabled) {
              this.previewThumbnails = new PreviewThumbnails(this);
            }
          } // Update the fullscreen support
  
  
          this.fullscreen.update();
        }, true);
      }
  
    };
  
    // TODO: Use a WeakMap for private globals
    // const globals = new WeakMap();
    // Plyr instance
  
    class Plyr {
      constructor(target, options) {
        _defineProperty$1(this, "play", () => {
          if (!is.function(this.media.play)) {
            return null;
          } // Intecept play with ads
  
  
          if (this.ads && this.ads.enabled) {
            this.ads.managerPromise.then(() => this.ads.play()).catch(() => silencePromise(this.media.play()));
          } // Return the promise (for HTML5)
  
  
          return this.media.play();
        });
  
        _defineProperty$1(this, "pause", () => {
          if (!this.playing || !is.function(this.media.pause)) {
            return null;
          }
  
          return this.media.pause();
        });
  
        _defineProperty$1(this, "togglePlay", input => {
          // Toggle based on current state if nothing passed
          const toggle = is.boolean(input) ? input : !this.playing;
  
          if (toggle) {
            return this.play();
          }
  
          return this.pause();
        });
  
        _defineProperty$1(this, "stop", () => {
          if (this.isHTML5) {
            this.pause();
            this.restart();
          } else if (is.function(this.media.stop)) {
            this.media.stop();
          }
        });
  
        _defineProperty$1(this, "restart", () => {
          this.currentTime = 0;
        });
  
        _defineProperty$1(this, "rewind", seekTime => {
          this.currentTime -= is.number(seekTime) ? seekTime : this.config.seekTime;
        });
  
        _defineProperty$1(this, "forward", seekTime => {
          this.currentTime += is.number(seekTime) ? seekTime : this.config.seekTime;
        });
  
        _defineProperty$1(this, "increaseVolume", step => {
          const volume = this.media.muted ? 0 : this.volume;
          this.volume = volume + (is.number(step) ? step : 0);
        });
  
        _defineProperty$1(this, "decreaseVolume", step => {
          this.increaseVolume(-step);
        });
  
        _defineProperty$1(this, "airplay", () => {
          // Show dialog if supported
          if (support.airplay) {
            this.media.webkitShowPlaybackTargetPicker();
          }
        });
  
        _defineProperty$1(this, "toggleControls", toggle => {
          // Don't toggle if missing UI support or if it's audio
          if (this.supported.ui && !this.isAudio) {
            // Get state before change
            const isHidden = hasClass(this.elements.container, this.config.classNames.hideControls); // Negate the argument if not undefined since adding the class to hides the controls
  
            const force = typeof toggle === 'undefined' ? undefined : !toggle; // Apply and get updated state
  
            const hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force); // Close menu
  
            if (hiding && is.array(this.config.controls) && this.config.controls.includes('settings') && !is.empty(this.config.settings)) {
              controls.toggleMenu.call(this, false);
            } // Trigger event on change
  
  
            if (hiding !== isHidden) {
              const eventName = hiding ? 'controlshidden' : 'controlsshown';
              triggerEvent.call(this, this.media, eventName);
            }
  
            return !hiding;
          }
  
          return false;
        });
  
        _defineProperty$1(this, "on", (event, callback) => {
          on.call(this, this.elements.container, event, callback);
        });
  
        _defineProperty$1(this, "once", (event, callback) => {
          once.call(this, this.elements.container, event, callback);
        });
  
        _defineProperty$1(this, "off", (event, callback) => {
          off(this.elements.container, event, callback);
        });
  
        _defineProperty$1(this, "destroy", (callback, soft = false) => {
          if (!this.ready) {
            return;
          }
  
          const done = () => {
            // Reset overflow (incase destroyed while in fullscreen)
            document.body.style.overflow = ''; // GC for embed
  
            this.embed = null; // If it's a soft destroy, make minimal changes
  
            if (soft) {
              if (Object.keys(this.elements).length) {
                // Remove elements
                removeElement(this.elements.buttons.play);
                removeElement(this.elements.captions);
                removeElement(this.elements.controls);
                removeElement(this.elements.wrapper); // Clear for GC
  
                this.elements.buttons.play = null;
                this.elements.captions = null;
                this.elements.controls = null;
                this.elements.wrapper = null;
              } // Callback
  
  
              if (is.function(callback)) {
                callback();
              }
            } else {
              // Unbind listeners
              unbindListeners.call(this); // Cancel current network requests
  
              html5.cancelRequests.call(this); // Replace the container with the original element provided
  
              replaceElement(this.elements.original, this.elements.container); // Event
  
              triggerEvent.call(this, this.elements.original, 'destroyed', true); // Callback
  
              if (is.function(callback)) {
                callback.call(this.elements.original);
              } // Reset state
  
  
              this.ready = false; // Clear for garbage collection
  
              setTimeout(() => {
                this.elements = null;
                this.media = null;
              }, 200);
            }
          }; // Stop playback
  
  
          this.stop(); // Clear timeouts
  
          clearTimeout(this.timers.loading);
          clearTimeout(this.timers.controls);
          clearTimeout(this.timers.resized); // Provider specific stuff
  
          if (this.isHTML5) {
            // Restore native video controls
            ui.toggleNativeControls.call(this, true); // Clean up
  
            done();
          } else if (this.isYouTube) {
            // Clear timers
            clearInterval(this.timers.buffering);
            clearInterval(this.timers.playing); // Destroy YouTube API
  
            if (this.embed !== null && is.function(this.embed.destroy)) {
              this.embed.destroy();
            } // Clean up
  
  
            done();
          } else if (this.isVimeo) {
            // Destroy Vimeo API
            // then clean up (wait, to prevent postmessage errors)
            if (this.embed !== null) {
              this.embed.unload().then(done);
            } // Vimeo does not always return
  
  
            setTimeout(done, 200);
          }
        });
  
        _defineProperty$1(this, "supports", type => support.mime.call(this, type));
  
        this.timers = {}; // State
  
        this.ready = false;
        this.loading = false;
        this.failed = false; // Touch device
  
        this.touch = support.touch; // Set the media element
  
        this.media = target; // String selector passed
  
        if (is.string(this.media)) {
          this.media = document.querySelectorAll(this.media);
        } // jQuery, NodeList or Array passed, use first element
  
  
        if (window.jQuery && this.media instanceof jQuery || is.nodeList(this.media) || is.array(this.media)) {
          // eslint-disable-next-line
          this.media = this.media[0];
        } // Set config
  
  
        this.config = extend({}, defaults, Plyr.defaults, options || {}, (() => {
          try {
            return JSON.parse(this.media.getAttribute('data-plyr-config'));
          } catch (_) {
            return {};
          }
        })()); // Elements cache
  
        this.elements = {
          container: null,
          fullscreen: null,
          captions: null,
          buttons: {},
          display: {},
          progress: {},
          inputs: {},
          settings: {
            popup: null,
            menu: null,
            panels: {},
            buttons: {}
          }
        }; // Captions
  
        this.captions = {
          active: null,
          currentTrack: -1,
          meta: new WeakMap()
        }; // Fullscreen
  
        this.fullscreen = {
          active: false
        }; // Options
  
        this.options = {
          speed: [],
          quality: []
        }; // Debugging
        // TODO: move to globals
  
        this.debug = new Console(this.config.debug); // Log config options and support
  
        this.debug.log('Config', this.config);
        this.debug.log('Support', support); // We need an element to setup
  
        if (is.nullOrUndefined(this.media) || !is.element(this.media)) {
          this.debug.error('Setup failed: no suitable element passed');
          return;
        } // Bail if the element is initialized
  
  
        if (this.media.plyr) {
          this.debug.warn('Target already setup');
          return;
        } // Bail if not enabled
  
  
        if (!this.config.enabled) {
          this.debug.error('Setup failed: disabled by config');
          return;
        } // Bail if disabled or no basic support
        // You may want to disable certain UAs etc
  
  
        if (!support.check().api) {
          this.debug.error('Setup failed: no support');
          return;
        } // Cache original element state for .destroy()
  
  
        const clone = this.media.cloneNode(true);
        clone.autoplay = false;
        this.elements.original = clone; // Set media type based on tag or data attribute
        // Supported: video, audio, vimeo, youtube
  
        const _type = this.media.tagName.toLowerCase(); // Embed properties
  
  
        let iframe = null;
        let url = null; // Different setup based on type
  
        switch (_type) {
          case 'div':
            // Find the frame
            iframe = this.media.querySelector('iframe'); // <iframe> type
  
            if (is.element(iframe)) {
              // Detect provider
              url = parseUrl(iframe.getAttribute('src'));
              this.provider = getProviderByUrl(url.toString()); // Rework elements
  
              this.elements.container = this.media;
              this.media = iframe; // Reset classname
  
              this.elements.container.className = ''; // Get attributes from URL and set config
  
              if (url.search.length) {
                const truthy = ['1', 'true'];
  
                if (truthy.includes(url.searchParams.get('autoplay'))) {
                  this.config.autoplay = true;
                }
  
                if (truthy.includes(url.searchParams.get('loop'))) {
                  this.config.loop.active = true;
                } // TODO: replace fullscreen.iosNative with this playsinline config option
                // YouTube requires the playsinline in the URL
  
  
                if (this.isYouTube) {
                  this.config.playsinline = truthy.includes(url.searchParams.get('playsinline'));
                  this.config.youtube.hl = url.searchParams.get('hl'); // TODO: Should this be setting language?
                } else {
                  this.config.playsinline = true;
                }
              }
            } else {
              // <div> with attributes
              this.provider = this.media.getAttribute(this.config.attributes.embed.provider); // Remove attribute
  
              this.media.removeAttribute(this.config.attributes.embed.provider);
            } // Unsupported or missing provider
  
  
            if (is.empty(this.provider) || !Object.values(providers).includes(this.provider)) {
              this.debug.error('Setup failed: Invalid provider');
              return;
            } // Audio will come later for external providers
  
  
            this.type = types.video;
            break;
  
          case 'video':
          case 'audio':
            this.type = _type;
            this.provider = providers.html5; // Get config from attributes
  
            if (this.media.hasAttribute('crossorigin')) {
              this.config.crossorigin = true;
            }
  
            if (this.media.hasAttribute('autoplay')) {
              this.config.autoplay = true;
            }
  
            if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {
              this.config.playsinline = true;
            }
  
            if (this.media.hasAttribute('muted')) {
              this.config.muted = true;
            }
  
            if (this.media.hasAttribute('loop')) {
              this.config.loop.active = true;
            }
  
            break;
  
          default:
            this.debug.error('Setup failed: unsupported type');
            return;
        } // Check for support again but with type
  
  
        this.supported = support.check(this.type, this.provider, this.config.playsinline); // If no support for even API, bail
  
        if (!this.supported.api) {
          this.debug.error('Setup failed: no support');
          return;
        }
  
        this.eventListeners = []; // Create listeners
  
        this.listeners = new Listeners(this); // Setup local storage for user settings
  
        this.storage = new Storage(this); // Store reference
  
        this.media.plyr = this; // Wrap media
  
        if (!is.element(this.elements.container)) {
          this.elements.container = createElement('div', {
            tabindex: 0
          });
          wrap(this.media, this.elements.container);
        } // Migrate custom properties from media to container (so they work 😉)
  
  
        ui.migrateStyles.call(this); // Add style hook
  
        ui.addStyleHook.call(this); // Setup media
  
        media.setup.call(this); // Listen for events if debugging
  
        if (this.config.debug) {
          on.call(this, this.elements.container, this.config.events.join(' '), event => {
            this.debug.log(`event: ${event.type}`);
          });
        } // Setup fullscreen
  
  
        this.fullscreen = new Fullscreen(this); // Setup interface
        // If embed but not fully supported, build interface now to avoid flash of controls
  
        if (this.isHTML5 || this.isEmbed && !this.supported.ui) {
          ui.build.call(this);
        } // Container listeners
  
  
        this.listeners.container(); // Global listeners
  
        this.listeners.global(); // Setup ads if provided
  
        if (this.config.ads.enabled) {
          this.ads = new Ads(this);
        } // Autoplay if required
  
  
        if (this.isHTML5 && this.config.autoplay) {
          this.once('canplay', () => silencePromise(this.play()));
        } // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek
  
  
        this.lastSeekTime = 0; // Setup preview thumbnails if enabled
  
        if (this.config.previewThumbnails.enabled) {
          this.previewThumbnails = new PreviewThumbnails(this);
        }
      } // ---------------------------------------
      // API
      // ---------------------------------------
  
      /**
       * Types and provider helpers
       */
  
  
      get isHTML5() {
        return this.provider === providers.html5;
      }
  
      get isEmbed() {
        return this.isYouTube || this.isVimeo;
      }
  
      get isYouTube() {
        return this.provider === providers.youtube;
      }
  
      get isVimeo() {
        return this.provider === providers.vimeo;
      }
  
      get isVideo() {
        return this.type === types.video;
      }
  
      get isAudio() {
        return this.type === types.audio;
      }
      /**
       * Play the media, or play the advertisement (if they are not blocked)
       */
  
  
      /**
       * Get playing state
       */
      get playing() {
        return Boolean(this.ready && !this.paused && !this.ended);
      }
      /**
       * Get paused state
       */
  
  
      get paused() {
        return Boolean(this.media.paused);
      }
      /**
       * Get stopped state
       */
  
  
      get stopped() {
        return Boolean(this.paused && this.currentTime === 0);
      }
      /**
       * Get ended state
       */
  
  
      get ended() {
        return Boolean(this.media.ended);
      }
      /**
       * Toggle playback based on current status
       * @param {Boolean} input
       */
  
  
      /**
       * Seek to a time
       * @param {Number} input - where to seek to in seconds. Defaults to 0 (the start)
       */
      set currentTime(input) {
        // Bail if media duration isn't available yet
        if (!this.duration) {
          return;
        } // Validate input
  
  
        const inputIsValid = is.number(input) && input > 0; // Set
  
        this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0; // Logging
  
        this.debug.log(`Seeking to ${this.currentTime} seconds`);
      }
      /**
       * Get current time
       */
  
  
      get currentTime() {
        return Number(this.media.currentTime);
      }
      /**
       * Get buffered
       */
  
  
      get buffered() {
        const {
          buffered
        } = this.media; // YouTube / Vimeo return a float between 0-1
  
        if (is.number(buffered)) {
          return buffered;
        } // HTML5
        // TODO: Handle buffered chunks of the media
        // (i.e. seek to another section buffers only that section)
  
  
        if (buffered && buffered.length && this.duration > 0) {
          return buffered.end(0) / this.duration;
        }
  
        return 0;
      }
      /**
       * Get seeking status
       */
  
  
      get seeking() {
        return Boolean(this.media.seeking);
      }
      /**
       * Get the duration of the current media
       */
  
  
      get duration() {
        // Faux duration set via config
        const fauxDuration = parseFloat(this.config.duration); // Media duration can be NaN or Infinity before the media has loaded
  
        const realDuration = (this.media || {}).duration;
        const duration = !is.number(realDuration) || realDuration === Infinity ? 0 : realDuration; // If config duration is funky, use regular duration
  
        return fauxDuration || duration;
      }
      /**
       * Set the player volume
       * @param {Number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage
       */
  
  
      set volume(value) {
        let volume = value;
        const max = 1;
        const min = 0;
  
        if (is.string(volume)) {
          volume = Number(volume);
        } // Load volume from storage if no value specified
  
  
        if (!is.number(volume)) {
          volume = this.storage.get('volume');
        } // Use config if all else fails
  
  
        if (!is.number(volume)) {
          ({
            volume
          } = this.config);
        } // Maximum is volumeMax
  
  
        if (volume > max) {
          volume = max;
        } // Minimum is volumeMin
  
  
        if (volume < min) {
          volume = min;
        } // Update config
  
  
        this.config.volume = volume; // Set the player volume
  
        this.media.volume = volume; // If muted, and we're increasing volume manually, reset muted state
  
        if (!is.empty(value) && this.muted && volume > 0) {
          this.muted = false;
        }
      }
      /**
       * Get the current player volume
       */
  
  
      get volume() {
        return Number(this.media.volume);
      }
      /**
       * Increase volume
       * @param {Boolean} step - How much to decrease by (between 0 and 1)
       */
  
  
      /**
       * Set muted state
       * @param {Boolean} mute
       */
      set muted(mute) {
        let toggle = mute; // Load muted state from storage
  
        if (!is.boolean(toggle)) {
          toggle = this.storage.get('muted');
        } // Use config if all else fails
  
  
        if (!is.boolean(toggle)) {
          toggle = this.config.muted;
        } // Update config
  
  
        this.config.muted = toggle; // Set mute on the player
  
        this.media.muted = toggle;
      }
      /**
       * Get current muted state
       */
  
  
      get muted() {
        return Boolean(this.media.muted);
      }
      /**
       * Check if the media has audio
       */
  
  
      get hasAudio() {
        // Assume yes for all non HTML5 (as we can't tell...)
        if (!this.isHTML5) {
          return true;
        }
  
        if (this.isAudio) {
          return true;
        } // Get audio tracks
  
  
        return Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length);
      }
      /**
       * Set playback speed
       * @param {Number} input - the speed of playback (0.5-2.0)
       */
  
  
      set speed(input) {
        let speed = null;
  
        if (is.number(input)) {
          speed = input;
        }
  
        if (!is.number(speed)) {
          speed = this.storage.get('speed');
        }
  
        if (!is.number(speed)) {
          speed = this.config.speed.selected;
        } // Clamp to min/max
  
  
        const {
          minimumSpeed: min,
          maximumSpeed: max
        } = this;
        speed = clamp(speed, min, max); // Update config
  
        this.config.speed.selected = speed; // Set media speed
  
        setTimeout(() => {
          if (this.media) {
            this.media.playbackRate = speed;
          }
        }, 0);
      }
      /**
       * Get current playback speed
       */
  
  
      get speed() {
        return Number(this.media.playbackRate);
      }
      /**
       * Get the minimum allowed speed
       */
  
  
      get minimumSpeed() {
        if (this.isYouTube) {
          // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate
          return Math.min(...this.options.speed);
        }
  
        if (this.isVimeo) {
          // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror
          return 0.5;
        } // https://stackoverflow.com/a/32320020/1191319
  
  
        return 0.0625;
      }
      /**
       * Get the maximum allowed speed
       */
  
  
      get maximumSpeed() {
        if (this.isYouTube) {
          // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate
          return Math.max(...this.options.speed);
        }
  
        if (this.isVimeo) {
          // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror
          return 2;
        } // https://stackoverflow.com/a/32320020/1191319
  
  
        return 16;
      }
      /**
       * Set playback quality
       * Currently HTML5 & YouTube only
       * @param {Number} input - Quality level
       */
  
  
      set quality(input) {
        const config = this.config.quality;
        const options = this.options.quality;
  
        if (!options.length) {
          return;
        }
  
        let quality = [!is.empty(input) && Number(input), this.storage.get('quality'), config.selected, config.default].find(is.number);
        let updateStorage = true;
  
        if (!options.includes(quality)) {
          const value = closest(options, quality);
          this.debug.warn(`Unsupported quality option: ${quality}, using ${value} instead`);
          quality = value; // Don't update storage if quality is not supported
  
          updateStorage = false;
        } // Update config
  
  
        config.selected = quality; // Set quality
  
        this.media.quality = quality; // Save to storage
  
        if (updateStorage) {
          this.storage.set({
            quality
          });
        }
      }
      /**
       * Get current quality level
       */
  
  
      get quality() {
        return this.media.quality;
      }
      /**
       * Toggle loop
       * TODO: Finish fancy new logic. Set the indicator on load as user may pass loop as config
       * @param {Boolean} input - Whether to loop or not
       */
  
  
      set loop(input) {
        const toggle = is.boolean(input) ? input : this.config.loop.active;
        this.config.loop.active = toggle;
        this.media.loop = toggle; // Set default to be a true toggle
  
        /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';
             switch (type) {
                case 'start':
                    if (this.config.loop.end && this.config.loop.end <= this.currentTime) {
                        this.config.loop.end = null;
                    }
                    this.config.loop.start = this.currentTime;
                    // this.config.loop.indicator.start = this.elements.display.played.value;
                    break;
                 case 'end':
                    if (this.config.loop.start >= this.currentTime) {
                        return this;
                    }
                    this.config.loop.end = this.currentTime;
                    // this.config.loop.indicator.end = this.elements.display.played.value;
                    break;
                 case 'all':
                    this.config.loop.start = 0;
                    this.config.loop.end = this.duration - 2;
                    this.config.loop.indicator.start = 0;
                    this.config.loop.indicator.end = 100;
                    break;
                 case 'toggle':
                    if (this.config.loop.active) {
                        this.config.loop.start = 0;
                        this.config.loop.end = null;
                    } else {
                        this.config.loop.start = 0;
                        this.config.loop.end = this.duration - 2;
                    }
                    break;
                 default:
                    this.config.loop.start = 0;
                    this.config.loop.end = null;
                    break;
            } */
      }
      /**
       * Get current loop state
       */
  
  
      get loop() {
        return Boolean(this.media.loop);
      }
      /**
       * Set new media source
       * @param {Object} input - The new source object (see docs)
       */
  
  
      set source(input) {
        source.change.call(this, input);
      }
      /**
       * Get current source
       */
  
  
      get source() {
        return this.media.currentSrc;
      }
      /**
       * Get a download URL (either source or custom)
       */
  
  
      get download() {
        const {
          download
        } = this.config.urls;
        return is.url(download) ? download : this.source;
      }
      /**
       * Set the download URL
       */
  
  
      set download(input) {
        if (!is.url(input)) {
          return;
        }
  
        this.config.urls.download = input;
        controls.setDownloadUrl.call(this);
      }
      /**
       * Set the poster image for a video
       * @param {String} input - the URL for the new poster image
       */
  
  
      set poster(input) {
        if (!this.isVideo) {
          this.debug.warn('Poster can only be set for video');
          return;
        }
  
        ui.setPoster.call(this, input, false).catch(() => {});
      }
      /**
       * Get the current poster image
       */
  
  
      get poster() {
        if (!this.isVideo) {
          return null;
        }
  
        return this.media.getAttribute('poster') || this.media.getAttribute('data-poster');
      }
      /**
       * Get the current aspect ratio in use
       */
  
  
      get ratio() {
        if (!this.isVideo) {
          return null;
        }
  
        const ratio = reduceAspectRatio(getAspectRatio.call(this));
        return is.array(ratio) ? ratio.join(':') : ratio;
      }
      /**
       * Set video aspect ratio
       */
  
  
      set ratio(input) {
        if (!this.isVideo) {
          this.debug.warn('Aspect ratio can only be set for video');
          return;
        }
  
        if (!is.string(input) || !validateAspectRatio(input)) {
          this.debug.error(`Invalid aspect ratio specified (${input})`);
          return;
        }
  
        this.config.ratio = reduceAspectRatio(input);
        setAspectRatio.call(this);
      }
      /**
       * Set the autoplay state
       * @param {Boolean} input - Whether to autoplay or not
       */
  
  
      set autoplay(input) {
        this.config.autoplay = is.boolean(input) ? input : this.config.autoplay;
      }
      /**
       * Get the current autoplay state
       */
  
  
      get autoplay() {
        return Boolean(this.config.autoplay);
      }
      /**
       * Toggle captions
       * @param {Boolean} input - Whether to enable captions
       */
  
  
      toggleCaptions(input) {
        captions.toggle.call(this, input, false);
      }
      /**
       * Set the caption track by index
       * @param {Number} input - Caption index
       */
  
  
      set currentTrack(input) {
        captions.set.call(this, input, false);
        captions.setup.call(this);
      }
      /**
       * Get the current caption track index (-1 if disabled)
       */
  
  
      get currentTrack() {
        const {
          toggled,
          currentTrack
        } = this.captions;
        return toggled ? currentTrack : -1;
      }
      /**
       * Set the wanted language for captions
       * Since tracks can be added later it won't update the actual caption track until there is a matching track
       * @param {String} input - Two character ISO language code (e.g. EN, FR, PT, etc)
       */
  
  
      set language(input) {
        captions.setLanguage.call(this, input, false);
      }
      /**
       * Get the current track's language
       */
  
  
      get language() {
        return (captions.getCurrentTrack.call(this) || {}).language;
      }
      /**
       * Toggle picture-in-picture playback on WebKit/MacOS
       * TODO: update player with state, support, enabled
       * TODO: detect outside changes
       */
  
  
      set pip(input) {
        // Bail if no support
        if (!support.pip) {
          return;
        } // Toggle based on current state if not passed
  
  
        const toggle = is.boolean(input) ? input : !this.pip; // Toggle based on current state
        // Safari
  
        if (is.function(this.media.webkitSetPresentationMode)) {
          this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);
        } // Chrome
  
  
        if (is.function(this.media.requestPictureInPicture)) {
          if (!this.pip && toggle) {
            this.media.requestPictureInPicture();
          } else if (this.pip && !toggle) {
            document.exitPictureInPicture();
          }
        }
      }
      /**
       * Get the current picture-in-picture state
       */
  
  
      get pip() {
        if (!support.pip) {
          return null;
        } // Safari
  
  
        if (!is.empty(this.media.webkitPresentationMode)) {
          return this.media.webkitPresentationMode === pip.active;
        } // Chrome
  
  
        return this.media === document.pictureInPictureElement;
      }
      /**
       * Sets the preview thubmnails for the current source
       */
  
  
      setPreviewThumbnails(thumbnailSource) {
        if (this.previewThumbnails && this.previewThumbnails.loaded) {
          this.previewThumbnails.destroy();
          this.previewThumbnails = null;
        }
  
        Object.assign(this.config.previewThumbnails, thumbnailSource); // Create new instance if it is still enabled
  
        if (this.config.previewThumbnails.enabled) {
          this.previewThumbnails = new PreviewThumbnails(this);
        }
      }
      /**
       * Trigger the airplay dialog
       * TODO: update player with state, support, enabled
       */
  
  
      /**
       * Check for support
       * @param {String} type - Player type (audio/video)
       * @param {String} provider - Provider (html5/youtube/vimeo)
       * @param {Boolean} inline - Where player has `playsinline` sttribute
       */
      static supported(type, provider, inline) {
        return support.check(type, provider, inline);
      }
      /**
       * Load an SVG sprite into the page
       * @param {String} url - URL for the SVG sprite
       * @param {String} [id] - Unique ID
       */
  
  
      static loadSprite(url, id) {
        return loadSprite(url, id);
      }
      /**
       * Setup multiple instances
       * @param {*} selector
       * @param {Object} options
       */
  
  
      static setup(selector, options = {}) {
        let targets = null;
  
        if (is.string(selector)) {
          targets = Array.from(document.querySelectorAll(selector));
        } else if (is.nodeList(selector)) {
          targets = Array.from(selector);
        } else if (is.array(selector)) {
          targets = selector.filter(is.element);
        }
  
        if (is.empty(targets)) {
          return null;
        }
  
        return targets.map(t => new Plyr(t, options));
      }
  
    }
  
    Plyr.defaults = cloneDeep(defaults);
  
    return Plyr;
  
  }));
/*! js-cookie v3.0.1 | MIT */
;
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, (function () {
    var current = global.Cookies;
    var exports = global.Cookies = factory();
    exports.noConflict = function () { global.Cookies = current; return exports; };
  }()));
}(this, (function () { 'use strict';

  /* eslint-disable no-var */
  function assign (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target
  }
  /* eslint-enable no-var */

  /* eslint-disable no-var */
  var defaultConverter = {
    read: function (value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function (value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      )
    }
  };
  /* eslint-enable no-var */

  /* eslint-disable no-var */

  function init (converter, defaultAttributes) {
    function set (key, value, attributes) {
      if (typeof document === 'undefined') {
        return
      }

      attributes = assign({}, defaultAttributes, attributes);

      if (typeof attributes.expires === 'number') {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }

      key = encodeURIComponent(key)
        .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
        .replace(/[()]/g, escape);

      var stringifiedAttributes = '';
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue
        }

        stringifiedAttributes += '; ' + attributeName;

        if (attributes[attributeName] === true) {
          continue
        }

        // Considers RFC 6265 section 5.2:
        // ...
        // 3.  If the remaining unparsed-attributes contains a %x3B (";")
        //     character:
        // Consume the characters of the unparsed-attributes up to,
        // not including, the first %x3B (";") character.
        // ...
        stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
      }

      return (document.cookie =
        key + '=' + converter.write(value, key) + stringifiedAttributes)
    }

    function get (key) {
      if (typeof document === 'undefined' || (arguments.length && !key)) {
        return
      }

      // To prevent the for loop in the first place assign an empty array
      // in case there are no cookies at all.
      var cookies = document.cookie ? document.cookie.split('; ') : [];
      var jar = {};
      for (var i = 0; i < cookies.length; i++) {
        var parts = cookies[i].split('=');
        var value = parts.slice(1).join('=');

        try {
          var foundKey = decodeURIComponent(parts[0]);
          jar[foundKey] = converter.read(value, foundKey);

          if (key === foundKey) {
            break
          }
        } catch (e) {}
      }

      return key ? jar[key] : jar
    }

    return Object.create(
      {
        set: set,
        get: get,
        remove: function (key, attributes) {
          set(
            key,
            '',
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function (attributes) {
          return init(this.converter, assign({}, this.attributes, attributes))
        },
        withConverter: function (converter) {
          return init(assign({}, this.converter, converter), this.attributes)
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    )
  }

  var api = init(defaultConverter, { path: '/' });
  /* eslint-enable no-var */

  return api;

})));
/*! algoliasearch-lite.umd.js | 4.5.1 | © Algolia, inc. | https://github.com/algolia/algoliasearch-client-javascript */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).algoliasearch=t()}(this,(function(){"use strict";function e(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function t(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function r(r){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?t(Object(o),!0).forEach((function(t){e(r,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(o)):t(Object(o)).forEach((function(e){Object.defineProperty(r,e,Object.getOwnPropertyDescriptor(o,e))}))}return r}function n(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}function o(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var r=[],n=!0,o=!1,a=void 0;try{for(var u,i=e[Symbol.iterator]();!(n=(u=i.next()).done)&&(r.push(u.value),!t||r.length!==t);n=!0);}catch(e){o=!0,a=e}finally{try{n||null==i.return||i.return()}finally{if(o)throw a}}return r}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function a(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function u(e){var t,r="algoliasearch-client-js-".concat(e.key),n=function(){return void 0===t&&(t=e.localStorage||window.localStorage),t},a=function(){return JSON.parse(n().getItem(r)||"{}")};return{get:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}};return Promise.resolve().then((function(){var r=JSON.stringify(e),n=a()[r];return Promise.all([n||t(),void 0!==n])})).then((function(e){var t=o(e,2),n=t[0],a=t[1];return Promise.all([n,a||r.miss(n)])})).then((function(e){return o(e,1)[0]}))},set:function(e,t){return Promise.resolve().then((function(){var o=a();return o[JSON.stringify(e)]=t,n().setItem(r,JSON.stringify(o)),t}))},delete:function(e){return Promise.resolve().then((function(){var t=a();delete t[JSON.stringify(e)],n().setItem(r,JSON.stringify(t))}))},clear:function(){return Promise.resolve().then((function(){n().removeItem(r)}))}}}function i(e){var t=a(e.caches),r=t.shift();return void 0===r?{get:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}},n=t();return n.then((function(e){return Promise.all([e,r.miss(e)])})).then((function(e){return o(e,1)[0]}))},set:function(e,t){return Promise.resolve(t)},delete:function(e){return Promise.resolve()},clear:function(){return Promise.resolve()}}:{get:function(e,n){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}};return r.get(e,n,o).catch((function(){return i({caches:t}).get(e,n,o)}))},set:function(e,n){return r.set(e,n).catch((function(){return i({caches:t}).set(e,n)}))},delete:function(e){return r.delete(e).catch((function(){return i({caches:t}).delete(e)}))},clear:function(){return r.clear().catch((function(){return i({caches:t}).clear()}))}}}function s(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{serializable:!0},t={};return{get:function(r,n){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}},a=JSON.stringify(r);if(a in t)return Promise.resolve(e.serializable?JSON.parse(t[a]):t[a]);var u=n(),i=o&&o.miss||function(){return Promise.resolve()};return u.then((function(e){return i(e)})).then((function(){return u}))},set:function(r,n){return t[JSON.stringify(r)]=e.serializable?JSON.stringify(n):n,Promise.resolve(n)},delete:function(e){return delete t[JSON.stringify(e)],Promise.resolve()},clear:function(){return t={},Promise.resolve()}}}function c(e){for(var t=e.length-1;t>0;t--){var r=Math.floor(Math.random()*(t+1)),n=e[t];e[t]=e[r],e[r]=n}return e}function l(e,t){return Object.keys(void 0!==t?t:{}).forEach((function(r){e[r]=t[r](e)})),e}function f(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];var o=0;return e.replace(/%s/g,(function(){return encodeURIComponent(r[o++])}))}var h={WithinQueryParameters:0,WithinHeaders:1};function d(e,t){var r=e||{},n=r.data||{};return Object.keys(r).forEach((function(e){-1===["timeout","headers","queryParameters","data","cacheable"].indexOf(e)&&(n[e]=r[e])})),{data:Object.entries(n).length>0?n:void 0,timeout:r.timeout||t,headers:r.headers||{},queryParameters:r.queryParameters||{},cacheable:r.cacheable}}var m={Read:1,Write:2,Any:3},p=1,v=2,y=3;function g(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p;return r(r({},e),{},{status:t,lastUpdate:Date.now()})}function b(e){return"string"==typeof e?{protocol:"https",url:e,accept:m.Any}:{protocol:e.protocol||"https",url:e.url,accept:e.accept||m.Any}}var O="GET",P="POST";function q(e,t){return Promise.all(t.map((function(t){return e.get(t,(function(){return Promise.resolve(g(t))}))}))).then((function(e){var r=e.filter((function(e){return function(e){return e.status===p||Date.now()-e.lastUpdate>12e4}(e)})),n=e.filter((function(e){return function(e){return e.status===y&&Date.now()-e.lastUpdate<=12e4}(e)})),o=[].concat(a(r),a(n));return{getTimeout:function(e,t){return(0===n.length&&0===e?1:n.length+3+e)*t},statelessHosts:o.length>0?o.map((function(e){return b(e)})):t}}))}function j(e,t,n,o){var u=[],i=function(e,t){if(e.method===O||void 0===e.data&&void 0===t.data)return;var n=Array.isArray(e.data)?e.data:r(r({},e.data),t.data);return JSON.stringify(n)}(n,o),s=function(e,t){var n=r(r({},e.headers),t.headers),o={};return Object.keys(n).forEach((function(e){var t=n[e];o[e.toLowerCase()]=t})),o}(e,o),c=n.method,l=n.method!==O?{}:r(r({},n.data),o.data),f=r(r(r({"x-algolia-agent":e.userAgent.value},e.queryParameters),l),o.queryParameters),h=0,d=function t(r,a){var l=r.pop();if(void 0===l)throw{name:"RetryError",message:"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.",transporterStackTrace:A(u)};var d={data:i,headers:s,method:c,url:w(l,n.path,f),connectTimeout:a(h,e.timeouts.connect),responseTimeout:a(h,o.timeout)},m=function(e){var t={request:d,response:e,host:l,triesLeft:r.length};return u.push(t),t},p={onSucess:function(e){return function(e){try{return JSON.parse(e.content)}catch(t){throw function(e,t){return{name:"DeserializationError",message:e,response:t}}(t.message,e)}}(e)},onRetry:function(n){var o=m(n);return n.isTimedOut&&h++,Promise.all([e.logger.info("Retryable failure",x(o)),e.hostsCache.set(l,g(l,n.isTimedOut?y:v))]).then((function(){return t(r,a)}))},onFail:function(e){throw m(e),function(e,t){var r=e.content,n=e.status,o=r;try{o=JSON.parse(r).message}catch(e){}return function(e,t,r){return{name:"ApiError",message:e,status:t,transporterStackTrace:r}}(o,n,t)}(e,A(u))}};return e.requester.send(d).then((function(e){return function(e,t){return function(e){var t=e.status;return e.isTimedOut||function(e){var t=e.isTimedOut,r=e.status;return!t&&0==~~r}(e)||2!=~~(t/100)&&4!=~~(t/100)}(e)?t.onRetry(e):2==~~(e.status/100)?t.onSucess(e):t.onFail(e)}(e,p)}))};return q(e.hostsCache,t).then((function(e){return d(a(e.statelessHosts).reverse(),e.getTimeout)}))}function S(e){var t={value:"Algolia for JavaScript (".concat(e,")"),add:function(e){var r="; ".concat(e.segment).concat(void 0!==e.version?" (".concat(e.version,")"):"");return-1===t.value.indexOf(r)&&(t.value="".concat(t.value).concat(r)),t}};return t}function w(e,t,r){var n=T(r),o="".concat(e.protocol,"://").concat(e.url,"/").concat("/"===t.charAt(0)?t.substr(1):t);return n.length&&(o+="?".concat(n)),o}function T(e){return Object.keys(e).map((function(t){return f("%s=%s",t,(r=e[t],"[object Object]"===Object.prototype.toString.call(r)||"[object Array]"===Object.prototype.toString.call(r)?JSON.stringify(e[t]):e[t]));var r})).join("&")}function A(e){return e.map((function(e){return x(e)}))}function x(e){var t=e.request.headers["x-algolia-api-key"]?{"x-algolia-api-key":"*****"}:{};return r(r({},e),{},{request:r(r({},e.request),{},{headers:r(r({},e.request.headers),t)})})}var C=function(e){var t=e.appId,n=function(e,t,r){var n={"x-algolia-api-key":r,"x-algolia-application-id":t};return{headers:function(){return e===h.WithinHeaders?n:{}},queryParameters:function(){return e===h.WithinQueryParameters?n:{}}}}(void 0!==e.authMode?e.authMode:h.WithinHeaders,t,e.apiKey),a=function(e){var t=e.hostsCache,r=e.logger,n=e.requester,a=e.requestsCache,u=e.responsesCache,i=e.timeouts,s=e.userAgent,c=e.hosts,l=e.queryParameters,f={hostsCache:t,logger:r,requester:n,requestsCache:a,responsesCache:u,timeouts:i,userAgent:s,headers:e.headers,queryParameters:l,hosts:c.map((function(e){return b(e)})),read:function(e,t){var r=d(t,f.timeouts.read),n=function(){return j(f,f.hosts.filter((function(e){return 0!=(e.accept&m.Read)})),e,r)};if(!0!==(void 0!==r.cacheable?r.cacheable:e.cacheable))return n();var a={request:e,mappedRequestOptions:r,transporter:{queryParameters:f.queryParameters,headers:f.headers}};return f.responsesCache.get(a,(function(){return f.requestsCache.get(a,(function(){return f.requestsCache.set(a,n()).then((function(e){return Promise.all([f.requestsCache.delete(a),e])}),(function(e){return Promise.all([f.requestsCache.delete(a),Promise.reject(e)])})).then((function(e){var t=o(e,2);t[0];return t[1]}))}))}),{miss:function(e){return f.responsesCache.set(a,e)}})},write:function(e,t){return j(f,f.hosts.filter((function(e){return 0!=(e.accept&m.Write)})),e,d(t,f.timeouts.write))}};return f}(r(r({hosts:[{url:"".concat(t,"-dsn.algolia.net"),accept:m.Read},{url:"".concat(t,".algolia.net"),accept:m.Write}].concat(c([{url:"".concat(t,"-1.algolianet.com")},{url:"".concat(t,"-2.algolianet.com")},{url:"".concat(t,"-3.algolianet.com")}]))},e),{},{headers:r(r(r({},n.headers()),{"content-type":"application/x-www-form-urlencoded"}),e.headers),queryParameters:r(r({},n.queryParameters()),e.queryParameters)}));return l({transporter:a,appId:t,addAlgoliaAgent:function(e,t){a.userAgent.add({segment:e,version:t})},clearCache:function(){return Promise.all([a.requestsCache.clear(),a.responsesCache.clear()]).then((function(){}))}},e.methods)},N=function(e){return function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={transporter:e.transporter,appId:e.appId,indexName:t};return l(n,r.methods)}},k=function(e){return function(t,n){var o=t.map((function(e){return r(r({},e),{},{params:T(e.params||{})})}));return e.transporter.read({method:P,path:"1/indexes/*/queries",data:{requests:o},cacheable:!0},n)}},J=function(e){return function(t,o){return Promise.all(t.map((function(t){var a=t.params,u=a.facetName,i=a.facetQuery,s=n(a,["facetName","facetQuery"]);return N(e)(t.indexName,{methods:{searchForFacetValues:I}}).searchForFacetValues(u,i,r(r({},o),s))})))}},E=function(e){return function(t,r){return e.transporter.read({method:P,path:f("1/indexes/%s/query",e.indexName),data:{query:t},cacheable:!0},r)}},I=function(e){return function(t,r,n){return e.transporter.read({method:P,path:f("1/indexes/%s/facets/%s/query",e.indexName,t),data:{facetQuery:r},cacheable:!0},n)}},F=1,R=2,D=3;function W(e,t,n){var o,a={appId:e,apiKey:t,timeouts:{connect:1,read:2,write:30},requester:{send:function(e){return new Promise((function(t){var r=new XMLHttpRequest;r.open(e.method,e.url,!0),Object.keys(e.headers).forEach((function(t){return r.setRequestHeader(t,e.headers[t])}));var n,o=function(e,n){return setTimeout((function(){r.abort(),t({status:0,content:n,isTimedOut:!0})}),1e3*e)},a=o(e.connectTimeout,"Connection timeout");r.onreadystatechange=function(){r.readyState>r.OPENED&&void 0===n&&(clearTimeout(a),n=o(e.responseTimeout,"Socket timeout"))},r.onerror=function(){0===r.status&&(clearTimeout(a),clearTimeout(n),t({content:r.responseText||"Network request failed",status:r.status,isTimedOut:!1}))},r.onload=function(){clearTimeout(a),clearTimeout(n),t({content:r.responseText,status:r.status,isTimedOut:!1})},r.send(e.data)}))}},logger:(o=D,{debug:function(e,t){return F>=o&&console.debug(e,t),Promise.resolve()},info:function(e,t){return R>=o&&console.info(e,t),Promise.resolve()},error:function(e,t){return console.error(e,t),Promise.resolve()}}),responsesCache:s(),requestsCache:s({serializable:!1}),hostsCache:i({caches:[u({key:"".concat("4.5.1","-").concat(e)}),s()]}),userAgent:S("4.5.1").add({segment:"Browser",version:"lite"}),authMode:h.WithinQueryParameters};return C(r(r(r({},a),n),{},{methods:{search:k,searchForFacetValues:J,multipleQueries:k,multipleSearchForFacetValues:J,initIndex:function(e){return function(t){return N(e)(t,{methods:{search:E,searchForFacetValues:I}})}}}}))}return W.version="4.5.1",W}));
/*! InstantSearch.js 4.8.3 | © Algolia, Inc. and contributors; MIT License | https://github.com/algolia/instantsearch.js */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).instantsearch=t()}(this,function(){"use strict";function h(e){return(h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function k(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function M(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e}function L(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function f(){return(f=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),n.push.apply(n,r)}return n}function D(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach(function(e){L(t,e,n[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}return t}function j(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&n(e,t)}function O(e){return(O=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function n(e,t){return(n=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function A(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],0<=t.indexOf(n)||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],0<=t.indexOf(n)||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}function H(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function B(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?H(e):t}function Q(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var n=[],r=!0,i=!1,a=void 0;try{for(var s,o=e[Symbol.iterator]();!(r=(s=o.next()).done)&&(n.push(s.value),!t||n.length!==t);r=!0);}catch(e){i=!0,a=e}finally{try{r||null==o.return||o.return()}finally{if(i)throw a}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function _(e){return function(e){if(Array.isArray(e)){for(var t=0,n=new Array(e.length);t<e.length;t++)n[t]=e[t];return n}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function s(e){return"function"==typeof e||Array.isArray(e)||"[object Object]"===Object.prototype.toString.call(e)}function o(e,t){if(e===t)return e;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var r=t[n],i=e[n];void 0!==i&&void 0===r||(s(i)&&s(r)?e[n]=o(i,r):e[n]="object"==typeof(a=r)&&null!==a?o(Array.isArray(a)?[]:{},a):a)}var a;return e}function m(){return Array.prototype.slice.call(arguments).reduceRight(function(t,n){return Object.keys(Object(n)).forEach(function(e){void 0!==n[e]&&(void 0!==t[e]&&delete t[e],t[e]=n[e])}),t},{})}var p=function(e){s(e)||(e={});for(var t=1,n=arguments.length;t<n;t++){var r=arguments[t];s(r)&&o(e,r)}return e};var a=function(n,r){return n.filter(function(e,t){return-1<r.indexOf(e)&&n.indexOf(e)===t})},v=function(e,t){if(Array.isArray(e))for(var n=0;n<e.length;n++)if(t(e[n]))return e[n]};var c=function e(t){if("number"==typeof t)return t;if("string"==typeof t)return parseFloat(t);if(Array.isArray(t))return t.map(e);throw new Error("The value should be a number, a parsable string or an array of those.")};var u=function(e,t){if(null===e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],0<=t.indexOf(n)||(i[n]=e[n]);return i};var l=function(e){return e&&0<Object.keys(e).length},d={addRefinement:function(e,t,n){if(d.isRefined(e,t,n))return e;var r=""+n,i=e[t]?e[t].concat(r):[r],a={};return a[t]=i,m({},a,e)},removeRefinement:function(e,n,t){if(void 0===t)return d.clearRefinement(e,function(e,t){return n===t});var r=""+t;return d.clearRefinement(e,function(e,t){return n===t&&r===e})},toggleRefinement:function(e,t,n){if(void 0===n)throw new Error("toggleRefinement should be used with a value");return d.isRefined(e,t,n)?d.removeRefinement(e,t,n):d.addRefinement(e,t,n)},clearRefinement:function(i,a,s){if(void 0===a)return l(i)?{}:i;if("string"==typeof a)return u(i,[a]);if("function"==typeof a){var o=!1,e=Object.keys(i).reduce(function(e,t){var n=i[t]||[],r=n.filter(function(e){return!a(e,t,s)});return r.length!==n.length&&(o=!0),e[t]=r,e},{});return o?e:i}},isRefined:function(e,t,n){var r=!!e[t]&&0<e[t].length;if(void 0===n||!r)return r;var i=""+n;return-1!==e[t].indexOf(i)}},g=d;function y(e,n){return Array.isArray(e)&&Array.isArray(n)?e.length===n.length&&e.every(function(e,t){return y(n[t],e)}):e===n}function b(e){var r=e?b._parseNumbers(e):{};this.facets=r.facets||[],this.disjunctiveFacets=r.disjunctiveFacets||[],this.hierarchicalFacets=r.hierarchicalFacets||[],this.facetsRefinements=r.facetsRefinements||{},this.facetsExcludes=r.facetsExcludes||{},this.disjunctiveFacetsRefinements=r.disjunctiveFacetsRefinements||{},this.numericRefinements=r.numericRefinements||{},this.tagRefinements=r.tagRefinements||[],this.hierarchicalFacetsRefinements=r.hierarchicalFacetsRefinements||{};var i=this;Object.keys(r).forEach(function(e){var t=-1!==b.PARAMETERS.indexOf(e),n=void 0!==r[e];!t&&n&&(i[e]=r[e])})}b.PARAMETERS=Object.keys(new b),b._parseNumbers=function(i){if(i instanceof b)return i;var r={};if(["aroundPrecision","aroundRadius","getRankingInfo","minWordSizefor2Typos","minWordSizefor1Typo","page","maxValuesPerFacet","distinct","minimumAroundRadius","hitsPerPage","minProximity"].forEach(function(e){var t=i[e];if("string"==typeof t){var n=parseFloat(t);r[e]=isNaN(n)?t:n}}),Array.isArray(i.insideBoundingBox)&&(r.insideBoundingBox=i.insideBoundingBox.map(function(e){return Array.isArray(e)?e.map(function(e){return parseFloat(e)}):e})),i.numericRefinements){var a={};Object.keys(i.numericRefinements).forEach(function(n){var r=i.numericRefinements[n]||{};a[n]={},Object.keys(r).forEach(function(e){var t=r[e].map(function(e){return Array.isArray(e)?e.map(function(e){return"string"==typeof e?parseFloat(e):e}):"string"==typeof e?parseFloat(e):e});a[n][e]=t})}),r.numericRefinements=a}return p({},i,r)},b.make=function(e){var n=new b(e);return(e.hierarchicalFacets||[]).forEach(function(e){if(e.rootPath){var t=n.getHierarchicalRefinement(e.name);0<t.length&&0!==t[0].indexOf(e.rootPath)&&(n=n.clearRefinements(e.name)),0===(t=n.getHierarchicalRefinement(e.name)).length&&(n=n.toggleHierarchicalFacetRefinement(e.name,e.rootPath))}}),n},b.validate=function(e,t){var n=t||{};return e.tagFilters&&n.tagRefinements&&0<n.tagRefinements.length?new Error("[Tags] Cannot switch from the managed tag API to the advanced API. It is probably an error, if it is really what you want, you should first clear the tags with clearTags method."):0<e.tagRefinements.length&&n.tagFilters?new Error("[Tags] Cannot switch from the advanced tag API to the managed API. It is probably an error, if it is not, you should first clear the tags with clearTags method."):e.numericFilters&&n.numericRefinements&&l(n.numericRefinements)?new Error("[Numeric filters] Can't switch from the advanced to the managed API. It is probably an error, if this is really what you want, you have to first clear the numeric filters."):l(e.numericRefinements)&&n.numericFilters?new Error("[Numeric filters] Can't switch from the managed API to the advanced. It is probably an error, if this is really what you want, you have to first clear the numeric filters."):null},b.prototype={constructor:b,clearRefinements:function(e){var t={numericRefinements:this._clearNumericRefinements(e),facetsRefinements:g.clearRefinement(this.facetsRefinements,e,"conjunctiveFacet"),facetsExcludes:g.clearRefinement(this.facetsExcludes,e,"exclude"),disjunctiveFacetsRefinements:g.clearRefinement(this.disjunctiveFacetsRefinements,e,"disjunctiveFacet"),hierarchicalFacetsRefinements:g.clearRefinement(this.hierarchicalFacetsRefinements,e,"hierarchicalFacet")};return t.numericRefinements===this.numericRefinements&&t.facetsRefinements===this.facetsRefinements&&t.facetsExcludes===this.facetsExcludes&&t.disjunctiveFacetsRefinements===this.disjunctiveFacetsRefinements&&t.hierarchicalFacetsRefinements===this.hierarchicalFacetsRefinements?this:this.setQueryParameters(t)},clearTags:function(){return void 0===this.tagFilters&&0===this.tagRefinements.length?this:this.setQueryParameters({tagFilters:void 0,tagRefinements:[]})},setIndex:function(e){return e===this.index?this:this.setQueryParameters({index:e})},setQuery:function(e){return e===this.query?this:this.setQueryParameters({query:e})},setPage:function(e){return e===this.page?this:this.setQueryParameters({page:e})},setFacets:function(e){return this.setQueryParameters({facets:e})},setDisjunctiveFacets:function(e){return this.setQueryParameters({disjunctiveFacets:e})},setHitsPerPage:function(e){return this.hitsPerPage===e?this:this.setQueryParameters({hitsPerPage:e})},setTypoTolerance:function(e){return this.typoTolerance===e?this:this.setQueryParameters({typoTolerance:e})},addNumericRefinement:function(e,t,n){var r=c(n);if(this.isNumericRefined(e,t,r))return this;var i=p({},this.numericRefinements);return i[e]=p({},i[e]),i[e][t]?(i[e][t]=i[e][t].slice(),i[e][t].push(r)):i[e][t]=[r],this.setQueryParameters({numericRefinements:i})},getConjunctiveRefinements:function(e){return this.isConjunctiveFacet(e)&&this.facetsRefinements[e]||[]},getDisjunctiveRefinements:function(e){return this.isDisjunctiveFacet(e)&&this.disjunctiveFacetsRefinements[e]||[]},getHierarchicalRefinement:function(e){return this.hierarchicalFacetsRefinements[e]||[]},getExcludeRefinements:function(e){return this.isConjunctiveFacet(e)&&this.facetsExcludes[e]||[]},removeNumericRefinement:function(n,r,i){return void 0!==i?this.isNumericRefined(n,r,i)?this.setQueryParameters({numericRefinements:this._clearNumericRefinements(function(e,t){return t===n&&e.op===r&&y(e.val,c(i))})}):this:void 0!==r?this.isNumericRefined(n,r)?this.setQueryParameters({numericRefinements:this._clearNumericRefinements(function(e,t){return t===n&&e.op===r})}):this:this.isNumericRefined(n)?this.setQueryParameters({numericRefinements:this._clearNumericRefinements(function(e,t){return t===n})}):this},getNumericRefinements:function(e){return this.numericRefinements[e]||{}},getNumericRefinement:function(e,t){return this.numericRefinements[e]&&this.numericRefinements[e][t]},_clearNumericRefinements:function(s){if(void 0===s)return l(this.numericRefinements)?{}:this.numericRefinements;if("string"==typeof s)return l(this.numericRefinements[s])?u(this.numericRefinements,[s]):this.numericRefinements;if("function"==typeof s){var o=!1,t=this.numericRefinements,e=Object.keys(t).reduce(function(e,r){var i=t[r],a={};return i=i||{},Object.keys(i).forEach(function(t){var e=i[t]||[],n=[];e.forEach(function(e){s({val:e,op:t},r,"numeric")||n.push(e)}),n.length!==e.length&&(o=!0),a[t]=n}),e[r]=a,e},{});return o?e:this.numericRefinements}},addFacet:function(e){return this.isConjunctiveFacet(e)?this:this.setQueryParameters({facets:this.facets.concat([e])})},addDisjunctiveFacet:function(e){return this.isDisjunctiveFacet(e)?this:this.setQueryParameters({disjunctiveFacets:this.disjunctiveFacets.concat([e])})},addHierarchicalFacet:function(e){if(this.isHierarchicalFacet(e.name))throw new Error("Cannot declare two hierarchical facets with the same name: `"+e.name+"`");return this.setQueryParameters({hierarchicalFacets:this.hierarchicalFacets.concat([e])})},addFacetRefinement:function(e,t){if(!this.isConjunctiveFacet(e))throw new Error(e+" is not defined in the facets attribute of the helper configuration");return g.isRefined(this.facetsRefinements,e,t)?this:this.setQueryParameters({facetsRefinements:g.addRefinement(this.facetsRefinements,e,t)})},addExcludeRefinement:function(e,t){if(!this.isConjunctiveFacet(e))throw new Error(e+" is not defined in the facets attribute of the helper configuration");return g.isRefined(this.facetsExcludes,e,t)?this:this.setQueryParameters({facetsExcludes:g.addRefinement(this.facetsExcludes,e,t)})},addDisjunctiveFacetRefinement:function(e,t){if(!this.isDisjunctiveFacet(e))throw new Error(e+" is not defined in the disjunctiveFacets attribute of the helper configuration");return g.isRefined(this.disjunctiveFacetsRefinements,e,t)?this:this.setQueryParameters({disjunctiveFacetsRefinements:g.addRefinement(this.disjunctiveFacetsRefinements,e,t)})},addTagRefinement:function(e){if(this.isTagRefined(e))return this;var t={tagRefinements:this.tagRefinements.concat(e)};return this.setQueryParameters(t)},removeFacet:function(t){return this.isConjunctiveFacet(t)?this.clearRefinements(t).setQueryParameters({facets:this.facets.filter(function(e){return e!==t})}):this},removeDisjunctiveFacet:function(t){return this.isDisjunctiveFacet(t)?this.clearRefinements(t).setQueryParameters({disjunctiveFacets:this.disjunctiveFacets.filter(function(e){return e!==t})}):this},removeHierarchicalFacet:function(t){return this.isHierarchicalFacet(t)?this.clearRefinements(t).setQueryParameters({hierarchicalFacets:this.hierarchicalFacets.filter(function(e){return e.name!==t})}):this},removeFacetRefinement:function(e,t){if(!this.isConjunctiveFacet(e))throw new Error(e+" is not defined in the facets attribute of the helper configuration");return g.isRefined(this.facetsRefinements,e,t)?this.setQueryParameters({facetsRefinements:g.removeRefinement(this.facetsRefinements,e,t)}):this},removeExcludeRefinement:function(e,t){if(!this.isConjunctiveFacet(e))throw new Error(e+" is not defined in the facets attribute of the helper configuration");return g.isRefined(this.facetsExcludes,e,t)?this.setQueryParameters({facetsExcludes:g.removeRefinement(this.facetsExcludes,e,t)}):this},removeDisjunctiveFacetRefinement:function(e,t){if(!this.isDisjunctiveFacet(e))throw new Error(e+" is not defined in the disjunctiveFacets attribute of the helper configuration");return g.isRefined(this.disjunctiveFacetsRefinements,e,t)?this.setQueryParameters({disjunctiveFacetsRefinements:g.removeRefinement(this.disjunctiveFacetsRefinements,e,t)}):this},removeTagRefinement:function(t){if(!this.isTagRefined(t))return this;var e={tagRefinements:this.tagRefinements.filter(function(e){return e!==t})};return this.setQueryParameters(e)},toggleRefinement:function(e,t){return this.toggleFacetRefinement(e,t)},toggleFacetRefinement:function(e,t){if(this.isHierarchicalFacet(e))return this.toggleHierarchicalFacetRefinement(e,t);if(this.isConjunctiveFacet(e))return this.toggleConjunctiveFacetRefinement(e,t);if(this.isDisjunctiveFacet(e))return this.toggleDisjunctiveFacetRefinement(e,t);throw new Error("Cannot refine the undeclared facet "+e+"; it should be added to the helper options facets, disjunctiveFacets or hierarchicalFacets")},toggleConjunctiveFacetRefinement:function(e,t){if(!this.isConjunctiveFacet(e))throw new Error(e+" is not defined in the facets attribute of the helper configuration");return this.setQueryParameters({facetsRefinements:g.toggleRefinement(this.facetsRefinements,e,t)})},toggleExcludeFacetRefinement:function(e,t){if(!this.isConjunctiveFacet(e))throw new Error(e+" is not defined in the facets attribute of the helper configuration");return this.setQueryParameters({facetsExcludes:g.toggleRefinement(this.facetsExcludes,e,t)})},toggleDisjunctiveFacetRefinement:function(e,t){if(!this.isDisjunctiveFacet(e))throw new Error(e+" is not defined in the disjunctiveFacets attribute of the helper configuration");return this.setQueryParameters({disjunctiveFacetsRefinements:g.toggleRefinement(this.disjunctiveFacetsRefinements,e,t)})},toggleHierarchicalFacetRefinement:function(e,t){if(!this.isHierarchicalFacet(e))throw new Error(e+" is not defined in the hierarchicalFacets attribute of the helper configuration");var n=this._getHierarchicalFacetSeparator(this.getHierarchicalFacetByName(e)),r={};return void 0!==this.hierarchicalFacetsRefinements[e]&&0<this.hierarchicalFacetsRefinements[e].length&&(this.hierarchicalFacetsRefinements[e][0]===t||0===this.hierarchicalFacetsRefinements[e][0].indexOf(t+n))?-1===t.indexOf(n)?r[e]=[]:r[e]=[t.slice(0,t.lastIndexOf(n))]:r[e]=[t],this.setQueryParameters({hierarchicalFacetsRefinements:m({},r,this.hierarchicalFacetsRefinements)})},addHierarchicalFacetRefinement:function(e,t){if(this.isHierarchicalFacetRefined(e))throw new Error(e+" is already refined.");if(!this.isHierarchicalFacet(e))throw new Error(e+" is not defined in the hierarchicalFacets attribute of the helper configuration.");var n={};return n[e]=[t],this.setQueryParameters({hierarchicalFacetsRefinements:m({},n,this.hierarchicalFacetsRefinements)})},removeHierarchicalFacetRefinement:function(e){if(!this.isHierarchicalFacetRefined(e))return this;var t={};return t[e]=[],this.setQueryParameters({hierarchicalFacetsRefinements:m({},t,this.hierarchicalFacetsRefinements)})},toggleTagRefinement:function(e){return this.isTagRefined(e)?this.removeTagRefinement(e):this.addTagRefinement(e)},isDisjunctiveFacet:function(e){return-1<this.disjunctiveFacets.indexOf(e)},isHierarchicalFacet:function(e){return void 0!==this.getHierarchicalFacetByName(e)},isConjunctiveFacet:function(e){return-1<this.facets.indexOf(e)},isFacetRefined:function(e,t){return!!this.isConjunctiveFacet(e)&&g.isRefined(this.facetsRefinements,e,t)},isExcludeRefined:function(e,t){return!!this.isConjunctiveFacet(e)&&g.isRefined(this.facetsExcludes,e,t)},isDisjunctiveFacetRefined:function(e,t){return!!this.isDisjunctiveFacet(e)&&g.isRefined(this.disjunctiveFacetsRefinements,e,t)},isHierarchicalFacetRefined:function(e,t){if(!this.isHierarchicalFacet(e))return!1;var n=this.getHierarchicalRefinement(e);return t?-1!==n.indexOf(t):0<n.length},isNumericRefined:function(e,t,n){if(void 0===n&&void 0===t)return!!this.numericRefinements[e];var r=this.numericRefinements[e]&&void 0!==this.numericRefinements[e][t];if(void 0===n||!r)return r;var i=c(n),a=void 0!==function(e,t){return v(e,function(e){return y(e,t)})}(this.numericRefinements[e][t],i);return r&&a},isTagRefined:function(e){return-1!==this.tagRefinements.indexOf(e)},getRefinedDisjunctiveFacets:function(){var t=this,e=a(Object.keys(this.numericRefinements).filter(function(e){return 0<Object.keys(t.numericRefinements[e]).length}),this.disjunctiveFacets);return Object.keys(this.disjunctiveFacetsRefinements).filter(function(e){return 0<t.disjunctiveFacetsRefinements[e].length}).concat(e).concat(this.getRefinedHierarchicalFacets())},getRefinedHierarchicalFacets:function(){var t=this;return a(this.hierarchicalFacets.map(function(e){return e.name}),Object.keys(this.hierarchicalFacetsRefinements).filter(function(e){return 0<t.hierarchicalFacetsRefinements[e].length}))},getUnrefinedDisjunctiveFacets:function(){var t=this.getRefinedDisjunctiveFacets();return this.disjunctiveFacets.filter(function(e){return-1===t.indexOf(e)})},managedParameters:["index","facets","disjunctiveFacets","facetsRefinements","facetsExcludes","disjunctiveFacetsRefinements","numericRefinements","tagRefinements","hierarchicalFacets","hierarchicalFacetsRefinements"],getQueryParams:function(){var n=this.managedParameters,r={},i=this;return Object.keys(this).forEach(function(e){var t=i[e];-1===n.indexOf(e)&&void 0!==t&&(r[e]=t)}),r},setQueryParameter:function(e,t){if(this[e]===t)return this;var n={};return n[e]=t,this.setQueryParameters(n)},setQueryParameters:function(e){if(!e)return this;var t=b.validate(this,e);if(t)throw t;var n=this,i=b._parseNumbers(e),r=Object.keys(this).reduce(function(e,t){return e[t]=n[t],e},{}),a=Object.keys(i).reduce(function(e,t){var n=void 0!==e[t],r=void 0!==i[t];return n&&!r?u(e,[t]):(r&&(e[t]=i[t]),e)},r);return new this.constructor(a)},resetPage:function(){return void 0===this.page?this:this.setPage(0)},_getHierarchicalFacetSortBy:function(e){return e.sortBy||["isRefined:desc","name:asc"]},_getHierarchicalFacetSeparator:function(e){return e.separator||" > "},_getHierarchicalRootPath:function(e){return e.rootPath||null},_getHierarchicalShowParentLevel:function(e){return"boolean"!=typeof e.showParentLevel||e.showParentLevel},getHierarchicalFacetByName:function(t){return v(this.hierarchicalFacets,function(e){return e.name===t})},getHierarchicalFacetBreadcrumb:function(e){if(!this.isHierarchicalFacet(e))return[];var t=this.getHierarchicalRefinement(e)[0];if(!t)return[];var n=this._getHierarchicalFacetSeparator(this.getHierarchicalFacetByName(e));return t.split(n).map(function(e){return e.trim()})},toString:function(){return JSON.stringify(this,null,2)}};var R=b;function w(e,t){if(e!==t){var n=void 0!==e,r=null===e,i=void 0!==t,a=null===t;if(!a&&t<e||r&&i||!n)return 1;if(!r&&e<t||a&&n||!i)return-1}return 0}function t(e){return Array.isArray(e)?e.filter(Boolean):[]}function S(e,t){if(!Array.isArray(e))return-1;for(var n=0;n<e.length;n++)if(t(e[n]))return n;return-1}function P(e,t){var i=(t||[]).map(function(e){return e.split(":")});return e.reduce(function(e,t){var n=t.split(":"),r=v(i,function(e){return e[0]===n[0]});return 1<n.length||!r?(e[0].push(n[0]),e[1].push(n[1])):(e[0].push(r[0]),e[1].push(r[1])),e},[[],[]])}var N=function(e,n,i){if(!Array.isArray(e))return[];Array.isArray(i)||(i=[]);var t=e.map(function(t,e){return{criteria:n.map(function(e){return t[e]}),index:e,value:t}});return t.sort(function(e,t){for(var n=-1;++n<e.criteria.length;){var r=w(e.criteria[n],t.criteria[n]);if(r)return n>=i.length?r:"desc"===i[n]?-r:r}return e.index-t.index}),t.map(function(e){return e.value})},x=function(h){return function(e,t){var n=h.hierarchicalFacets[t],r=h.hierarchicalFacetsRefinements[n.name]&&h.hierarchicalFacetsRefinements[n.name][0]||"",i=h._getHierarchicalFacetSeparator(n),a=h._getHierarchicalRootPath(n),s=h._getHierarchicalShowParentLevel(n),o=P(h._getHierarchicalFacetSortBy(n)),c=e.every(function(e){return e.exhaustive}),u=function(o,c,u,l,h){return function(e,n,t){var r=e;if(0<t){var i=0;for(r=e;i<t;){var a=r&&Array.isArray(r.data)?r.data:[];r=v(a,function(e){return e.isRefined}),i++}}if(r){var s=Object.keys(n.data).map(function(e){return[e,n.data[e]]}).filter(function(e){return function(e,t,n,r,i,a){return(!i||0===e.indexOf(i)&&i!==e)&&(!i&&-1===e.indexOf(r)||i&&e.split(r).length-i.split(r).length==1||-1===e.indexOf(r)&&-1===n.indexOf(r)||0===n.indexOf(e)||0===e.indexOf(t+r)&&(a||0===e.indexOf(n)))}(e[0],r.path||u,h,c,u,l)});r.data=N(s.map(function(e){var t=e[0];return function(e,t,n,r,i){var a=t.split(n);return{name:a[a.length-1].trim(),path:t,count:e,isRefined:r===t||0===r.indexOf(t+n),exhaustive:i,data:null}}(e[1],t,c,h,n.exhaustive)}),o[0],o[1])}return e}}(o,i,a,s,r),l=e;return a&&(l=e.slice(a.split(i).length)),l.reduce(u,{name:h.hierarchicalFacets[t].name,count:null,isRefined:!0,path:null,exhaustive:c,data:null})}};function F(e){var n={};return e.forEach(function(e,t){n[e]=t}),n}function I(e,t,n){t&&t[n]&&(e.stats=t[n])}function C(l,n){var c=n[0];this._rawResults=n;var h=this;Object.keys(c).forEach(function(e){h[e]=c[e]}),this.processingTimeMS=n.reduce(function(e,t){return void 0===t.processingTimeMS?e:e+t.processingTimeMS},0),this.disjunctiveFacets=[],this.hierarchicalFacets=l.hierarchicalFacets.map(function(){return[]}),this.facets=[];var e=l.getRefinedDisjunctiveFacets(),u=F(l.facets),f=F(l.disjunctiveFacets),r=1,d=c.facets||{};Object.keys(d).forEach(function(e){var t=d[e],n=function(e,t){return v(e,function(e){return-1<(e.attributes||[]).indexOf(t)})}(l.hierarchicalFacets,e);if(n){var r=n.attributes.indexOf(e),i=S(l.hierarchicalFacets,function(e){return e.name===n.name});h.hierarchicalFacets[i][r]={attribute:e,data:t,exhaustive:c.exhaustiveFacetsCount}}else{var a,s=-1!==l.disjunctiveFacets.indexOf(e),o=-1!==l.facets.indexOf(e);s&&(a=f[e],h.disjunctiveFacets[a]={name:e,data:t,exhaustive:c.exhaustiveFacetsCount},I(h.disjunctiveFacets[a],c.facets_stats,e)),o&&(a=u[e],h.facets[a]={name:e,data:t,exhaustive:c.exhaustiveFacetsCount},I(h.facets[a],c.facets_stats,e))}}),this.hierarchicalFacets=t(this.hierarchicalFacets),e.forEach(function(e){var a=n[r],s=a&&a.facets?a.facets:{},o=l.getHierarchicalFacetByName(e);Object.keys(s).forEach(function(t){var n,e=s[t];if(o){n=S(l.hierarchicalFacets,function(e){return e.name===o.name});var r=S(h.hierarchicalFacets[n],function(e){return e.attribute===t});if(-1===r)return;h.hierarchicalFacets[n][r].data=p({},h.hierarchicalFacets[n][r].data,e)}else{n=f[t];var i=c.facets&&c.facets[t]||{};h.disjunctiveFacets[n]={name:t,data:m({},e,i),exhaustive:a.exhaustiveFacetsCount},I(h.disjunctiveFacets[n],a.facets_stats,t),l.disjunctiveFacetsRefinements[t]&&l.disjunctiveFacetsRefinements[t].forEach(function(e){!h.disjunctiveFacets[n].data[e]&&-1<l.disjunctiveFacetsRefinements[t].indexOf(e)&&(h.disjunctiveFacets[n].data[e]=0)})}}),r++}),l.getRefinedHierarchicalFacets().forEach(function(e){var s=l.getHierarchicalFacetByName(e),o=l._getHierarchicalFacetSeparator(s),c=l.getHierarchicalRefinement(e);if(!(0===c.length||c[0].split(o).length<2)){var t=n[r],u=t&&t.facets?t.facets:{};Object.keys(u).forEach(function(t){var e=u[t],n=S(l.hierarchicalFacets,function(e){return e.name===s.name}),r=S(h.hierarchicalFacets[n],function(e){return e.attribute===t});if(-1!==r){var i={};if(0<c.length){var a=c[0].split(o)[0];i[a]=h.hierarchicalFacets[n][r].data[a]}h.hierarchicalFacets[n][r].data=m(i,e,h.hierarchicalFacets[n][r].data)}}),r++}}),Object.keys(l.facetsExcludes).forEach(function(t){var e=l.facetsExcludes[t],n=u[t];h.facets[n]={name:t,data:c.facets[t],exhaustive:c.exhaustiveFacetsCount},e.forEach(function(e){h.facets[n]=h.facets[n]||{name:t},h.facets[n].data=h.facets[n].data||{},h.facets[n].data[e]=0})}),this.hierarchicalFacets=this.hierarchicalFacets.map(x(l)),this.facets=t(this.facets),this.disjunctiveFacets=t(this.disjunctiveFacets),this._state=l}function T(t,e){if(!e.data||0===e.data.length)return e;var n=e.data.map(function(e){return T(t,e)}),r=t(n);return p({},e,{data:r})}function E(e,t){var n=v(e,function(e){return e.name===t});return n&&n.stats}function q(e,t,n,r,i){var a=v(i,function(e){return e.name===n}),s=a&&a.data&&a.data[r]?a.data[r]:0,o=a&&a.exhaustive||!1;return{type:t,attributeName:n,name:r,count:s,exhaustive:o}}C.prototype.getFacetByName=function(t){function e(e){return e.name===t}return v(this.facets,e)||v(this.disjunctiveFacets,e)||v(this.hierarchicalFacets,e)},C.DEFAULT_SORT=["isRefined:desc","count:desc","name:asc"],C.prototype.getFacetValues=function(e,t){var n=function(t,n){function e(e){return e.name===n}if(t._state.isConjunctiveFacet(n)){var r=v(t.facets,e);return r?Object.keys(r.data).map(function(e){return{name:e,count:r.data[e],isRefined:t._state.isFacetRefined(n,e),isExcluded:t._state.isExcludeRefined(n,e)}}):[]}if(t._state.isDisjunctiveFacet(n)){var i=v(t.disjunctiveFacets,e);return i?Object.keys(i.data).map(function(e){return{name:e,count:i.data[e],isRefined:t._state.isDisjunctiveFacetRefined(n,e)}}):[]}if(t._state.isHierarchicalFacet(n))return v(t.hierarchicalFacets,e)}(this,e);if(n){var r=m({},t,{sortBy:C.DEFAULT_SORT});if(Array.isArray(r.sortBy)){var i=P(r.sortBy,C.DEFAULT_SORT);return Array.isArray(n)?N(n,i[0],i[1]):T(function(e){return N(e,i[0],i[1])},n)}if("function"==typeof r.sortBy)return Array.isArray(n)?n.sort(r.sortBy):T(function(e){return function(e,t){return t.sort(e)}(r.sortBy,e)},n);throw new Error("options.sortBy is optional but if defined it must be either an array of string (predicates) or a sorting function")}},C.prototype.getFacetStats=function(e){return this._state.isConjunctiveFacet(e)?E(this.facets,e):this._state.isDisjunctiveFacet(e)?E(this.disjunctiveFacets,e):void 0},C.prototype.getRefinements=function(){var r=this._state,n=this,i=[];return Object.keys(r.facetsRefinements).forEach(function(t){r.facetsRefinements[t].forEach(function(e){i.push(q(r,"facet",t,e,n.facets))})}),Object.keys(r.facetsExcludes).forEach(function(t){r.facetsExcludes[t].forEach(function(e){i.push(q(r,"exclude",t,e,n.facets))})}),Object.keys(r.disjunctiveFacetsRefinements).forEach(function(t){r.disjunctiveFacetsRefinements[t].forEach(function(e){i.push(q(r,"disjunctive",t,e,n.disjunctiveFacets))})}),Object.keys(r.hierarchicalFacetsRefinements).forEach(function(t){r.hierarchicalFacetsRefinements[t].forEach(function(e){i.push(function(e,t,n,r){var i=e.getHierarchicalFacetByName(t),a=e._getHierarchicalFacetSeparator(i),s=n.split(a),o=v(r,function(e){return e.name===t}),c=s.reduce(function(e,t){var n=e&&v(e.data,function(e){return e.name===t});return void 0!==n?n:e},o),u=c&&c.count||0,l=c&&c.exhaustive||!1,h=c&&c.path||"";return{type:"hierarchical",attributeName:t,name:h,count:u,exhaustive:l}}(r,t,e,n.hierarchicalFacets))})}),Object.keys(r.numericRefinements).forEach(function(n){var e=r.numericRefinements[n];Object.keys(e).forEach(function(t){e[t].forEach(function(e){i.push({type:"numeric",attributeName:n,name:e,numericValue:e,operator:t})})})}),r.tagRefinements.forEach(function(e){i.push({type:"tag",attributeName:"_tags",name:e})}),i};var U=C;function V(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}var e=V;function W(e){return"function"==typeof e}function $(e){return"object"==typeof e&&null!==e}function z(e){return void 0===e}(V.EventEmitter=V).prototype._events=void 0,V.prototype._maxListeners=void 0,V.defaultMaxListeners=10,V.prototype.setMaxListeners=function(e){if(!function(e){return"number"==typeof e}(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},V.prototype.emit=function(e){var t,n,r,i,a,s;if(this._events||(this._events={}),"error"===e&&(!this._events.error||$(this._events.error)&&!this._events.error.length)){if((t=arguments[1])instanceof Error)throw t;var o=new Error('Uncaught, unspecified "error" event. ('+t+")");throw o.context=t,o}if(z(n=this._events[e]))return!1;if(W(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:i=Array.prototype.slice.call(arguments,1),n.apply(this,i)}else if($(n))for(i=Array.prototype.slice.call(arguments,1),r=(s=n.slice()).length,a=0;a<r;a++)s[a].apply(this,i);return!0},V.prototype.on=V.prototype.addListener=function(e,t){var n;if(!W(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,W(t.listener)?t.listener:t),this._events[e]?$(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,$(this._events[e])&&!this._events[e].warned&&(n=z(this._maxListeners)?V.defaultMaxListeners:this._maxListeners)&&0<n&&this._events[e].length>n&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace()),this},V.prototype.once=function(e,t){if(!W(t))throw TypeError("listener must be a function");var n=!1;function r(){this.removeListener(e,r),n||(n=!0,t.apply(this,arguments))}return r.listener=t,this.on(e,r),this},V.prototype.removeListener=function(e,t){var n,r,i,a;if(!W(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(i=(n=this._events[e]).length,r=-1,n===t||W(n.listener)&&n.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if($(n)){for(a=i;0<a--;)if(n[a]===t||n[a].listener&&n[a].listener===t){r=a;break}if(r<0)return this;1===n.length?(n.length=0,delete this._events[e]):n.splice(r,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},V.prototype.removeAllListeners=function(e){var t,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(W(n=this._events[e]))this.removeListener(e,n);else if(n)for(;n.length;)this.removeListener(e,n[n.length-1]);return delete this._events[e],this},V.prototype.listeners=function(e){return this._events&&this._events[e]?W(this._events[e])?[this._events[e]]:this._events[e].slice():[]},V.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(W(t))return 1;if(t)return t.length}return 0},V.listenerCount=function(e,t){return e.listenerCount(t)};var K=function(e,t){e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})};function J(e,t){this.main=e,this.fn=t,this.lastResults=null}K(J,e.EventEmitter),J.prototype.detach=function(){this.removeAllListeners(),this.main.detachDerivedHelper(this)},J.prototype.getModifiedState=function(e){return this.fn(e)};var Y=J,G={_getQueries:function(i,a){var s=[];return s.push({indexName:i,params:G._getHitsSearchParams(a)}),a.getRefinedDisjunctiveFacets().forEach(function(e){s.push({indexName:i,params:G._getDisjunctiveFacetSearchParams(a,e)})}),a.getRefinedHierarchicalFacets().forEach(function(e){var t=a.getHierarchicalFacetByName(e),n=a.getHierarchicalRefinement(e),r=a._getHierarchicalFacetSeparator(t);0<n.length&&1<n[0].split(r).length&&s.push({indexName:i,params:G._getDisjunctiveFacetSearchParams(a,e,!0)})}),s},_getHitsSearchParams:function(e){var t=e.facets.concat(e.disjunctiveFacets).concat(G._getHitsHierarchicalFacetsAttributes(e)),n=G._getFacetFilters(e),r=G._getNumericFilters(e),i={facets:t,tagFilters:G._getTagFilters(e)};return 0<n.length&&(i.facetFilters=n),0<r.length&&(i.numericFilters=r),p({},e.getQueryParams(),i)},_getDisjunctiveFacetSearchParams:function(e,t,n){var r=G._getFacetFilters(e,t,n),i=G._getNumericFilters(e,t),a={hitsPerPage:1,page:0,attributesToRetrieve:[],attributesToHighlight:[],attributesToSnippet:[],tagFilters:G._getTagFilters(e),analytics:!1,clickAnalytics:!1},s=e.getHierarchicalFacetByName(t);return a.facets=s?G._getDisjunctiveHierarchicalFacetAttribute(e,s,n):t,0<i.length&&(a.numericFilters=i),0<r.length&&(a.facetFilters=r),p({},e.getQueryParams(),a)},_getNumericFilters:function(e,i){if(e.numericFilters)return e.numericFilters;var a=[];return Object.keys(e.numericRefinements).forEach(function(r){var t=e.numericRefinements[r]||{};Object.keys(t).forEach(function(n){var e=t[n]||[];i!==r&&e.forEach(function(e){if(Array.isArray(e)){var t=e.map(function(e){return r+n+e});a.push(t)}else a.push(r+n+e)})})}),a},_getTagFilters:function(e){return e.tagFilters?e.tagFilters:e.tagRefinements.join(",")},_getFacetFilters:function(o,c,u){var l=[],e=o.facetsRefinements||{};Object.keys(e).forEach(function(t){(e[t]||[]).forEach(function(e){l.push(t+":"+e)})});var n=o.facetsExcludes||{};Object.keys(n).forEach(function(t){(n[t]||[]).forEach(function(e){l.push(t+":-"+e)})});var r=o.disjunctiveFacetsRefinements||{};Object.keys(r).forEach(function(t){var e=r[t]||[];if(t!==c&&e&&0!==e.length){var n=[];e.forEach(function(e){n.push(t+":"+e)}),l.push(n)}});var h=o.hierarchicalFacetsRefinements||{};return Object.keys(h).forEach(function(e){var t=(h[e]||[])[0];if(void 0!==t){var n,r,i=o.getHierarchicalFacetByName(e),a=o._getHierarchicalFacetSeparator(i),s=o._getHierarchicalRootPath(i);if(c===e){if(-1===t.indexOf(a)||!s&&!0===u||s&&s.split(a).length===t.split(a).length)return;t=s?(r=s.split(a).length-1,s):(r=t.split(a).length-2,t.slice(0,t.lastIndexOf(a))),n=i.attributes[r]}else r=t.split(a).length-1,n=i.attributes[r];n&&l.push([n+":"+t])}}),l},_getHitsHierarchicalFacetsAttributes:function(s){return s.hierarchicalFacets.reduce(function(e,t){var n=s.getHierarchicalRefinement(t.name)[0];if(!n)return e.push(t.attributes[0]),e;var r=s._getHierarchicalFacetSeparator(t),i=n.split(r).length,a=t.attributes.slice(0,i+1);return e.concat(a)},[])},_getDisjunctiveHierarchicalFacetAttribute:function(e,t,n){var r=e._getHierarchicalFacetSeparator(t);if(!0===n){var i=e._getHierarchicalRootPath(t),a=0;return i&&(a=i.split(r).length),[t.attributes[a]]}var s=(e.getHierarchicalRefinement(t.name)[0]||"").split(r).length-1;return t.attributes.slice(0,1+s)},getSearchForFacetQuery:function(e,t,n,r){var i=r.isDisjunctiveFacet(e)?r.clearRefinements(e):r,a={facetQuery:t,facetName:e};return"number"==typeof n&&(a.maxFacetHits=n),p({},G._getHitsSearchParams(i),a)}},X=G,Z="3.2.2";function ee(e,t,n){"function"==typeof e.addAlgoliaAgent&&e.addAlgoliaAgent("JS Helper (3.2.2)"),this.setClient(e);var r=n||{};r.index=t,this.state=R.make(r),this.lastResults=null,this._queryId=0,this._lastQueryIdReceived=-1,this.derivedHelpers=[],this._currentNbQueries=0}function te(e){if(e<0)throw new Error("Page requested below 0.");return this._change({state:this.state.setPage(e),isPageReset:!1}),this}function ne(){return this.state.page}K(ee,e.EventEmitter),ee.prototype.search=function(){return this._search({onlyWithDerivedHelpers:!1}),this},ee.prototype.searchOnlyWithDerivedHelpers=function(){return this._search({onlyWithDerivedHelpers:!0}),this},ee.prototype.getQuery=function(){var e=this.state;return X._getHitsSearchParams(e)},ee.prototype.searchOnce=function(e,t){var n=e?this.state.setQueryParameters(e):this.state,r=X._getQueries(n.index,n),i=this;if(this._currentNbQueries++,this.emit("searchOnce",{state:n}),!t)return this.client.search(r).then(function(e){return i._currentNbQueries--,0===i._currentNbQueries&&i.emit("searchQueueEmpty"),{content:new U(n,e.results),state:n,_originalResponse:e}},function(e){throw i._currentNbQueries--,0===i._currentNbQueries&&i.emit("searchQueueEmpty"),e});this.client.search(r).then(function(e){i._currentNbQueries--,0===i._currentNbQueries&&i.emit("searchQueueEmpty"),t(null,new U(n,e.results),n)}).catch(function(e){i._currentNbQueries--,0===i._currentNbQueries&&i.emit("searchQueueEmpty"),t(e,null,n)})},ee.prototype.searchForFacetValues=function(t,e,n,r){var i="function"==typeof this.client.searchForFacetValues;if(!i&&"function"!=typeof this.client.initIndex)throw new Error("search for facet values (searchable) was called, but this client does not have a function client.searchForFacetValues or client.initIndex(index).searchForFacetValues");var a=this.state.setQueryParameters(r||{}),s=a.isDisjunctiveFacet(t),o=X.getSearchForFacetQuery(t,e,n,a);this._currentNbQueries++;var c=this;return this.emit("searchForFacetValues",{state:a,facet:t,query:e}),(i?this.client.searchForFacetValues([{indexName:a.index,params:o}]):this.client.initIndex(a.index).searchForFacetValues(o)).then(function(e){return c._currentNbQueries--,0===c._currentNbQueries&&c.emit("searchQueueEmpty"),(e=Array.isArray(e)?e[0]:e).facetHits.forEach(function(e){e.isRefined=s?a.isDisjunctiveFacetRefined(t,e.value):a.isFacetRefined(t,e.value)}),e},function(e){throw c._currentNbQueries--,0===c._currentNbQueries&&c.emit("searchQueueEmpty"),e})},ee.prototype.setQuery=function(e){return this._change({state:this.state.resetPage().setQuery(e),isPageReset:!0}),this},ee.prototype.clearRefinements=function(e){return this._change({state:this.state.resetPage().clearRefinements(e),isPageReset:!0}),this},ee.prototype.clearTags=function(){return this._change({state:this.state.resetPage().clearTags(),isPageReset:!0}),this},ee.prototype.addDisjunctiveFacetRefinement=function(e,t){return this._change({state:this.state.resetPage().addDisjunctiveFacetRefinement(e,t),isPageReset:!0}),this},ee.prototype.addDisjunctiveRefine=function(){return this.addDisjunctiveFacetRefinement.apply(this,arguments)},ee.prototype.addHierarchicalFacetRefinement=function(e,t){return this._change({state:this.state.resetPage().addHierarchicalFacetRefinement(e,t),isPageReset:!0}),this},ee.prototype.addNumericRefinement=function(e,t,n){return this._change({state:this.state.resetPage().addNumericRefinement(e,t,n),isPageReset:!0}),this},ee.prototype.addFacetRefinement=function(e,t){return this._change({state:this.state.resetPage().addFacetRefinement(e,t),isPageReset:!0}),this},ee.prototype.addRefine=function(){return this.addFacetRefinement.apply(this,arguments)},ee.prototype.addFacetExclusion=function(e,t){return this._change({state:this.state.resetPage().addExcludeRefinement(e,t),isPageReset:!0}),this},ee.prototype.addExclude=function(){return this.addFacetExclusion.apply(this,arguments)},ee.prototype.addTag=function(e){return this._change({state:this.state.resetPage().addTagRefinement(e),isPageReset:!0}),this},ee.prototype.removeNumericRefinement=function(e,t,n){return this._change({state:this.state.resetPage().removeNumericRefinement(e,t,n),isPageReset:!0}),this},ee.prototype.removeDisjunctiveFacetRefinement=function(e,t){return this._change({state:this.state.resetPage().removeDisjunctiveFacetRefinement(e,t),isPageReset:!0}),this},ee.prototype.removeDisjunctiveRefine=function(){return this.removeDisjunctiveFacetRefinement.apply(this,arguments)},ee.prototype.removeHierarchicalFacetRefinement=function(e){return this._change({state:this.state.resetPage().removeHierarchicalFacetRefinement(e),isPageReset:!0}),this},ee.prototype.removeFacetRefinement=function(e,t){return this._change({state:this.state.resetPage().removeFacetRefinement(e,t),isPageReset:!0}),this},ee.prototype.removeRefine=function(){return this.removeFacetRefinement.apply(this,arguments)},ee.prototype.removeFacetExclusion=function(e,t){return this._change({state:this.state.resetPage().removeExcludeRefinement(e,t),isPageReset:!0}),this},ee.prototype.removeExclude=function(){return this.removeFacetExclusion.apply(this,arguments)},ee.prototype.removeTag=function(e){return this._change({state:this.state.resetPage().removeTagRefinement(e),isPageReset:!0}),this},ee.prototype.toggleFacetExclusion=function(e,t){return this._change({state:this.state.resetPage().toggleExcludeFacetRefinement(e,t),isPageReset:!0}),this},ee.prototype.toggleExclude=function(){return this.toggleFacetExclusion.apply(this,arguments)},ee.prototype.toggleRefinement=function(e,t){return this.toggleFacetRefinement(e,t)},ee.prototype.toggleFacetRefinement=function(e,t){return this._change({state:this.state.resetPage().toggleFacetRefinement(e,t),isPageReset:!0}),this},ee.prototype.toggleRefine=function(){return this.toggleFacetRefinement.apply(this,arguments)},ee.prototype.toggleTag=function(e){return this._change({state:this.state.resetPage().toggleTagRefinement(e),isPageReset:!0}),this},ee.prototype.nextPage=function(){var e=this.state.page||0;return this.setPage(e+1)},ee.prototype.previousPage=function(){var e=this.state.page||0;return this.setPage(e-1)},ee.prototype.setCurrentPage=te,ee.prototype.setPage=te,ee.prototype.setIndex=function(e){return this._change({state:this.state.resetPage().setIndex(e),isPageReset:!0}),this},ee.prototype.setQueryParameter=function(e,t){return this._change({state:this.state.resetPage().setQueryParameter(e,t),isPageReset:!0}),this},ee.prototype.setState=function(e){return this._change({state:R.make(e),isPageReset:!1}),this},ee.prototype.overrideStateWithoutTriggeringChangeEvent=function(e){return this.state=new R(e),this},ee.prototype.hasRefinements=function(e){return!!l(this.state.getNumericRefinements(e))||(this.state.isConjunctiveFacet(e)?this.state.isFacetRefined(e):this.state.isDisjunctiveFacet(e)?this.state.isDisjunctiveFacetRefined(e):!!this.state.isHierarchicalFacet(e)&&this.state.isHierarchicalFacetRefined(e))},ee.prototype.isExcluded=function(e,t){return this.state.isExcludeRefined(e,t)},ee.prototype.isDisjunctiveRefined=function(e,t){return this.state.isDisjunctiveFacetRefined(e,t)},ee.prototype.hasTag=function(e){return this.state.isTagRefined(e)},ee.prototype.isTagRefined=function(){return this.hasTagRefinements.apply(this,arguments)},ee.prototype.getIndex=function(){return this.state.index},ee.prototype.getCurrentPage=ne,ee.prototype.getPage=ne,ee.prototype.getTags=function(){return this.state.tagRefinements},ee.prototype.getRefinements=function(e){var n=[];if(this.state.isConjunctiveFacet(e))this.state.getConjunctiveRefinements(e).forEach(function(e){n.push({value:e,type:"conjunctive"})}),this.state.getExcludeRefinements(e).forEach(function(e){n.push({value:e,type:"exclude"})});else if(this.state.isDisjunctiveFacet(e)){this.state.getDisjunctiveRefinements(e).forEach(function(e){n.push({value:e,type:"disjunctive"})})}var r=this.state.getNumericRefinements(e);return Object.keys(r).forEach(function(e){var t=r[e];n.push({value:t,operator:e,type:"numeric"})}),n},ee.prototype.getNumericRefinement=function(e,t){return this.state.getNumericRefinement(e,t)},ee.prototype.getHierarchicalFacetBreadcrumb=function(e){return this.state.getHierarchicalFacetBreadcrumb(e)},ee.prototype._search=function(e){var r=this.state,i=[],t=[];e.onlyWithDerivedHelpers||(t=X._getQueries(r.index,r),i.push({state:r,queriesCount:t.length,helper:this}),this.emit("search",{state:r,results:this.lastResults}));var n=this.derivedHelpers.map(function(e){var t=e.getModifiedState(r),n=X._getQueries(t.index,t);return i.push({state:t,queriesCount:n.length,helper:e}),e.emit("search",{state:t,results:e.lastResults}),n}),a=Array.prototype.concat.apply(t,n),s=this._queryId++;this._currentNbQueries++;try{this.client.search(a).then(this._dispatchAlgoliaResponse.bind(this,i,s)).catch(this._dispatchAlgoliaError.bind(this,s))}catch(e){this.emit("error",{error:e})}},ee.prototype._dispatchAlgoliaResponse=function(e,t,n){if(!(t<this._lastQueryIdReceived)){this._currentNbQueries-=t-this._lastQueryIdReceived,this._lastQueryIdReceived=t,0===this._currentNbQueries&&this.emit("searchQueueEmpty");var s=n.results.slice();e.forEach(function(e){var t=e.state,n=e.queriesCount,r=e.helper,i=s.splice(0,n),a=r.lastResults=new U(t,i);r.emit("result",{results:a,state:t})})}},ee.prototype._dispatchAlgoliaError=function(e,t){e<this._lastQueryIdReceived||(this._currentNbQueries-=e-this._lastQueryIdReceived,this._lastQueryIdReceived=e,this.emit("error",{error:t}),0===this._currentNbQueries&&this.emit("searchQueueEmpty"))},ee.prototype.containsRefinement=function(e,t,n,r){return e||0!==t.length||0!==n.length||0!==r.length},ee.prototype._hasDisjunctiveRefinements=function(e){return this.state.disjunctiveRefinements[e]&&0<this.state.disjunctiveRefinements[e].length},ee.prototype._change=function(e){var t=e.state,n=e.isPageReset;t!==this.state&&(this.state=t,this.emit("change",{state:this.state,results:this.lastResults,isPageReset:n}))},ee.prototype.clearCache=function(){return this.client.clearCache&&this.client.clearCache(),this},ee.prototype.setClient=function(e){return this.client===e||("function"==typeof e.addAlgoliaAgent&&e.addAlgoliaAgent("JS Helper (3.2.2)"),this.client=e),this},ee.prototype.getClient=function(){return this.client},ee.prototype.derive=function(e){var t=new Y(this,e);return this.derivedHelpers.push(t),t},ee.prototype.detachDerivedHelper=function(e){var t=this.derivedHelpers.indexOf(e);if(-1===t)throw new Error("Derived helper already detached");this.derivedHelpers.splice(t,1)},ee.prototype.hasPendingRequests=function(){return 0<this._currentNbQueries};var re=ee;function ie(e,t,n){return new re(e,t,n)}ie.version=Z,ie.AlgoliaSearchHelper=re,ie.SearchParameters=R,ie.SearchResults=U;var ae=ie;function se(r){function e(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];null===i&&(i=oe.then(function(){i=null,a?a=!1:r.apply(void 0,t)}))}var i=null,a=!1;return e.wait=function(){if(null===i)throw new Error("The deferred function should be called before calling `wait()`");return i},e.cancel=function(){null!==i&&(a=!0)},e}var oe=Promise.resolve();function ce(e){var t="string"==typeof e,n=t?document.querySelector(e):e;if(function(e){return e instanceof HTMLElement||Boolean(e)&&0<e.nodeType}(n))return n;var r="Container must be `string` or `HTMLElement`.";throw t&&(r+=" Unable to find ".concat(e)),new Error(r)}function ue(e){return 1===e.button||e.altKey||e.ctrlKey||e.metaKey||e.shiftKey}function le(e){return e.filter(function(e,t,n){return n.indexOf(e)===t})}function he(e){var t=e.defaultTemplates,n=e.templates;return D({templatesConfig:e.templatesConfig},function(e,t){var a=0<arguments.length&&void 0!==e?e:{},s=1<arguments.length&&void 0!==t?t:{};return le([].concat(_(Object.keys(a)),_(Object.keys(s)))).reduce(function(e,t){var n=a[t],r=s[t],i=void 0!==r&&r!==n;return e.templates[t]=i?r:n,e.useCustomCompileOptions[t]=i,e},{templates:{},useCustomCompileOptions:{}})}(t,n))}function fe(e,t){return e(t={exports:{}},t.exports),t.exports}var de=fe(function(e,t){!function(R){var w=/\S/,t=/\"/g,n=/\n/g,r=/\r/g,i=/\\/g,a=/\u2028/,s=/\u2029/;function S(e){"}"===e.n.substr(e.n.length-1)&&(e.n=e.n.substring(0,e.n.length-1))}function P(e){return e.trim?e.trim():e.replace(/^\s*|\s*$/g,"")}function _(e,t,n){if(t.charAt(n)!=e.charAt(0))return!1;for(var r=1,i=e.length;r<i;r++)if(t.charAt(n+r)!=e.charAt(r))return!1;return!0}R.tags={"#":1,"^":2,"<":3,$:4,"/":5,"!":6,">":7,"=":8,_v:9,"{":10,"&":11,_t:12},R.scan=function(e,t){var n,r,i,a,s,o=e.length,c=0,u=null,l=null,h="",f=[],d=!1,m=0,p=0,v="{{",g="}}";function y(){0<h.length&&(f.push({tag:"_t",text:new String(h)}),h="")}function b(e,t){if(y(),e&&function(){for(var e=!0,t=p;t<f.length;t++)if(!(e=R.tags[f[t].tag]<R.tags._v||"_t"==f[t].tag&&null===f[t].text.match(w)))return!1;return e}())for(var n,r=p;r<f.length;r++)f[r].text&&((n=f[r+1])&&">"==n.tag&&(n.indent=f[r].text.toString()),f.splice(r,1));else t||f.push({tag:"\n"});d=!1,p=f.length}for(t&&(t=t.split(" "),v=t[0],g=t[1]),m=0;m<o;m++)0==c?_(v,e,m)?(--m,y(),c=1):"\n"==e.charAt(m)?b(d):h+=e.charAt(m):1==c?(m+=v.length-1,c="="==(u=(l=R.tags[e.charAt(m+1)])?e.charAt(m+1):"_v")?(r=m,void 0,i="="+g,a=(n=e).indexOf(i,r),s=P(n.substring(n.indexOf("=",r)+1,a)).split(" "),v=s[0],g=s[s.length-1],m=a+i.length-1,0):(l&&m++,2),d=m):_(g,e,m)?(f.push({tag:u,n:P(h),otag:v,ctag:g,i:"/"==u?d-v.length:m+g.length}),h="",m+=g.length-1,c=0,"{"==u&&("}}"==g?m++:S(f[f.length-1]))):h+=e.charAt(m);return b(d,!0),f};var u={_t:!0,"\n":!0,$:!0,"/":!0};function l(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n].o==e.n)return e.tag="#",!0}function h(e,t,n){for(var r=0,i=n.length;r<i;r++)if(n[r].c==e&&n[r].o==t)return!0}function o(e){var t=[];for(var n in e.partials)t.push('"'+f(n)+'":{name:"'+f(e.partials[n].name)+'", '+o(e.partials[n])+"}");return"partials: {"+t.join(",")+"}, subs: "+function(e){var t=[];for(var n in e)t.push('"'+f(n)+'": function(c,p,t,i) {'+e[n]+"}");return"{ "+t.join(",")+" }"}(e.subs)}R.stringify=function(e,t,n){return"{code: function (c,p,i) { "+R.wrapMain(e.code)+" },"+o(e)+"}"};var c=0;function f(e){return e.replace(i,"\\\\").replace(t,'\\"').replace(n,"\\n").replace(r,"\\r").replace(a,"\\u2028").replace(s,"\\u2029")}function d(e){return~e.indexOf(".")?"d":"f"}function m(e,t){var n="<"+(t.prefix||"")+e.n+c++;return t.partials[n]={name:e.n,partials:{}},t.code+='t.b(t.rp("'+f(n)+'",c,p,"'+(e.indent||"")+'"));',n}function e(e,t){t.code+="t.b(t.t(t."+d(e.n)+'("'+f(e.n)+'",c,p,0)));'}function p(e){return"t.b("+e+");"}R.generate=function(e,t,n){c=0;var r={code:"",subs:{},partials:{}};return R.walk(e,r),n.asString?this.stringify(r,t,n):this.makeTemplate(r,t,n)},R.wrapMain=function(e){return'var t=this;t.b(i=i||"");'+e+"return t.fl();"},R.template=R.Template,R.makeTemplate=function(e,t,n){var r=this.makePartials(e);return r.code=new Function("c","p","i",this.wrapMain(e.code)),new this.template(r,t,this,n)},R.makePartials=function(e){var t,n={subs:{},partials:e.partials,name:e.name};for(t in n.partials)n.partials[t]=this.makePartials(n.partials[t]);for(t in e.subs)n.subs[t]=new Function("c","p","t","i",e.subs[t]);return n},R.codegen={"#":function(e,t){t.code+="if(t.s(t."+d(e.n)+'("'+f(e.n)+'",c,p,1),c,p,0,'+e.i+","+e.end+',"'+e.otag+" "+e.ctag+'")){t.rs(c,p,function(c,p,t){',R.walk(e.nodes,t),t.code+="});c.pop();}"},"^":function(e,t){t.code+="if(!t.s(t."+d(e.n)+'("'+f(e.n)+'",c,p,1),c,p,1,0,0,"")){',R.walk(e.nodes,t),t.code+="};"},">":m,"<":function(e,t){var n={partials:{},code:"",subs:{},inPartial:!0};R.walk(e.nodes,n);var r=t.partials[m(e,t)];r.subs=n.subs,r.partials=n.partials},$:function(e,t){var n={subs:{},code:"",partials:t.partials,prefix:e.n};R.walk(e.nodes,n),t.subs[e.n]=n.code,t.inPartial||(t.code+='t.sub("'+f(e.n)+'",c,p,i);')},"\n":function(e,t){t.code+=p('"\\n"'+(e.last?"":" + i"))},_v:function(e,t){t.code+="t.b(t.v(t."+d(e.n)+'("'+f(e.n)+'",c,p,0)));'},_t:function(e,t){t.code+=p('"'+f(e.text)+'"')},"{":e,"&":e},R.walk=function(e,t){for(var n,r=0,i=e.length;r<i;r++)(n=R.codegen[e[r].tag])&&n(e[r],t);return t},R.parse=function(e,t,n){return function e(t,n,r,i){var a,s=[],o=null,c=null;for(a=r[r.length-1];0<t.length;){if(c=t.shift(),a&&"<"==a.tag&&!(c.tag in u))throw new Error("Illegal content in < super tag.");if(R.tags[c.tag]<=R.tags.$||l(c,i))r.push(c),c.nodes=e(t,c.tag,r,i);else{if("/"==c.tag){if(0===r.length)throw new Error("Closing tag without opener: /"+c.n);if(o=r.pop(),c.n!=o.n&&!h(c.n,o.n,i))throw new Error("Nesting error: "+o.n+" vs. "+c.n);return o.end=c.i,s}"\n"==c.tag&&(c.last=0==t.length||"\n"==t[0].tag)}s.push(c)}if(0<r.length)throw new Error("missing closing tag: "+r.pop().n);return s}(e,0,[],(n=n||{}).sectionTags||[])},R.cache={},R.cacheKey=function(e,t){return[e,!!t.asString,!!t.disableLambda,t.delimiters,!!t.modelGet].join("||")},R.compile=function(e,t){t=t||{};var n=R.cacheKey(e,t),r=this.cache[n];if(r){var i=r.partials;for(var a in i)delete i[a].instance;return r}return r=this.generate(this.parse(this.scan(e,t.delimiters),e,t),e,t),this.cache[n]=r}}(t)}),me=fe(function(e,t){!function(e){function l(e,t,n){var r;return t&&"object"==typeof t&&(void 0!==t[e]?r=t[e]:n&&t.get&&"function"==typeof t.get&&(r=t.get(e))),r}e.Template=function(e,t,n,r){e=e||{},this.r=e.code||this.r,this.c=n,this.options=r||{},this.text=t||"",this.partials=e.partials||{},this.subs=e.subs||{},this.buf=""},e.Template.prototype={r:function(e,t,n){return""},v:function(e){return e=o(e),s.test(e)?e.replace(t,"&amp;").replace(n,"&lt;").replace(r,"&gt;").replace(i,"&#39;").replace(a,"&quot;"):e},t:o,render:function(e,t,n){return this.ri([e],t||{},n)},ri:function(e,t,n){return this.r(e,t,n)},ep:function(e,t){var n=this.partials[e],r=t[n.name];if(n.instance&&n.base==r)return n.instance;if("string"==typeof r){if(!this.c)throw new Error("No compiler available.");r=this.c.compile(r,this.options)}if(!r)return null;if(this.partials[e].base=r,n.subs){for(key in t.stackText||(t.stackText={}),n.subs)t.stackText[key]||(t.stackText[key]=void 0!==this.activeSub&&t.stackText[this.activeSub]?t.stackText[this.activeSub]:this.text);r=function(e,t,n,r,i,a){function s(){}function o(){}var c;o.prototype=(s.prototype=e).subs;var u=new s;for(c in u.subs=new o,u.subsText={},u.buf="",r=r||{},u.stackSubs=r,u.subsText=a,t)r[c]||(r[c]=t[c]);for(c in r)u.subs[c]=r[c];for(c in i=i||{},u.stackPartials=i,n)i[c]||(i[c]=n[c]);for(c in i)u.partials[c]=i[c];return u}(r,n.subs,n.partials,this.stackSubs,this.stackPartials,t.stackText)}return this.partials[e].instance=r},rp:function(e,t,n,r){var i=this.ep(e,n);return i?i.ri(t,n,r):""},rs:function(e,t,n){var r=e[e.length-1];if(h(r))for(var i=0;i<r.length;i++)e.push(r[i]),n(e,t,this),e.pop();else n(e,t,this)},s:function(e,t,n,r,i,a,s){var o;return(!h(e)||0!==e.length)&&("function"==typeof e&&(e=this.ms(e,t,n,r,i,a,s)),o=!!e,!r&&o&&t&&t.push("object"==typeof e?e:t[t.length-1]),o)},d:function(e,t,n,r){var i,a=e.split("."),s=this.f(a[0],t,n,r),o=this.options.modelGet,c=null;if("."===e&&h(t[t.length-2]))s=t[t.length-1];else for(var u=1;u<a.length;u++)s=void 0!==(i=l(a[u],s,o))?(c=s,i):"";return!(r&&!s)&&(r||"function"!=typeof s||(t.push(c),s=this.mv(s,t,n),t.pop()),s)},f:function(e,t,n,r){for(var i=!1,a=!1,s=this.options.modelGet,o=t.length-1;0<=o;o--)if(void 0!==(i=l(e,t[o],s))){a=!0;break}return a?(r||"function"!=typeof i||(i=this.mv(i,t,n)),i):!r&&""},ls:function(e,t,n,r,i){var a=this.options.delimiters;return this.options.delimiters=i,this.b(this.ct(o(e.call(t,r)),t,n)),this.options.delimiters=a,!1},ct:function(e,t,n){if(this.options.disableLambda)throw new Error("Lambda features disabled.");return this.c.compile(e,this.options).render(t,n)},b:function(e){this.buf+=e},fl:function(){var e=this.buf;return this.buf="",e},ms:function(e,t,n,r,i,a,s){var o,c=t[t.length-1],u=e.call(c);return"function"==typeof u?!!r||(o=this.activeSub&&this.subsText&&this.subsText[this.activeSub]?this.subsText[this.activeSub]:this.text,this.ls(u,c,n,o.substring(i,a),s)):u},mv:function(e,t,n){var r=t[t.length-1],i=e.call(r);return"function"==typeof i?this.ct(o(i.call(r)),r,n):i},sub:function(e,t,n,r){var i=this.subs[e];i&&(this.activeSub=e,i(t,n,this,r),this.activeSub=!1)}};var t=/&/g,n=/</g,r=/>/g,i=/\'/g,a=/\"/g,s=/[&<>\"\']/;function o(e){return String(null==e?"":e)}var h=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}}(t)});de.Template=me.Template,de.template=de.Template;var pe=de;function ve(e){var t=e.templates,n=e.templateKey,r=e.compileOptions,i=e.helpers,a=e.data,s=e.bindEvent,o=t[n],c=h(o),u="function"===c;if(!("string"===c)&&!u)throw new Error("Template must be 'string' or 'function', was '".concat(c,"' (key: ").concat(n,")"));if(u)return o(a,s);var l=function(e,t,n){var r=0<arguments.length&&void 0!==e?e:{},i=1<arguments.length?t:void 0,a=2<arguments.length?n:void 0;return Object.keys(r).reduce(function(e,n){return D({},e,L({},n,function(){var t=this;return function(e){return r[n].call(a,e,function(e){return pe.compile(e,i).render(t)})}}))},{})}(i,r,a);return pe.compile(o,r).render(D({},a,{helpers:l})).replace(/[ \n\r\t\f\xA0]+/g,function(e){return e.replace(/(^|\xA0+)[^\xA0]+/g,"$1 ")}).trim()}function ge(e,t,n){return Array.prototype.find?e.find(t,n):e.filter(t,n)[0]}function ye(e){return String(e).replace(/^\\-/,"-")}function be(i,e,a,s,t){var o,n={type:e,attribute:a,name:s},c=ge(4<arguments.length&&void 0!==t?t:[],function(e){return e.name===a});"hierarchical"===e?function(){for(var e=i.getHierarchicalFacetByName(a),n=s.split(e.separator),t=function(t){c=c&&c.data&&ge(Object.keys(c.data).map(function(t){return function(e){return t[e]}}(c.data)),function(e){return e.name===n[t]})},r=0;void 0!==c&&r<n.length;++r)t(r);o=c&&c.count}():o=c&&c.data&&c.data[n.name];var r=c&&c.exhaustive;return void 0!==o&&(n.count=o),void 0!==r&&(n.exhaustive=r),n}function Re(n,r,e){var t=2<arguments.length&&void 0!==e&&e,a=[],i=r.facetsRefinements,s=void 0===i?{}:i,o=r.facetsExcludes,c=void 0===o?{}:o,u=r.disjunctiveFacetsRefinements,l=void 0===u?{}:u,h=r.hierarchicalFacetsRefinements,f=void 0===h?{}:h,d=r.numericRefinements,m=void 0===d?{}:d,p=r.tagRefinements,v=void 0===p?[]:p;return Object.keys(s).forEach(function(t){s[t].forEach(function(e){a.push(be(r,"facet",t,e,n.facets))})}),Object.keys(c).forEach(function(t){c[t].forEach(function(e){a.push({type:"exclude",attribute:t,name:e,exclude:!0})})}),Object.keys(l).forEach(function(t){l[t].forEach(function(e){a.push(be(r,"disjunctive",t,ye(e),n.disjunctiveFacets))})}),Object.keys(f).forEach(function(t){f[t].forEach(function(e){a.push(be(r,"hierarchical",t,e,n.hierarchicalFacets))})}),Object.keys(m).forEach(function(r){var i=m[r];Object.keys(i).forEach(function(e){var t=e,n=i[t];(Array.isArray(n)?n:[n]).forEach(function(e){a.push({type:"numeric",attribute:r,name:"".concat(e),numericValue:e,operator:t})})})}),v.forEach(function(e){a.push({type:"tag",attribute:"_tags",name:e})}),t&&r.query&&r.query.trim()&&a.push({attribute:"query",type:"query",name:r.query,query:r.query}),a}function we(e){var t=e.helper,n=e.attributesToClear,r=void 0===n?[]:n,i=t.state.setPage(0);return i=r.reduce(function(e,t){return i.isNumericRefined(t)?e.removeNumericRefinement(t):i.isHierarchicalFacet(t)?e.removeHierarchicalFacetRefinement(t):i.isDisjunctiveFacet(t)?e.removeDisjunctiveFacetRefinement(t):i.isConjunctiveFacet(t)?e.removeFacetRefinement(t):e},i),-1!==r.indexOf("query")&&(i=i.setQuery("")),i}function Se(e){return"number"==typeof e&&e<0&&(e=String(e).replace(/^-/,"\\-")),e}function Pe(e,t){if(void 0===e||"function"!=typeof e)throw new Error("The render function is not valid (received type ".concat(function(e){return Object.prototype.toString.call(e).slice(8,-1)}(e),").\n\n").concat(t))}function _e(){}function Ne(e,t){return t.split(".").reduce(function(e,t){return e&&e[t]},e)}function xe(e){return"number"==typeof e&&isFinite(e)}function Fe(e){if(!function(e){return"object"===h(e)&&null!==e}(e)||"[object Object]"!==function(e){return null===e?void 0===e?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}(e))return!1;if(null===Object.getPrototypeOf(e))return!0;for(var t=e;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function Ie(e){var t=e.start,n=void 0===t?0:t,r=e.end,i=e.step,a=void 0===i?1:i,s=0===a?1:a,o=Math.round((r-n)/s);return _(Array(o)).map(function(e,t){return n+t*s})}function Ce(e){return e!==Object(e)}function Te(e,t){if(e===t)return!0;if(Ce(e)||Ce(t)||"function"==typeof e||"function"==typeof t)return e===t;if(Object.keys(e).length!==Object.keys(t).length)return!1;for(var n=0,r=Object.keys(e);n<r.length;n++){var i=r[n];if(!(i in t))return!1;if(!Te(e[i],t[i]))return!1}return!0}var Ee={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},ke=/[&<>"']/g,Me=RegExp(ke.source);function Le(e,t){return e.setQueryParameters({hierarchicalFacets:t.hierarchicalFacets.reduce(function(e,t){var n=function(e,t){if(!Array.isArray(e))return-1;for(var n=0;n<e.length;n++)if(t(e[n]))return n;return-1}(e,function(e){return e.name===t.name});if(-1===n)return e.concat(t);var r=e.slice();return r.splice(n,1,t),r},e.hierarchicalFacets)})}function je(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce(function(e,t){var n=function(e,t){return e.setQueryParameters({hierarchicalFacetsRefinements:D({},e.hierarchicalFacetsRefinements,{},t.hierarchicalFacetsRefinements)})}(e,t);return function(e,t){t.facets,t.disjunctiveFacets,t.facetsRefinements,t.facetsExcludes,t.disjunctiveFacetsRefinements,t.numericRefinements,t.tagRefinements,t.hierarchicalFacets,t.hierarchicalFacetsRefinements,t.ruleContexts;var n=A(t,["facets","disjunctiveFacets","facetsRefinements","facetsExcludes","disjunctiveFacetsRefinements","numericRefinements","tagRefinements","hierarchicalFacets","hierarchicalFacetsRefinements","ruleContexts"]);return e.setQueryParameters(n)}(function(e,t){return t.facets.reduce(function(e,t){return e.addFacet(t)},e)}(function(e,t){var n=le([].concat(e.ruleContexts).concat(t.ruleContexts).filter(Boolean));return 0<n.length?e.setQueryParameters({ruleContexts:n}):e}(function(e,t){return t.disjunctiveFacets.reduce(function(e,t){return e.addDisjunctiveFacet(t)},e)}(function(e,t){return e.setQueryParameters({facetsRefinements:D({},e.facetsRefinements,{},t.facetsRefinements)})}(function(e,t){return e.setQueryParameters({facetsExcludes:D({},e.facetsExcludes,{},t.facetsExcludes)})}(function(e,t){return e.setQueryParameters({disjunctiveFacetsRefinements:D({},e.disjunctiveFacetsRefinements,{},t.disjunctiveFacetsRefinements)})}(function(e,t){return e.setQueryParameters({numericRefinements:D({},e.numericRefinements,{},t.numericRefinements)})}(function(e,t){return t.tagRefinements.reduce(function(e,t){return e.addTagRefinement(t)},e)}(Le(n,t),t),t),t),t),t),t),t),t),t)})}function Oe(e){return Array.isArray(e)?e:[e]}function Ae(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=t.map(function(e){return function(e){var t=e.name,n=e.connector;return["https://www.algolia.com/doc/api-reference/widgets/",t,"/js/",void 0!==n&&n?"#connector":""].join("")}(e)}).join(", ");return function(e){return[e,"See documentation: ".concat(r)].filter(Boolean).join("\n\n")}}var He=/^(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)$/;function De(e){return Array.isArray(e)?function(e){var t=Q(e,1)[0],n=Q(t=void 0===t?[void 0,void 0,void 0,void 0]:t,4),r=n[0],i=n[1],a=n[2],s=n[3];if(!(r&&i&&a&&s))throw new Error('Invalid value for "insideBoundingBox" parameter: ['.concat(e,"]"));return{northEast:{lat:r,lng:i},southWest:{lat:a,lng:s}}}(e):function(e){var t=Q(e.split(",").map(parseFloat),4),n=t[0],r=t[1],i=t[2],a=t[3];if(!(n&&r&&i&&a))throw new Error('Invalid value for "insideBoundingBox" parameter: "'.concat(e,'"'));return{northEast:{lat:n,lng:r},southWest:{lat:i,lng:a}}}(e)}function Be(e,n,r){return e.map(function(e,t){return D({},e,{__position:r*n+t+1})})}function Qe(e,t){return t?e.map(function(e){return D({},e,{__queryID:t})}):e}function qe(e){var o=e.instantSearchInstance,c=e.helper,u=e.attribute,l=e.widgetType;return function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=t[0],i=t[1],a=t[2],s=void 0===a?"Filter Applied":a;1===t.length&&"object"===h(t[0])?o.sendEventToInsights(t[0]):"click"!==r||2!==t.length&&3!==t.length||function(e,t,n){return e.state.isHierarchicalFacet(t)?e.state.isHierarchicalFacetRefined(t,n):e.state.isConjunctiveFacet(t)?e.state.isFacetRefined(t,n):e.state.isDisjunctiveFacetRefined(t,n)}(c,u,i)||o.sendEventToInsights({insightsMethod:"clickedFilters",widgetType:l,eventType:r,payload:{eventName:s,index:c.getIndex(),filters:["".concat(u,":").concat(JSON.stringify(i))]}})}}function Ue(e){var t=e.index,n=e.widgetType,r=(e.methodName,e.args);if(1===r.length&&"object"===h(r[0]))return r[0];var i=r[0],a=r[1],s=r[2];if(!a)return null;if(("click"===i||"conversion"===i)&&!s)return null;var o=Array.isArray(a)?a:[a];if(0===o.length)return null;var c=o[0].__queryID,u=o.map(function(e){return e.objectID}),l=o.map(function(e){return e.__position});return"view"===i?{insightsMethod:"viewedObjectIDs",widgetType:n,eventType:i,payload:{eventName:s||"Hits Viewed",index:t,objectIDs:u}}:"click"===i?{insightsMethod:"clickedObjectIDsAfterSearch",widgetType:n,eventType:i,payload:{eventName:s,index:t,queryID:c,objectIDs:u,positions:l}}:"conversion"===i?{insightsMethod:"convertedObjectIDsAfterSearch",widgetType:n,eventType:i,payload:{eventName:s,index:t,queryID:c,objectIDs:u}}:null}function Ve(e){var i=e.instantSearchInstance,a=e.index,s=e.widgetType;return function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=Ue({widgetType:s,index:a,methodName:"sendEvent",args:t});r&&i.sendEventToInsights(r)}}function We(e){var i=e.index,a=e.widgetType;return function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=Ue({widgetType:a,index:i,methodName:"bindEvent",args:t});return r?"data-insights-event=".concat(btoa(JSON.stringify(r))):""}}function $e(e,n){if(!e)return null;var r=e.numericRefinements[n],i=[];return Object.keys(r).filter(function(e){return Array.isArray(r[e])&&0<r[e].length}).forEach(function(t){r[t].forEach(function(e){i.push("".concat(n).concat(t).concat(e))})}),i}var ze=Ae({name:"index-widget"});function Ke(e){return"ais.index"===e.$$type}function Je(e,t){var n=t.state,r=t.isPageReset,i=t._uiState;n!==e.state&&(e.state=n,e.emit("change",{state:e.state,results:e.lastResults,isPageReset:r,_uiState:i}))}function Ye(e,n,t){var r=2<arguments.length&&void 0!==t?t:{};return e.filter(function(e){return!Ke(e)}).reduce(function(e,t){return t.getWidgetState?t.getWidgetState(e,n):e},r)}function Ge(e,t){var n=t.initialSearchParameters,r=A(t,["initialSearchParameters"]);return e.filter(function(e){return!Ke(e)}).reduce(function(e,t){return t.getWidgetSearchParameters?t.getWidgetSearchParameters(e,r):e},n)}function Xe(e){var t=e.getParent();return function n(e){return e.filter(Ke).reduce(function(e,t){return e.concat.apply(e,[{indexId:t.getIndexId(),results:t.getResults(),helper:t.getHelper()}].concat(_(n(t.getWidgets()))))},[])}(t?t.getWidgets():[e])}function Ze(e){if(void 0===e||void 0===e.indexName)throw new Error(ze("The `indexName` option is required."));function o(e){return f._createURL(L({},u,Ye(l,{searchParameters:e,helper:m})))}var c=e.indexName,t=e.indexId,u=void 0===t?c:t,l=[],h={},f=null,d=null,m=null,p=null;return{$$type:"ais.index",getIndexName:function(){return c},getIndexId:function(){return u},getHelper:function(){return m},getResults:function(){return p&&p.lastResults},getParent:function(){return d},getWidgets:function(){return l},addWidgets:function(e){var t=this;if(!Array.isArray(e))throw new Error(ze("The `addWidgets` method expects an array of widgets."));if(e.some(function(e){return"function"!=typeof e.init&&"function"!=typeof e.render}))throw new Error(ze("The widget definition expects a `render` and/or an `init` method."));return l=l.concat(e),f&&Boolean(e.length)&&(Je(m,{state:Ge(l,{uiState:h,initialSearchParameters:m.state}),_uiState:h}),e.forEach(function(e){f&&e.init&&e.init({helper:m,parent:t,uiState:f._initialUiState,instantSearchInstance:f,state:m.state,templatesConfig:f.templatesConfig,createURL:o})}),f.scheduleSearch()),this},removeWidgets:function(t){if(!Array.isArray(t))throw new Error(ze("The `removeWidgets` method expects an array of widgets."));if(t.some(function(e){return"function"!=typeof e.dispose}))throw new Error(ze("The widget definition expects a `dispose` method."));if(l=l.filter(function(e){return-1===t.indexOf(e)}),f&&Boolean(t.length)){var e=t.reduce(function(e,t){return t.dispose({helper:m,state:e})||e},m.state);h=Ye(l,{searchParameters:e,helper:m}),m.setState(Ge(l,{uiState:h,initialSearchParameters:e})),l.length&&f.scheduleSearch()}return this},init:function(e){var t=this,r=e.instantSearchInstance,n=e.parent,i=e.uiState;f=r,d=n,h=i[u]||{};var a=r.mainHelper,s=Ge(l,{uiState:h,initialSearchParameters:new ae.SearchParameters({index:c})});(m=ae({},s.index,s)).search=function(){return r.onStateChange?(r.onStateChange({uiState:r.mainIndex.getWidgetState({}),setUiState:r.setUiState.bind(r)}),a):a.search()},m.searchWithoutTriggeringOnStateChange=function(){return a.search()},m.searchForFacetValues=function(e,t,n,r){var i=m.state.setQueryParameters(r);return a.searchForFacetValues(e,t,n,i)},p=a.derive(function(){return je.apply(void 0,_(function(e){for(var t=e.getParent(),n=[e.getHelper().state];null!==t;)n=[t.getHelper().state].concat(n),t=t.getParent();return n}(t)))}),m.on("change",function(e){e.isPageReset&&!function n(e){var t=e.filter(Ke);0!==t.length&&t.forEach(function(e){var t=e.getHelper();Je(t,{state:t.state.resetPage(),isPageReset:!0}),n(e.getWidgets())})}(l)}),p.on("search",function(){r.scheduleStalledRender()}),p.on("result",function(e){var t=e.results;r.scheduleRender(),m.lastResults=t}),l.forEach(function(e){e.init&&e.init({uiState:i,helper:m,parent:t,instantSearchInstance:r,state:m.state,templatesConfig:r.templatesConfig,createURL:o})}),m.on("change",function(e){var t=e.state,n=e._uiState;h=Ye(l,{searchParameters:t,helper:m},n||{}),r.onStateChange||r.onInternalStateChange()})},render:function(e){var t=this,n=e.instantSearchInstance;l.forEach(function(e){e.render&&p.lastResults&&e.render({helper:m,instantSearchInstance:n,results:p.lastResults,scopedResults:Xe(t),state:p.lastResults._state,templatesConfig:n.templatesConfig,createURL:o,searchMetadata:{isSearchStalled:n._isSearchStalled}})})},dispose:function(){l.forEach(function(e){e.dispose&&e.dispose({helper:m,state:m.state})}),d=f=null,m.removeAllListeners(),m=null,p.detach(),p=null},getWidgetState:function(e){return l.filter(Ke).reduce(function(e,t){return t.getWidgetState(e)},D({},e,L({},this.getIndexId(),h)))},getWidgetSearchParameters:function(e,t){var n=t.uiState;return Ge(l,{uiState:n,initialSearchParameters:e})},refreshUiState:function(){h=Ye(l,{searchParameters:this.getHelper().state,helper:this.getHelper()})}}}var et={highlightPreTag:"__ais-highlight__",highlightPostTag:"__/ais-highlight__"},tt={highlightPreTag:"<mark>",highlightPostTag:"</mark>"};function nt(e){return function(e){return e&&Me.test(e)?e.replace(ke,function(e){return Ee[e]}):e}(e).replace(new RegExp(et.highlightPreTag,"g"),tt.highlightPreTag).replace(new RegExp(et.highlightPostTag,"g"),tt.highlightPostTag)}function rt(n){return Fe(n)&&"string"!=typeof n.value?Object.keys(n).reduce(function(e,t){return D({},e,L({},t,rt(n[t])))},{}):Array.isArray(n)?n.map(rt):D({},n,{value:nt(n.value)})}function it(e){return void 0===e.__escaped&&((e=e.map(function(e){var t=f({},e);return t._highlightResult&&(t._highlightResult=rt(t._highlightResult)),t._snippetResult&&(t._snippetResult=rt(t._snippetResult)),t})).__escaped=!0),e}function at(a){return function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.descendantName,n=e.modifierName,r=t?"-".concat(t):"",i=n?"--".concat(n):"";return"".concat("ais","-").concat(a).concat(r).concat(i)}}var st=at("Highlight");function ot(e){var t=e.attribute,n=e.highlightedTagName,r=void 0===n?"mark":n,i=e.hit,a=e.cssClasses,s=void 0===a?{}:a,o=Ne(i,"_highlightResult.".concat(t,".value"))||"",c=st({descendantName:"highlighted"})+(s.highlighted?" ".concat(s.highlighted):"");return o.replace(new RegExp(tt.highlightPreTag,"g"),"<".concat(r,' class="').concat(c,'">')).replace(new RegExp(tt.highlightPostTag,"g"),"</".concat(r,">"))}var ct=at("Snippet");function ut(e){var t=e.attribute,n=e.highlightedTagName,r=void 0===n?"mark":n,i=e.hit,a=e.cssClasses,s=void 0===a?{}:a,o=Ne(i,"_snippetResult.".concat(t,".value"))||"",c=ct({descendantName:"highlighted"})+(s.highlighted?" ".concat(s.highlighted):"");return o.replace(new RegExp(tt.highlightPreTag,"g"),"<".concat(r,' class="').concat(c,'">')).replace(new RegExp(tt.highlightPostTag,"g"),"</".concat(r,">"))}function lt(e,t){return function(e){var t,n=e.method,r=e.payload;if("object"!==h(r))throw new Error("The insights helper expects the payload to be an object.");try{t=btoa(JSON.stringify(r))}catch(e){throw new Error("Could not JSON serialize the payload object.")}return'data-insights-method="'.concat(n,'" data-insights-payload="').concat(t,'"')}({method:e,payload:t})}function ht(){return function(e){for(var t="".concat(e,"="),n=document.cookie.split(";"),r=0;r<n.length;r++){for(var i=n[r];" "===i.charAt(0);)i=i.substring(1);if(0===i.indexOf(t))return i.substring(t.length,i.length)}}("_ALGOLIA")}function ft(e){e.configure;return A(e,["configure"])}function dt(){return{stateToRoute:function(n){return Object.keys(n).reduce(function(e,t){return D({},e,L({},t,ft(n[t])))},{})},routeToState:function(e){var n=0<arguments.length&&void 0!==e?e:{};return Object.keys(n).reduce(function(e,t){return D({},e,L({},t,ft(n[t])))},{})}}}function mt(e,t){for(var n=t&&t.plainObjects?Object.create(null):{},r=0;r<e.length;++r)void 0!==e[r]&&(n[r]=e[r]);return n}function pt(e,t){kt.apply(e,Et(t)?t:[t])}function vt(e,t,n,r,i,a,s,o,c,u,l,h,f){var d=e;if("function"==typeof s?d=s(t,d):d instanceof Date?d=u(d):"comma"===n&&Et(d)&&(d=d.join(",")),null===d){if(r)return a&&!h?a(t,jt.encoder,f):t;d=""}if(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e||"symbol"==typeof e||"bigint"==typeof e}(d)||_t.isBuffer(d))return a?[l(h?t:a(t,jt.encoder,f))+"="+l(a(d,jt.encoder,f))]:[l(t)+"="+l(String(d))];var m,p=[];if(void 0===d)return p;if(Et(s))m=s;else{var v=Object.keys(d);m=o?v.sort(o):v}for(var g=0;g<m.length;++g){var y=m[g];i&&null===d[y]||(Et(d)?pt(p,vt(d[y],"function"==typeof n?n(t,y):t,n,r,i,a,s,o,c,u,l,h,f)):pt(p,vt(d[y],t+(c?"."+y:"["+y+"]"),n,r,i,a,s,o,c,u,l,h,f)))}return p}function gt(e,t,n){if(e){var r=n.allowDots?e.replace(/\.([^.[]+)/g,"[$1]"):e,i=/(\[[^[\]]*])/g,a=0<n.depth&&/(\[[^[\]]*])/.exec(r),s=a?r.slice(0,a.index):r,o=[];if(s){if(!n.plainObjects&&Ot.call(Object.prototype,s)&&!n.allowPrototypes)return;o.push(s)}for(var c=0;0<n.depth&&null!==(a=i.exec(r))&&c<n.depth;){if(c+=1,!n.plainObjects&&Ot.call(Object.prototype,a[1].slice(1,-1))&&!n.allowPrototypes)return;o.push(a[1])}return a&&o.push("["+r.slice(a.index)+"]"),function(e,t,n){for(var r=t,i=e.length-1;0<=i;--i){var a,s=e[i];if("[]"===s&&n.parseArrays)a=[].concat(r);else{a=n.plainObjects?Object.create(null):{};var o="["===s.charAt(0)&&"]"===s.charAt(s.length-1)?s.slice(1,-1):s,c=parseInt(o,10);n.parseArrays||""!==o?!isNaN(c)&&s!==o&&String(c)===o&&0<=c&&n.parseArrays&&c<=n.arrayLimit?(a=[])[c]=r:a[o]=r:a={0:r}}r=a}return r}(o,t,n)}}function yt(e){var t=e.qsModule,n=e.routeState,r=e.location,i=r.protocol,a=r.hostname,s=r.port,o=void 0===s?"":s,c=r.pathname,u=r.hash,l=t.stringify(n),h=""===o?"":":".concat(o);return l?"".concat(i,"//").concat(a).concat(h).concat(c,"?").concat(l).concat(u):"".concat(i,"//").concat(a).concat(h).concat(c).concat(u)}function bt(e){var t=e.qsModule,n=e.location;return t.parse(n.search.slice(1),{arrayLimit:99})}function Rt(e){e&&(window.document.title=e)}var wt=Object.prototype.hasOwnProperty,St=Array.isArray,Pt=function(){for(var e=[],t=0;t<256;++t)e.push("%"+((t<16?"0":"")+t.toString(16)).toUpperCase());return e}(),_t={arrayToObject:mt,assign:function(e,n){return Object.keys(n).reduce(function(e,t){return e[t]=n[t],e},e)},combine:function(e,t){return[].concat(e,t)},compact:function(e){for(var t=[{obj:{o:e},prop:"o"}],n=[],r=0;r<t.length;++r)for(var i=t[r],a=i.obj[i.prop],s=Object.keys(a),o=0;o<s.length;++o){var c=s[o],u=a[c];"object"==typeof u&&null!==u&&-1===n.indexOf(u)&&(t.push({obj:a,prop:c}),n.push(u))}return function(e){for(;1<e.length;){var t=e.pop(),n=t.obj[t.prop];if(St(n)){for(var r=[],i=0;i<n.length;++i)void 0!==n[i]&&r.push(n[i]);t.obj[t.prop]=r}}}(t),e},decode:function(e,t,n){var r=e.replace(/\+/g," ");if("iso-8859-1"===n)return r.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(r)}catch(e){return r}},encode:function(e,t,n){if(0===e.length)return e;var r=e;if("symbol"==typeof e?r=Symbol.prototype.toString.call(e):"string"!=typeof e&&(r=String(e)),"iso-8859-1"===n)return escape(r).replace(/%u[0-9a-f]{4}/gi,function(e){return"%26%23"+parseInt(e.slice(2),16)+"%3B"});for(var i="",a=0;a<r.length;++a){var s=r.charCodeAt(a);45===s||46===s||95===s||126===s||48<=s&&s<=57||65<=s&&s<=90||97<=s&&s<=122?i+=r.charAt(a):s<128?i+=Pt[s]:s<2048?i+=Pt[192|s>>6]+Pt[128|63&s]:s<55296||57344<=s?i+=Pt[224|s>>12]+Pt[128|s>>6&63]+Pt[128|63&s]:(a+=1,s=65536+((1023&s)<<10|1023&r.charCodeAt(a)),i+=Pt[240|s>>18]+Pt[128|s>>12&63]+Pt[128|s>>6&63]+Pt[128|63&s])}return i},isBuffer:function(e){return!(!e||"object"!=typeof e)&&!!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e))},isRegExp:function(e){return"[object RegExp]"===Object.prototype.toString.call(e)},merge:function r(i,a,s){if(!a)return i;if("object"!=typeof a){if(St(i))i.push(a);else{if(!i||"object"!=typeof i)return[i,a];(s&&(s.plainObjects||s.allowPrototypes)||!wt.call(Object.prototype,a))&&(i[a]=!0)}return i}if(!i||"object"!=typeof i)return[i].concat(a);var e=i;return St(i)&&!St(a)&&(e=mt(i,s)),St(i)&&St(a)?(a.forEach(function(e,t){if(wt.call(i,t)){var n=i[t];n&&"object"==typeof n&&e&&"object"==typeof e?i[t]=r(n,e,s):i.push(e)}else i[t]=e}),i):Object.keys(a).reduce(function(e,t){var n=a[t];return wt.call(e,t)?e[t]=r(e[t],n,s):e[t]=n,e},e)}},Nt=String.prototype.replace,xt=/%20/g,Ft={RFC1738:"RFC1738",RFC3986:"RFC3986"},It=_t.assign({default:Ft.RFC3986,formatters:{RFC1738:function(e){return Nt.call(e,xt,"+")},RFC3986:function(e){return String(e)}}},Ft),Ct=Object.prototype.hasOwnProperty,Tt={brackets:function(e){return e+"[]"},comma:"comma",indices:function(e,t){return e+"["+t+"]"},repeat:function(e){return e}},Et=Array.isArray,kt=Array.prototype.push,Mt=Date.prototype.toISOString,Lt=It.default,jt={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:_t.encode,encodeValuesOnly:!1,format:Lt,formatter:It.formatters[Lt],indices:!1,serializeDate:function(e){return Mt.call(e)},skipNulls:!1,strictNullHandling:!1},Ot=Object.prototype.hasOwnProperty,At={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:_t.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},Ht={formats:It,parse:function(e,t){var n=function(e){if(!e)return At;if(null!==e.decoder&&void 0!==e.decoder&&"function"!=typeof e.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");var t=void 0===e.charset?At.charset:e.charset;return{allowDots:void 0===e.allowDots?At.allowDots:!!e.allowDots,allowPrototypes:"boolean"==typeof e.allowPrototypes?e.allowPrototypes:At.allowPrototypes,arrayLimit:"number"==typeof e.arrayLimit?e.arrayLimit:At.arrayLimit,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:At.charsetSentinel,comma:"boolean"==typeof e.comma?e.comma:At.comma,decoder:"function"==typeof e.decoder?e.decoder:At.decoder,delimiter:"string"==typeof e.delimiter||_t.isRegExp(e.delimiter)?e.delimiter:At.delimiter,depth:"number"==typeof e.depth||!1===e.depth?+e.depth:At.depth,ignoreQueryPrefix:!0===e.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof e.interpretNumericEntities?e.interpretNumericEntities:At.interpretNumericEntities,parameterLimit:"number"==typeof e.parameterLimit?e.parameterLimit:At.parameterLimit,parseArrays:!1!==e.parseArrays,plainObjects:"boolean"==typeof e.plainObjects?e.plainObjects:At.plainObjects,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:At.strictNullHandling}}(t);if(""===e||null==e)return n.plainObjects?Object.create(null):{};for(var r="string"==typeof e?function(e,t){var n,r={},i=t.ignoreQueryPrefix?e.replace(/^\?/,""):e,a=t.parameterLimit===1/0?void 0:t.parameterLimit,s=i.split(t.delimiter,a),o=-1,c=t.charset;if(t.charsetSentinel)for(n=0;n<s.length;++n)0===s[n].indexOf("utf8=")&&("utf8=%E2%9C%93"===s[n]?c="utf-8":"utf8=%26%2310003%3B"===s[n]&&(c="iso-8859-1"),o=n,n=s.length);for(n=0;n<s.length;++n)if(n!==o){var u,l,h=s[n],f=h.indexOf("]="),d=-1===f?h.indexOf("="):f+1;(l=-1===d?(u=t.decoder(h,At.decoder,c),t.strictNullHandling?null:""):(u=t.decoder(h.slice(0,d),At.decoder,c),t.decoder(h.slice(d+1),At.decoder,c)))&&t.interpretNumericEntities&&"iso-8859-1"===c&&(l=l.replace(/&#(\d+);/g,function(e,t){return String.fromCharCode(parseInt(t,10))})),l&&t.comma&&-1<l.indexOf(",")&&(l=l.split(",")),Ot.call(r,u)?r[u]=_t.combine(r[u],l):r[u]=l}return r}(e,n):e,i=n.plainObjects?Object.create(null):{},a=Object.keys(r),s=0;s<a.length;++s){var o=a[s],c=gt(o,r[o],n);i=_t.merge(i,c,n)}return _t.compact(i)},stringify:function(e,t){var n,r=e,i=function(e){if(!e)return jt;if(null!==e.encoder&&void 0!==e.encoder&&"function"!=typeof e.encoder)throw new TypeError("Encoder has to be a function.");var t=e.charset||jt.charset;if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var n=It.default;if(void 0!==e.format){if(!Ct.call(It.formatters,e.format))throw new TypeError("Unknown format option provided.");n=e.format}var r=It.formatters[n],i=jt.filter;return"function"!=typeof e.filter&&!Et(e.filter)||(i=e.filter),{addQueryPrefix:"boolean"==typeof e.addQueryPrefix?e.addQueryPrefix:jt.addQueryPrefix,allowDots:void 0===e.allowDots?jt.allowDots:!!e.allowDots,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:jt.charsetSentinel,delimiter:void 0===e.delimiter?jt.delimiter:e.delimiter,encode:"boolean"==typeof e.encode?e.encode:jt.encode,encoder:"function"==typeof e.encoder?e.encoder:jt.encoder,encodeValuesOnly:"boolean"==typeof e.encodeValuesOnly?e.encodeValuesOnly:jt.encodeValuesOnly,filter:i,formatter:r,serializeDate:"function"==typeof e.serializeDate?e.serializeDate:jt.serializeDate,skipNulls:"boolean"==typeof e.skipNulls?e.skipNulls:jt.skipNulls,sort:"function"==typeof e.sort?e.sort:null,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:jt.strictNullHandling}}(t);"function"==typeof i.filter?r=(0,i.filter)("",r):Et(i.filter)&&(n=i.filter);var a,s=[];if("object"!=typeof r||null===r)return"";a=t&&t.arrayFormat in Tt?t.arrayFormat:t&&"indices"in t?t.indices?"indices":"repeat":"indices";var o=Tt[a];n=n||Object.keys(r),i.sort&&n.sort(i.sort);for(var c=0;c<n.length;++c){var u=n[c];i.skipNulls&&null===r[u]||pt(s,vt(r[u],u,o,i.strictNullHandling,i.skipNulls,i.encode?i.encoder:null,i.filter,i.sort,i.allowDots,i.serializeDate,i.formatter,i.encodeValuesOnly,i.charset))}var l=s.join(i.delimiter),h=!0===i.addQueryPrefix?"?":"";return i.charsetSentinel&&("iso-8859-1"===i.charset?h+="utf8=%26%2310003%3B&":h+="utf8=%E2%9C%93&"),0<l.length?h+l:""}},Dt=function(){function u(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.windowTitle,n=e.writeDelay,r=void 0===n?400:n,i=e.createURL,a=void 0===i?yt:i,s=e.parseURL,o=void 0===s?bt:s;k(this,u),L(this,"windowTitle",void 0),L(this,"writeDelay",void 0),L(this,"_createURL",void 0),L(this,"parseURL",void 0),L(this,"writeTimer",void 0),this.windowTitle=t,this.writeTimer=void 0,this.writeDelay=r,this._createURL=a,this.parseURL=o;var c=this.windowTitle&&this.windowTitle(this.read());Rt(c)}return M(u,[{key:"read",value:function(){return this.parseURL({qsModule:Ht,location:window.location})}},{key:"write",value:function(e){var t=this,n=this.createURL(e),r=this.windowTitle&&this.windowTitle(e);this.writeTimer&&window.clearTimeout(this.writeTimer),this.writeTimer=window.setTimeout(function(){Rt(r),window.history.pushState(e,r||"",n),t.writeTimer=void 0},this.writeDelay)}},{key:"onUpdate",value:function(n){var r=this;this._onPopState=function(e){r.writeTimer&&(window.clearTimeout(r.writeTimer),r.writeTimer=void 0);var t=e.state;n(t||r.read())},window.addEventListener("popstate",this._onPopState)}},{key:"createURL",value:function(e){return this._createURL({qsModule:Ht,routeState:e,location:window.location})}},{key:"dispose",value:function(){this._onPopState&&window.removeEventListener("popstate",this._onPopState),this.writeTimer&&window.clearTimeout(this.writeTimer),this.write({})}}]),u}();function Bt(e){return new Dt(e)}function Qt(e){var t=0<arguments.length&&void 0!==e?e:{},n=t.router,i=void 0===n?Bt():n,r=t.stateMapping,s=void 0===r?dt():r;return function(e){var a=e.instantSearchInstance;a._createURL=function(n){var e=Object.keys(n).reduce(function(e,t){return D({},e,L({},t,n[t]))},a.mainIndex.getWidgetState({})),t=s.stateToRoute(e);return i.createURL(t)},a._initialUiState=D({},a._initialUiState,{},s.routeToState(i.read()));var r=void 0;return{onStateChange:function(e){var t=e.uiState,n=s.stateToRoute(t);void 0!==r&&Te(r,n)||(i.write(n),r=n)},subscribe:function(){i.onUpdate(function(e){var i=s.routeToState(e);!function t(e,n){n(e),e.getWidgets().filter(function(e){return"ais.index"===e.$$type}).forEach(function(e){t(e,n)})}(a.mainIndex,function(e){var t=e.getWidgets(),n=i[e.getIndexId()]||{},r=t.reduce(function(e,t){return t.getWidgetSearchParameters?t.getWidgetSearchParameters(e,{uiState:n}):e},e.getHelper().state);e.getHelper().overrideStateWithoutTriggeringChangeEvent(r),a.scheduleSearch()})})},unsubscribe:function(){i.dispose()}}}}var qt=Ae({name:"instantsearch"});function Ut(){return"#"}function Vt(f,e){var i=1<arguments.length&&void 0!==e?e:_e;return Pe(f,$t()),function(a){var e=a||{},t=e.includedAttributes,s=void 0===t?[]:t,n=e.excludedAttributes,o=void 0===n?["query"]:n,r=e.transformItems,c=void 0===r?function(e){return e}:r;if(a.includedAttributes&&a.excludedAttributes)throw new Error($t("The options `includedAttributes` and `excludedAttributes` cannot be used together."));function u(){return h.refine()}function l(){return h.createURL()}var h={refine:_e,createURL:function(){return""}};return{$$type:"ais.clearRefinements",init:function(e){var t=e.instantSearchInstance;f({hasRefinements:!1,refine:u,createURL:l,instantSearchInstance:t,widgetParams:a},!0)},render:function(e){var t=e.scopedResults,n=e.createURL,r=e.instantSearchInstance,i=t.reduce(function(e,t){return e.concat(function(e){var t=e.scopedResult,n=e.includedAttributes,r=e.excludedAttributes,i=e.transformItems,a=-1!==n.indexOf("query")||-1===r.indexOf("query");return{helper:t.helper,items:i(le(Re(t.results,t.helper.state,a).map(function(e){return e.attribute}).filter(function(e){return 0===n.length||-1!==n.indexOf(e)}).filter(function(e){return"query"===e&&a||-1===r.indexOf(e)})))}}({scopedResult:t,includedAttributes:s,excludedAttributes:o,transformItems:c}))},[]);h.refine=function(){i.forEach(function(e){var t=e.helper,n=e.items;t.setState(we({helper:t,attributesToClear:n})).search()})},h.createURL=function(){return n(je.apply(void 0,_(i.map(function(e){return we({helper:e.helper,attributesToClear:e.items})}))))},f({hasRefinements:i.some(function(e){return 0<e.items.length}),refine:u,createURL:l,instantSearchInstance:r,widgetParams:a},!1)},dispose:function(){i()}}}}var Wt=function(){function b(e){var r;k(this,b),L(H(r=B(this,O(b).call(this))),"client",void 0),L(H(r),"indexName",void 0),L(H(r),"insightsClient",void 0),L(H(r),"onStateChange",null),L(H(r),"helper",void 0),L(H(r),"mainHelper",void 0),L(H(r),"mainIndex",void 0),L(H(r),"started",void 0),L(H(r),"templatesConfig",void 0),L(H(r),"_stalledSearchDelay",void 0),L(H(r),"_searchStalledTimer",void 0),L(H(r),"_isSearchStalled",void 0),L(H(r),"_initialUiState",void 0),L(H(r),"_createURL",void 0),L(H(r),"_searchFunction",void 0),L(H(r),"_mainHelperSearch",void 0),L(H(r),"middleware",[]),L(H(r),"sendEventToInsights",void 0),L(H(r),"scheduleSearch",se(function(){r.started&&r.mainHelper.search()})),L(H(r),"scheduleRender",se(function(){r.mainHelper.hasPendingRequests()||(clearTimeout(r._searchStalledTimer),r._searchStalledTimer=null,r._isSearchStalled=!1),r.mainIndex.render({instantSearchInstance:H(r)}),r.emit("render")})),L(H(r),"setUiState",function(e){if(!r.mainHelper)throw new Error(qt("The `start` method needs to be called before `setUiState`."));r.mainIndex.refreshUiState();var n="function"==typeof e?e(r.mainIndex.getWidgetState({})):e;!function e(t){t.getHelper().overrideStateWithoutTriggeringChangeEvent(t.getWidgetSearchParameters(t.getHelper().state,{uiState:n[t.getIndexId()]})),t.getWidgets().filter(Ke).forEach(e)}(r.mainIndex),r.scheduleSearch(),r.onInternalStateChange()}),L(H(r),"onInternalStateChange",function(){var t=r.mainIndex.getWidgetState({});r.middleware.forEach(function(e){e.onStateChange({uiState:t})})});var t=e.indexName,n=void 0===t?null:t,i=e.numberLocale,a=e.initialUiState,s=void 0===a?{}:a,o=e.routing,c=void 0===o?null:o,u=e.searchFunction,l=e.stalledSearchDelay,h=void 0===l?200:l,f=e.searchClient,d=void 0===f?null:f,m=e.insightsClient,p=void 0===m?null:m,v=e.onStateChange,g=void 0===v?null:v;if(null===n)throw new Error(qt("The `indexName` option is required."));if(null===d)throw new Error(qt("The `searchClient` option is required."));if("function"!=typeof d.search)throw new Error("The `searchClient` must implement a `search` method.\n\nSee: https://www.algolia.com/doc/guides/building-search-ui/going-further/backend-search/in-depth/backend-instantsearch/js/");if("function"==typeof d.addAlgoliaAgent&&d.addAlgoliaAgent("instantsearch.js (".concat("4.8.3",")")),p&&"function"!=typeof p)throw new Error(qt("The `insightsClient` option should be a function."));if(r.client=d,r.insightsClient=p,r.indexName=n,r.helper=null,r.mainHelper=null,r.mainIndex=Ze({indexName:n}),r.onStateChange=g,r.started=!1,r.templatesConfig={helpers:function(e){var n=e.numberLocale;return{formatNumber:function(e,t){return Number(t(e)).toLocaleString(n)},highlight:function(e,t){try{return t(ot(D({},JSON.parse(e),{hit:this})))}catch(e){throw new Error('\nThe highlight helper expects a JSON object of the format:\n{ "attribute": "name", "highlightedTagName": "mark" }')}},snippet:function(e,t){try{return t(ut(D({},JSON.parse(e),{hit:this})))}catch(e){throw new Error('\nThe snippet helper expects a JSON object of the format:\n{ "attribute": "name", "highlightedTagName": "mark" }')}},insights:function(e,t){try{var n=JSON.parse(e),r=n.method,i=n.payload;return t(lt(r,D({objectIDs:[this.objectID]},i)))}catch(e){throw new Error('\nThe insights helper expects a JSON object of the format:\n{ "method": "method-name", "payload": { "eventName": "name of the event" } }')}}}}({numberLocale:i}),compileOptions:{}},r._stalledSearchDelay=h,r._searchStalledTimer=null,r._isSearchStalled=!1,r._createURL=Ut,r._initialUiState=s,u&&(r._searchFunction=u),r.sendEventToInsights=_e,c){var y="boolean"==typeof c?void 0:c;r.use(Qt(y))}return r}return j(b,e),M(b,[{key:"use",value:function(){for(var n=this,e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var i=t.map(function(e){var t=e({instantSearchInstance:n});return n.middleware.push(t),t});return this.started&&i.forEach(function(e){e.subscribe()}),this}},{key:"EXPERIMENTAL_use",value:function(){return this.use.apply(this,arguments)}},{key:"addWidget",value:function(e){return this.addWidgets([e])}},{key:"addWidgets",value:function(e){if(!Array.isArray(e))throw new Error(qt("The `addWidgets` method expects an array of widgets. Please use `addWidget`."));if(e.some(function(e){return"function"!=typeof e.init&&"function"!=typeof e.render}))throw new Error(qt("The widget definition expects a `render` and/or an `init` method."));return this.mainIndex.addWidgets(e),this}},{key:"removeWidget",value:function(e){return this.removeWidgets([e])}},{key:"removeWidgets",value:function(e){if(!Array.isArray(e))throw new Error(qt("The `removeWidgets` method expects an array of widgets. Please use `removeWidget`."));if(e.some(function(e){return"function"!=typeof e.dispose}))throw new Error(qt("The widget definition expects a `dispose` method."));return this.mainIndex.removeWidgets(e),this}},{key:"start",value:function(){var r=this;if(this.started)throw new Error(qt("The `start` method has already been called once."));var t=ae(this.client,this.indexName);if(t.search=function(){return t.searchOnlyWithDerivedHelpers()},this._searchFunction){var i={search:function(){return new Promise(_e)}};this._mainHelperSearch=t.search.bind(t),t.search=function(){var n=r.mainIndex.getHelper(),e=ae(i,n.state.index,n.state);return e.once("search",function(e){var t=e.state;n.overrideStateWithoutTriggeringChangeEvent(t),r._mainHelperSearch()}),e.on("change",function(e){var t=e.state;n.setState(t)}),r._searchFunction(e),t}}t.on("error",function(e){var t=e.error;r.emit("error",{error:t})}),this.mainHelper=t,this.mainIndex.init({instantSearchInstance:this,parent:null,uiState:this._initialUiState}),this.middleware.forEach(function(e){e.subscribe()}),t.search(),this.helper=this.mainIndex.getHelper(),this.started=!0}},{key:"dispose",value:function(){this.scheduleSearch.cancel(),this.scheduleRender.cancel(),clearTimeout(this._searchStalledTimer),this.removeWidgets(this.mainIndex.getWidgets()),this.mainIndex.dispose(),this.started=!1,this.removeAllListeners(),this.mainHelper.removeAllListeners(),this.mainHelper=null,this.helper=null,this.middleware.forEach(function(e){e.unsubscribe()})}},{key:"scheduleStalledRender",value:function(){var e=this;this._searchStalledTimer||(this._searchStalledTimer=setTimeout(function(){e._isSearchStalled=!0,e.scheduleRender()},this._stalledSearchDelay))}},{key:"createURL",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};if(!this.started)throw new Error(qt("The `start` method needs to be called before `createURL`."));return this._createURL(t)}},{key:"refresh",value:function(){if(!this.mainHelper)throw new Error(qt("The `start` method needs to be called before `refresh`."));this.mainHelper.clearCache().search()}}]),b}(),$t=Ae({name:"clear-refinements",connector:!0});function zt(l,e){var r=1<arguments.length&&void 0!==e?e:_e;return Pe(l,Kt()),function(s){if((s||{}).includedAttributes&&(s||{}).excludedAttributes)throw new Error(Kt("The options `includedAttributes` and `excludedAttributes` cannot be used together."));var e=s||{},o=e.includedAttributes,t=e.excludedAttributes,c=void 0===t?["query"]:t,n=e.transformItems,u=void 0===n?function(e){return e}:n;return{$$type:"ais.currentRefinements",init:function(e){var t=e.helper,n=e.createURL,r=e.instantSearchInstance,i=u(Jt({results:{},helper:t,includedAttributes:o,excludedAttributes:c}));l({items:i,refine:function(e){return Gt(t,e)},createURL:function(e){return n(Yt(t.state,e))},instantSearchInstance:r,widgetParams:s},!0)},render:function(e){var t=e.scopedResults,n=e.helper,r=e.createURL,i=e.instantSearchInstance,a=t.reduce(function(e,t){return e.concat(u(Jt({results:t.results,helper:t.helper,includedAttributes:o,excludedAttributes:c})))},[]);l({items:a,refine:function(e){return Gt(n,e)},createURL:function(e){return r(Yt(n.state,e))},instantSearchInstance:i,widgetParams:s},!1)},dispose:function(){r()}}}}var Kt=Ae({name:"current-refinements",connector:!0});function Jt(e){var t=e.results,n=e.helper,r=e.includedAttributes,i=e.excludedAttributes,a=-1!==(r||[]).indexOf("query")||-1===(i||[]).indexOf("query"),s=r?function(e){return-1!==r.indexOf(e.attribute)}:function(e){return-1===i.indexOf(e.attribute)},o=Re(t,n.state,a).map(Xt).filter(s);return o.reduce(function(e,t){return[].concat(_(e.filter(function(e){return e.attribute!==t.attribute})),[{indexName:n.state.index,attribute:t.attribute,label:t.attribute,refinements:o.filter(function(e){return e.attribute===t.attribute}).sort(function(e,t){return"numeric"===e.type?e.value-t.value:0}),refine:function(e){return Gt(n,e)}}])},[])}function Yt(e,t){switch(t.type){case"facet":return e.removeFacetRefinement(t.attribute,String(t.value));case"disjunctive":return e.removeDisjunctiveFacetRefinement(t.attribute,String(t.value));case"hierarchical":return e.removeHierarchicalFacetRefinement(t.attribute);case"exclude":return e.removeExcludeRefinement(t.attribute,String(t.value));case"numeric":return e.removeNumericRefinement(t.attribute,t.operator,String(t.value));case"tag":return e.removeTagRefinement(String(t.value));case"query":return e.setQueryParameter("query","");default:return e}}function Gt(e,t){e.setState(Yt(e.state,t)).search()}function Xt(e){var t="numeric"===e.type?Number(e.name):e.name,n=e.operator?"".concat(function(e){switch(e){case">=":return"≥";case"<=":return"≤";default:return e}}(e.operator)," ").concat(e.name):e.name,r={attribute:e.attribute,type:e.type,value:t,label:n};return void 0!==e.operator&&(r.operator=e.operator),void 0!==e.count&&(r.count=e.count),void 0!==e.exhaustive&&(r.exhaustive=e.exhaustive),r}var Zt=Ae({name:"hierarchical-menu",connector:!0});function en(R){var w=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(R,Zt()),function(){var l=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},c=l.attributes,e=l.separator,u=void 0===e?" > ":e,t=l.rootPath,h=void 0===t?null:t,n=l.showParentLevel,f=void 0===n||n,r=l.limit,d=void 0===r?10:r,i=l.showMore,m=void 0!==i&&i,a=l.showMoreLimit,p=void 0===a?20:a,s=l.sortBy,v=void 0===s?["name:asc"]:s,o=l.transformItems,g=void 0===o?function(e){return e}:o;if(!c||!Array.isArray(c)||0===c.length)throw new Error(Zt("The `attributes` option expects an array of strings."));if(!0===m&&p<=d)throw new Error(Zt("The `showMoreLimit` option must be greater than `limit`."));var y,b=Q(c,1)[0];return{$$type:"ais.hierarchicalMenu",isShowingMore:!1,toggleShowMore:function(){},cachedToggleShowMore:function(){this.toggleShowMore()},createToggleShowMore:function(e){var t=this;return function(){t.isShowingMore=!t.isShowingMore,t.render(e)}},getLimit:function(){return this.isShowingMore?p:d},init:function(e){var t=e.helper,n=e.createURL,r=e.instantSearchInstance;y=qe({instantSearchInstance:r,helper:t,attribute:b,widgetType:this.$$type}),this.cachedToggleShowMore=this.cachedToggleShowMore.bind(this),this._refine=function(e){y("click",e),t.toggleRefinement(b,e).search()},R({items:[],createURL:function(e){return n(t.state.toggleRefinement(b,e))},refine:this._refine,sendEvent:y,instantSearchInstance:r,widgetParams:l,isShowingMore:!1,toggleShowMore:this.cachedToggleShowMore,canToggleShowMore:!1},!0)},_prepareFacetValues:function(e,i){var a=this;return e.slice(0,this.getLimit()).map(function(e){var t=e.name,n=e.path,r=A(e,["name","path"]);return Array.isArray(r.data)&&(r.data=a._prepareFacetValues(r.data,i)),D({},r,{label:t,value:n})})},render:function(e){var t=e.results,n=e.state,r=e.createURL,i=e.instantSearchInstance,a=t.getFacetValues(b,{sortBy:v}).data||[],s=g(this._prepareFacetValues(a),n);var o=n.maxValuesPerFacet,c=this.getLimit(),u=c<o?a.length<=c:a.length<c;this.toggleShowMore=this.createToggleShowMore(e),R({items:s,refine:this._refine,sendEvent:y,createURL:function(e){return r(n.toggleRefinement(b,e))},instantSearchInstance:i,widgetParams:l,isShowingMore:this.isShowingMore,toggleShowMore:this.cachedToggleShowMore,canToggleShowMore:m&&(this.isShowingMore||!u)},!1)},dispose:function(e){var t=e.state;return w(),t.removeHierarchicalFacet(b).setQueryParameter("maxValuesPerFacet",void 0)},getWidgetState:function(e,t){var n=t.searchParameters.getHierarchicalFacetBreadcrumb(b);return n.length?D({},e,{hierarchicalMenu:D({},e.hierarchicalMenu,L({},b,n))}):e},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=n.hierarchicalMenu&&n.hierarchicalMenu[b];if(e.isHierarchicalFacet(b))e.getHierarchicalFacetByName(b);var i=e.removeHierarchicalFacet(b).addHierarchicalFacet({name:b,attributes:c,separator:u,rootPath:h,showParentLevel:f}),a=i.maxValuesPerFacet||0,s=Math.max(a,m?p:d),o=i.setQueryParameter("maxValuesPerFacet",s);return r?o.addHierarchicalFacetRefinement(b,r.join(u)):o.setQueryParameters({hierarchicalFacetsRefinements:D({},o.hierarchicalFacetsRefinements,L({},b,[]))})}}}}function tn(u,e){var r=1<arguments.length&&void 0!==e?e:_e;return Pe(u,rn()),function(i){var a,s,e=i||{},t=e.escapeHTML,o=void 0===t||t,n=e.transformItems,c=void 0===n?function(e){return e}:n;return{$$type:"ais.hits",init:function(e){var t=e.instantSearchInstance,n=e.helper;a=Ve({instantSearchInstance:t,index:n.getIndex(),widgetType:this.$$type}),s=We({index:n.getIndex(),widgetType:this.$$type}),u({hits:[],results:void 0,sendEvent:a,bindEvent:s,instantSearchInstance:t,widgetParams:i},!0)},render:function(e){var t=e.results,n=e.instantSearchInstance;o&&0<t.hits.length&&(t.hits=it(t.hits));var r=t.hits.__escaped;t.hits=Be(t.hits,t.page,t.hitsPerPage),t.hits=Qe(t.hits,t.queryID),t.hits=c(t.hits),t.hits.__escaped=r,a("view",t.hits),u({hits:t.hits,results:t,sendEvent:a,bindEvent:s,instantSearchInstance:n,widgetParams:i},!1)},dispose:function(e){var t=e.state;return r(),o?t.setQueryParameters(Object.keys(et).reduce(function(e,t){return D({},e,L({},t,void 0))},{})):t},getWidgetSearchParameters:function(e){return o?e.setQueryParameters(et):e}}}}function nn(e){var t=e.method,n=e.results,r=e.hits,i=e.objectIDs,a=n.index,s=function(n,e){return e.map(function(t){var e=ge(n,function(e){return e.objectID===t});if(void 0===e)throw new Error('Could not find objectID "'.concat(t,'" passed to `clickedObjectIDsAfterSearch` in the returned hits. This is necessary to infer the absolute position and the query ID.'));return e})}(r,i),o=function(e){var t=le(e.map(function(e){return e.__queryID}));if(1<t.length)throw new Error("Insights currently allows a single `queryID`. The `objectIDs` provided map to multiple `queryID`s.");var n=t[0];if("string"!=typeof n)throw new Error("Could not infer `queryID`. Ensure InstantSearch `clickAnalytics: true` was added with the Configure widget.\n\nSee: https://alg.li/lNiZZ7");return n}(s);switch(t){case"clickedObjectIDsAfterSearch":return{index:a,queryID:o,objectIDs:i,positions:function(e){return e.map(function(e){return e.__position})}(s)};case"convertedObjectIDsAfterSearch":return{index:a,queryID:o,objectIDs:i};default:throw new Error('Unsupported method passed to insights: "'.concat(t,'".'))}}var rn=Ae({name:"hits",connector:!0});function an(n){function r(s){return function(e,t){var n=e.results,r=e.hits,i=e.instantSearchInstance;if(n&&r&&i){var a=function(i,a,s){return function(e,t){if(!i){var n=Ae({name:"instantsearch"});throw new Error(n("The `insightsClient` option has not been provided to `instantsearch`."))}if(!Array.isArray(t.objectIDs))throw new TypeError("Expected `objectIDs` to be an array.");var r=nn({method:e,results:a,hits:s,objectIDs:t.objectIDs});i(e,D({},r,{},t))}}(i.insightsClient,n,r);return s(D({},e,{insights:a}),t)}return s(e,t)}}return function(e,t){return n(r(e),t)}}var sn,on,cn,un,ln,hn={},fn=[],dn=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;function mn(e,t){for(var n in t)e[n]=t[n];return e}function pn(e){var t=e.parentNode;t&&t.removeChild(e)}function vn(e,t,n){var r,i,a,s,o=arguments;if(t=mn({},t),3<arguments.length)for(n=[n],r=3;r<arguments.length;r++)n.push(o[r]);if(null!=n&&(t.children=n),null!=e&&null!=e.defaultProps)for(i in e.defaultProps)void 0===t[i]&&(t[i]=e.defaultProps[i]);return s=t.key,null!=(a=t.ref)&&delete t.ref,null!=s&&delete t.key,gn(e,t,s,a)}function gn(e,t,n,r){var i={type:e,props:t,key:n,ref:r,__k:null,__p:null,__b:0,__e:null,l:null,__c:null,constructor:void 0};return sn.vnode&&sn.vnode(i),i}function yn(e){return e.children}function bn(e,t){this.props=e,this.context=t}function Rn(e,t){if(null==t)return e.__p?Rn(e.__p,e.__p.__k.indexOf(e)+1):null;for(var n;t<e.__k.length;t++)if(null!=(n=e.__k[t])&&null!=n.__e)return n.__e;return"function"==typeof e.type?Rn(e):null}function wn(e){var t,n;if(null!=(e=e.__p)&&null!=e.__c){for(e.__e=e.__c.base=null,t=0;t<e.__k.length;t++)if(null!=(n=e.__k[t])&&null!=n.__e){e.__e=e.__c.base=n.__e;break}return wn(e)}}function Sn(e){(!e.__d&&(e.__d=!0)&&1===on.push(e)||un!==sn.debounceRendering)&&(un=sn.debounceRendering,(sn.debounceRendering||cn)(Pn))}function Pn(){var e,t,n,r,i,a,s,o;for(on.sort(function(e,t){return t.__v.__b-e.__v.__b});e=on.pop();)e.__d&&(r=n=void 0,a=(i=(t=e).__v).__e,s=t.__P,o=t.u,t.u=!1,s&&(n=[],r=Cn(s,i,mn({},i),t.__n,void 0!==s.ownerSVGElement,null,n,o,null==a?Rn(i):a),Tn(n,i),r!=a&&wn(i)))}function _n(t,n,e,r,i,a,s,o,c){var u,l,h,f,d,m,p,v=e&&e.__k||fn,g=v.length;if(o==hn&&(o=null!=a?a[0]:g?Rn(e,0):null),u=0,n.__k=Nn(n.__k,function(e){if(null!=e){if(e.__p=n,e.__b=n.__b+1,null===(h=v[u])||h&&e.key==h.key&&e.type===h.type)v[u]=void 0;else for(l=0;l<g;l++){if((h=v[l])&&e.key==h.key&&e.type===h.type){v[l]=void 0;break}h=null}if(f=Cn(t,e,h=h||hn,r,i,a,s,null,o,c),(l=e.ref)&&h.ref!=l&&(p=p||[]).push(l,e.__c||f,e),null!=f){if(null==m&&(m=f),null!=e.l)f=e.l,e.l=null;else if(a==h||f!=o||null==f.parentNode){e:if(null==o||o.parentNode!==t)t.appendChild(f);else{for(d=o,l=0;(d=d.nextSibling)&&l<g;l+=2)if(d==f)break e;t.insertBefore(f,o)}"option"==n.type&&(t.value="")}o=f.nextSibling,"function"==typeof n.type&&(n.l=f)}}return u++,e}),n.__e=m,null!=a&&"function"!=typeof n.type)for(u=a.length;u--;)null!=a[u]&&pn(a[u]);for(u=g;u--;)null!=v[u]&&kn(v[u],v[u]);if(p)for(u=0;u<p.length;u++)En(p[u],p[++u],p[++u])}function Nn(e,t,n){if(null==n&&(n=[]),null==e||"boolean"==typeof e)t&&n.push(t(null));else if(Array.isArray(e))for(var r=0;r<e.length;r++)Nn(e[r],t,n);else n.push(t?t(function(e){if(null==e||"boolean"==typeof e)return null;if("string"==typeof e||"number"==typeof e)return gn(null,e,null,null);if(null==e.__e&&null==e.__c)return e;var t=gn(e.type,e.props,e.key,null);return t.__e=e.__e,t}(e)):e);return n}function xn(e,t,n){"-"===t[0]?e.setProperty(t,n):e[t]="number"==typeof n&&!1===dn.test(t)?n+"px":null==n?"":n}function Fn(e,t,n,r,i){var a,s,o,c,u;if("key"===(t=i?"className"===t?"class":t:"class"===t?"className":t)||"children"===t);else if("style"===t)if(a=e.style,"string"==typeof n)a.cssText=n;else{if("string"==typeof r&&(a.cssText="",r=null),r)for(s in r)n&&s in n||xn(a,s,"");if(n)for(o in n)r&&n[o]===r[o]||xn(a,o,n[o])}else"o"===t[0]&&"n"===t[1]?(c=t!==(t=t.replace(/Capture$/,"")),t=((u=t.toLowerCase())in e?u:t).slice(2),n?(r||e.addEventListener(t,In,c),(e.t||(e.t={}))[t]=n):e.removeEventListener(t,In,c)):"list"!==t&&"tagName"!==t&&"form"!==t&&!i&&t in e?e[t]=null==n?"":n:"function"!=typeof n&&"dangerouslySetInnerHTML"!==t&&(t!==(t=t.replace(/^xlink:?/,""))?null==n||!1===n?e.removeAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase()):e.setAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase(),n):null==n||!1===n?e.removeAttribute(t):e.setAttribute(t,n))}function In(e){return this.t[e.type](sn.event?sn.event(e):e)}function Cn(e,t,n,r,i,a,s,o,c,u){var l,h,f,d,m,p,v,g,y,b,R=t.type;if(void 0!==t.constructor)return null;(l=sn.__b)&&l(t);try{e:if("function"==typeof R){if(g=t.props,y=(l=R.contextType)&&r[l.__c],b=l?y?y.props.value:l.__p:r,n.__c?v=(h=t.__c=n.__c).__p=h.__E:("prototype"in R&&R.prototype.render?t.__c=h=new R(g,b):(t.__c=h=new bn(g,b),h.constructor=R,h.render=Mn),y&&y.sub(h),h.props=g,h.state||(h.state={}),h.context=b,h.__n=r,f=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=R.getDerivedStateFromProps&&mn(h.__s==h.state?h.__s=mn({},h.__s):h.__s,R.getDerivedStateFromProps(g,h.__s)),f)null==R.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&s.push(h);else{if(null==R.getDerivedStateFromProps&&null==o&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,b),!o&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,b)){for(h.props=g,h.state=h.__s,h.__d=!1,(h.__v=t).__e=null!=c?c!==n.__e?c:n.__e:null,t.__k=n.__k,l=0;l<t.__k.length;l++)t.__k[l]&&(t.__k[l].__p=t);break e}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,b)}for(d=h.props,m=h.state,h.context=b,h.props=g,h.state=h.__s,(l=sn.__r)&&l(t),h.__d=!1,h.__v=t,h.__P=e,l=h.render(h.props,h.state,h.context),t.__k=Nn(null!=l&&l.type==yn&&null==l.key?l.props.children:l),null!=h.getChildContext&&(r=mn(mn({},r),h.getChildContext())),f||null==h.getSnapshotBeforeUpdate||(p=h.getSnapshotBeforeUpdate(d,m)),_n(e,t,n,r,i,a,s,c,u),h.base=t.__e;l=h.__h.pop();)h.__s&&(h.state=h.__s),l.call(h);f||null==d||null==h.componentDidUpdate||h.componentDidUpdate(d,m,p),v&&(h.__E=h.__p=null)}else t.__e=function(e,t,n,r,i,a,s,o){var c,u,l,h,f=n.props,d=t.props;if(i="svg"===t.type||i,null==e&&null!=a)for(c=0;c<a.length;c++)if(null!=(u=a[c])&&(null===t.type?3===u.nodeType:u.localName===t.type)){e=u,a[c]=null;break}if(null==e){if(null===t.type)return document.createTextNode(d);e=i?document.createElementNS("http://www.w3.org/2000/svg",t.type):document.createElement(t.type),a=null}return null===t.type?f!==d&&(null!=a&&(a[a.indexOf(e)]=null),e.data=d):t!==n&&(null!=a&&(a=fn.slice.call(e.childNodes)),l=(f=n.props||hn).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,o||(h||l)&&(h&&l&&h.__html==l.__html||(e.innerHTML=h&&h.__html||"")),function(e,t,n,r,i){var a;for(a in n)a in t||Fn(e,a,null,n[a],r);for(a in t)i&&"function"!=typeof t[a]||"value"===a||"checked"===a||n[a]===t[a]||Fn(e,a,t[a],n[a],r)}(e,d,f,i,o),t.__k=t.props.children,h||_n(e,t,n,r,"foreignObject"!==t.type&&i,a,s,hn,o),o||("value"in d&&void 0!==d.value&&d.value!==e.value&&(e.value=null==d.value?"":d.value),"checked"in d&&void 0!==d.checked&&d.checked!==e.checked&&(e.checked=d.checked))),e}(n.__e,t,n,r,i,a,s,u);(l=sn.diffed)&&l(t)}catch(e){sn.__e(e,t,n)}return t.__e}function Tn(e,t){for(var n;n=e.pop();)try{n.componentDidMount()}catch(e){sn.__e(e,n.__v)}sn.__c&&sn.__c(t)}function En(e,t,n){try{"function"==typeof e?e(t):e.current=t}catch(e){sn.__e(e,n)}}function kn(e,t,n){var r,i,a;if(sn.unmount&&sn.unmount(e),(r=e.ref)&&En(r,null,t),n||"function"==typeof e.type||(n=null!=(i=e.__e)),e.__e=e.l=null,null!=(r=e.__c)){if(r.componentWillUnmount)try{r.componentWillUnmount()}catch(e){sn.__e(e,t)}r.base=r.__P=null}if(r=e.__k)for(a=0;a<r.length;a++)r[a]&&kn(r[a],t,n);null!=i&&pn(i)}function Mn(e,t,n){return this.constructor(e,n)}function Ln(e,t,n){var r,i,a;sn.__p&&sn.__p(e,t),i=(r=n===ln)?null:n&&n.__k||t.__k,e=vn(yn,null,[e]),a=[],Cn(t,r?t.__k=e:(n||t).__k=e,i||hn,hn,void 0!==t.ownerSVGElement,n&&!r?[n]:i?null:fn.slice.call(t.childNodes),a,!1,n||hn,r),Tn(a,e)}sn={},bn.prototype.setState=function(e,t){var n=this.__s!==this.state&&this.__s||(this.__s=mn({},this.state));"function"==typeof e&&!(e=e(n,this.props))||mn(n,e),null!=e&&this.__v&&(this.u=!1,t&&this.__h.push(t),Sn(this))},bn.prototype.forceUpdate=function(e){this.__v&&(e&&this.__h.push(e),this.u=!0,Sn(this))},bn.prototype.render=yn,on=[],cn="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,un=sn.debounceRendering,sn.__e=function(e,t,n){for(var r;t=t.__p;)if((r=t.__c)&&!r.__p)try{if(r.constructor&&null!=r.constructor.getDerivedStateFromError)r.setState(r.constructor.getDerivedStateFromError(e));else{if(null==r.componentDidCatch)continue;r.componentDidCatch(e)}return Sn(r.__E=r)}catch(t){e=t}throw e},ln=hn;function jn(e,t,n){for(var r=e;r&&!n(r);){if(r===t)return null;r=r.parentElement}return r}function On(e){return function(o){return vn("div",{onClick:function(e){if(o.sendEvent){var t=jn(e.target,e.currentTarget,function(e){return e.hasAttribute("data-insights-event")});if(t){var n=function(e){var t=e.getAttribute("data-insights-event");if("string"!=typeof t)throw new Error("The insights middleware expects `data-insights-event` to be a base64-encoded JSON string.");try{return JSON.parse(atob(t))}catch(e){throw new Error("The insights middleware was unable to parse `data-insights-event`.")}}(t);o.sendEvent(n)}}var r=jn(e.target,e.currentTarget,function(e){return function(e){return e.hasAttribute("data-insights-method")}(e)});if(r){var i=function(e){var t=e.getAttribute("data-insights-method"),n=e.getAttribute("data-insights-payload");if("string"!=typeof n)throw new Error("The insights helper expects `data-insights-payload` to be a base64-encoded JSON string.");try{return{method:t,payload:JSON.parse(atob(n))}}catch(e){throw new Error("The insights helper was unable to parse `data-insights-payload`.")}}(r),a=i.method,s=i.payload;o.insights(a,s)}}},vn(e,o))}}function An(h,e){var a=1<arguments.length&&void 0!==e?e:_e;return Pe(h,Dn()),function(s){var e=s||{},t=e.items,n=e.transformItems,o=void 0===n?function(e){return e}:n,c=t;if(!Array.isArray(c))throw new Error(Dn("The `items` option expects an array of objects."));var r=c.filter(function(e){return!0===e.default});if(0===r.length)throw new Error(Dn("A default value must be specified in `items`."));if(1<r.length)throw new Error(Dn("More than one default value is specified in `items`."));function u(e){var t=e.hitsPerPage;return c.map(function(e){return D({},e,{isRefined:Number(e.value)===Number(t)})})}var i=r[0],l={};return{$$type:"ais.hitsPerPage",init:function(e){var t=e.helper,n=e.createURL,r=e.state,i=e.instantSearchInstance,a=c.some(function(e){return Number(r.hitsPerPage)===Number(e.value)});l.setHitsPerPage=function(e){return e||0===e?t.setQueryParameter("hitsPerPage",e).search():t.setQueryParameter("hitsPerPage",void 0).search()},a||(c=[{value:"",label:""}].concat(_(c))),l.createURLFactory=function(t){return function(e){return n(t.setQueryParameter("hitsPerPage",e||0===e?e:void 0))}},h({items:o(u(r)),refine:l.setHitsPerPage,createURL:l.createURLFactory(t.state),hasNoResults:!0,widgetParams:s,instantSearchInstance:i},!0)},render:function(e){var t=e.state,n=e.results,r=e.instantSearchInstance,i=0===n.nbHits;h({items:o(u(t)),refine:l.setHitsPerPage,createURL:l.createURLFactory(t),hasNoResults:i,widgetParams:s,instantSearchInstance:r},!1)},dispose:function(e){var t=e.state;return a(),t.setQueryParameter("hitsPerPage",void 0)},getWidgetState:function(e,t){var n=t.searchParameters.hitsPerPage;return void 0===n||n===i.value?e:D({},e,{hitsPerPage:n})},getWidgetSearchParameters:function(e,t){var n=t.uiState;return e.setQueryParameters({hitsPerPage:n.hitsPerPage||i.value})}}}}var Hn=an(tn),Dn=Ae({name:"hits-per-page",connector:!0}),Bn=Ae({name:"infinite-hits",connector:!0});function Qn(e){var t=e||{};t.page;return A(t,["page"])}function qn(n){return Object.keys(n).map(Number).sort(function(e,t){return e-t}).reduce(function(e,t){return e.concat(n[t])},[])}function Un(P,e){var i=1<arguments.length&&void 0!==e?e:_e;return Pe(P,Bn()),function(l){function h(){return Math.min.apply(Math,_(Object.keys(S||{}).map(Number)))}function f(){return Math.max.apply(Math,_(Object.keys(S||{}).map(Number)))}function d(e){var n=0<arguments.length&&void 0!==e?e:{};return Object.keys(n).filter(function(e){return Array.isArray(n[e])?n[e].length:Object.keys(n[e]).length}).reduce(function(e,t){return e[t]=n[t],e},{})}var m,p,v,g,y,e=l||{},t=e.escapeHTML,b=void 0===t||t,n=e.transformItems,R=void 0===n?function(e){return e}:n,r=e.cache,w=void 0===r?function(){var r=null,i=void 0;return{read:function(e){var t=e.state;return Te(i,Qn(t))?r:null},write:function(e){var t=e.state,n=e.hits;i=Qn(t),r=n}}}():r,S=void 0;return{$$type:"ais.infiniteHits",init:function(e){var t=e.instantSearchInstance,n=e.helper;p=function(e){return function(){e.overrideStateWithoutTriggeringChangeEvent(D({},e.state,{page:h()-1})).searchWithoutTriggeringOnStateChange()}}(n),v=function(e){return function(){e.setPage(f()+1).search()}}(n),g=Ve({instantSearchInstance:t,index:n.getIndex(),widgetType:this.$$type}),y=We({index:n.getIndex(),widgetType:this.$$type}),P({hits:qn(w.read({state:n.state})||{}),results:void 0,sendEvent:g,bindEvent:y,showPrevious:p,showMore:v,isFirstPage:0===h()||void 0===n.state.page,isLastPage:!0,instantSearchInstance:t,widgetParams:l},!0)},render:function(e){var t=e.results,n=e.state,r=e.instantSearchInstance,i=n.page,a=void 0===i?0:i,s=(n.facets,n.hierarchicalFacets,n.disjunctiveFacets,n.maxValuesPerFacet,A(n,["page","facets","hierarchicalFacets","disjunctiveFacets","maxValuesPerFacet"]));s.facetsRefinements=d(s.facetsRefinements),s.hierarchicalFacetsRefinements=d(s.hierarchicalFacetsRefinements),s.disjunctiveFacetsRefinements=d(s.disjunctiveFacetsRefinements),s.numericRefinements=d(s.numericRefinements),Te(s,m)||(S=w.read({state:n})||{},m=s),b&&0<t.hits.length&&(t.hits=it(t.hits));var o=t.hits.__escaped;t.hits=Be(t.hits,t.page,t.hitsPerPage),t.hits=Qe(t.hits,t.queryID),t.hits=R(t.hits),t.hits.__escaped=o,void 0===S&&(S=w.read({state:n})||{}),void 0===S[a]&&(S[a]=t.hits,w.write({state:n,hits:S}));var c=0===h(),u=t.nbPages<=f()+1;g("view",S[a]),P({hits:qn(S),results:t,sendEvent:g,bindEvent:y,showPrevious:p,showMore:v,isFirstPage:c,isLastPage:u,instantSearchInstance:r,widgetParams:l},!1)},dispose:function(e){var t=e.state;i();var n=t.setQueryParameter("page",void 0);return b?n.setQueryParameters(Object.keys(et).reduce(function(e,t){return D({},e,L({},t,void 0))},{})):n},getWidgetState:function(e,t){var n=t.searchParameters.page||0;return n?D({},e,{page:n+1}):e},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=e;b&&(r=e.setQueryParameters(et));var i=n.page?n.page-1:0;return r.setQueryParameter("page",i)}}}}var Vn=an(Un),Wn=Ae({name:"menu",connector:!0});function $n(m){var a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(m,Wn()),function(){var s,o=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},c=o.attribute,e=o.limit,u=void 0===e?10:e,t=o.showMore,l=void 0!==t&&t,n=o.showMoreLimit,h=void 0===n?20:n,r=o.sortBy,f=void 0===r?["isRefined","name:asc"]:r,i=o.transformItems,d=void 0===i?function(e){return e}:i;if(!c)throw new Error(Wn("The `attribute` option is required."));if(!0===l&&h<=u)throw new Error(Wn("The `showMoreLimit` option must be greater than `limit`."));return{$$type:"ais.menu",isShowingMore:!1,toggleShowMore:function(){},cachedToggleShowMore:function(){this.toggleShowMore()},createToggleShowMore:function(e){var t=this,n=e.results,r=e.instantSearchInstance;return function(){t.isShowingMore=!t.isShowingMore,t.render({results:n,instantSearchInstance:r})}},getLimit:function(){return this.isShowingMore?h:u},refine:function(n){return function(e){var t=Q(n.getHierarchicalFacetBreadcrumb(c),1)[0];s("click",e||t),n.toggleRefinement(c,e||t).search()}},init:function(e){var t=e.helper,n=e.createURL,r=e.instantSearchInstance;s=qe({instantSearchInstance:r,helper:t,attribute:c,widgetType:this.$$type}),this.cachedToggleShowMore=this.cachedToggleShowMore.bind(this),this._createURL=function(e){return n(t.state.toggleRefinement(c,e))},this._refine=this.refine(t),m({items:[],createURL:this._createURL,refine:this._refine,sendEvent:s,instantSearchInstance:r,canRefine:!1,widgetParams:o,isShowingMore:this.isShowingMore,toggleShowMore:this.cachedToggleShowMore,canToggleShowMore:!1},!0)},render:function(e){var t=e.results,n=e.instantSearchInstance,r=t.getFacetValues(c,{sortBy:f}),i=r&&r.data?r.data:[],a=d(i.slice(0,this.getLimit()).map(function(e){var t=e.name,n=e.path;return D({},A(e,["name","path"]),{label:t,value:n})}));this.toggleShowMore=this.createToggleShowMore({results:t,instantSearchInstance:n}),m({items:a,createURL:this._createURL,refine:this._refine,sendEvent:s,instantSearchInstance:n,canRefine:0<a.length,widgetParams:o,isShowingMore:this.isShowingMore,toggleShowMore:this.cachedToggleShowMore,canToggleShowMore:l&&(this.isShowingMore||i.length>this.getLimit())},!1)},dispose:function(e){var t=e.state;return a(),t.removeHierarchicalFacet(c).setQueryParameter("maxValuesPerFacet",void 0)},getWidgetState:function(e,t){var n=Q(t.searchParameters.getHierarchicalFacetBreadcrumb(c),1)[0];return n?D({},e,{menu:D({},e.menu,L({},c,n))}):e},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=n.menu&&n.menu[c],i=e.removeHierarchicalFacet(c).addHierarchicalFacet({name:c,attributes:[c]}),a=i.maxValuesPerFacet||0,s=Math.max(a,l?h:u),o=i.setQueryParameter("maxValuesPerFacet",s);return r?o.addHierarchicalFacetRefinement(c,r):o.setQueryParameters({hierarchicalFacetsRefinements:D({},o.hierarchicalFacetsRefinements,L({},c,[]))})}}}}function zn(l,e){var h=1<arguments.length&&void 0!==e?e:_e;return Pe(l,Kn()),function(i){var e=i||{},t=e.attribute,u=void 0===t?"":t,n=e.items,r=void 0===n?[]:n,a=e.transformItems,s=void 0===a?function(e){return e}:a;if(""===u)throw new Error(Kn("The `attribute` option is required."));if(!r||0===r.length)throw new Error(Kn("The `items` option expects an array of objects."));function o(i){return r.map(function(e){var t=e.start,n=e.end,r=e.label;return{label:r,value:window.encodeURI(JSON.stringify({start:t,end:n})),isRefined:Yn(i,u,{start:t,end:n,label:r})}})}var c={};return{$$type:Jn,init:function(e){var n=e.helper,r=e.createURL,t=e.instantSearchInstance;c.sendEvent=function(e){var c=e.instantSearchInstance,u=e.helper,l=e.attribute;return function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(1!==t.length){var r=t[0],i=t[1],a=t[2],s=void 0===a?"Filter Applied":a;if("click"===r){var o=$e(Gn(u.state,l,i),l);o&&0<o.length&&c.sendEventToInsights({insightsMethod:"clickedFilters",widgetType:Jn,eventType:r,payload:{eventName:s,index:u.getIndex(),filters:o}})}}else c.sendEventToInsights(t[0])}}({instantSearchInstance:t,helper:n,attribute:u}),c.refine=function(e){var t=Gn(n.state,u,e);c.sendEvent("click",e),n.setState(t).search()},c.createURL=function(t){return function(e){return r(Gn(t,u,e))}},l({createURL:c.createURL(n.state),items:s(o(n.state)),hasNoResults:!0,refine:c.refine,sendEvent:c.sendEvent,instantSearchInstance:t,widgetParams:i},!0)},render:function(e){var t=e.results,n=e.state,r=e.instantSearchInstance;l({createURL:c.createURL(n),items:s(o(n)),hasNoResults:0===t.nbHits,refine:c.refine,sendEvent:c.sendEvent,instantSearchInstance:r,widgetParams:i},!1)},dispose:function(e){var t=e.state;return h(),t.clearRefinements(u)},getWidgetState:function(e,t){var n=t.searchParameters.getNumericRefinements(u),r=n["="]&&n["="][0];if(r||0===r)return D({},e,{numericMenu:D({},e.numericMenu,L({},u,"".concat(n["="])))});var i=n[">="]&&n[">="][0]||"",a=n["<="]&&n["<="][0]||"";return""===i&&""===a?e:D({},e,{numericMenu:D({},e.numericMenu,L({},u,"".concat(i,":").concat(a)))})},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=n.numericMenu&&n.numericMenu[u],i=e.clearRefinements(u);if(!r)return i.setQueryParameters({numericRefinements:D({},i.numericRefinements,L({},u,{}))});if(-1===r.indexOf(":"))return i.addNumericRefinement(u,"=",Number(r));var a=Q(r.split(":").map(parseFloat),2),s=a[0],o=a[1],c=xe(s)?i.addNumericRefinement(u,">=",s):i;return xe(o)?c.addNumericRefinement(u,"<=",o):c}}}}var Kn=Ae({name:"numeric-menu",connector:!0}),Jn="ais.numericMenu";function Yn(e,t,n){var r=e.getNumericRefinements(t);return void 0!==n.start&&void 0!==n.end&&n.start===n.end?Xn(r,"=",n.start):void 0!==n.start?Xn(r,">=",n.start):void 0!==n.end?Xn(r,"<=",n.end):void 0===n.start&&void 0===n.end&&Object.keys(r).every(function(e){return 0===(r[e]||[]).length})}function Gn(e,t,n){var r=e,i=JSON.parse(window.decodeURI(n)),a=r.getNumericRefinements(t);if(void 0===i.start&&void 0===i.end)return r.removeNumericRefinement(t);if(Yn(r,t,i)||(r=r.removeNumericRefinement(t)),void 0!==i.start&&void 0!==i.end){if(i.start>i.end)throw new Error("option.start should be > to option.end");if(i.start===i.end)return r=Xn(a,"=",i.start)?r.removeNumericRefinement(t,"=",i.start):r.addNumericRefinement(t,"=",i.start)}return void 0!==i.start&&(r=Xn(a,">=",i.start)?r.removeNumericRefinement(t,">=",i.start):r.addNumericRefinement(t,">=",i.start)),void 0!==i.end&&(r=Xn(a,"<=",i.end)?r.removeNumericRefinement(t,"<=",i.end):r.addNumericRefinement(t,"<=",i.end)),"number"==typeof r.page&&(r.page=0),r}function Xn(e,t,n){return void 0!==e[t]&&e[t].includes(n)}var Zn=function(){function t(e){k(this,t),this.currentPage=e.currentPage,this.total=e.total,this.padding=e.padding}return M(t,[{key:"pages",value:function(){var e=this.total,t=this.currentPage,n=this.padding;if(0===e)return[0];var r=this.nbPagesDisplayed(n,e);if(r===e)return Ie({end:e});var i=this.calculatePaddingLeft(t,n,e,r);return Ie({start:t-i,end:t+(r-i)})}},{key:"nbPagesDisplayed",value:function(e,t){return Math.min(2*e+1,t)}},{key:"calculatePaddingLeft",value:function(e,t,n,r){return e<=t?e:n-t<=e?r-(n-e):t}},{key:"isLastPage",value:function(){return this.currentPage===this.total-1||0===this.total}},{key:"isFirstPage",value:function(){return 0===this.currentPage}}]),t}(),er=Ae({name:"pagination",connector:!0});function tr(c){var r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(c,er()),function(){var s=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},n=s.totalPages,e=s.padding,o=new Zn({currentPage:0,total:0,padding:void 0===e?3:e});return{$$type:"ais.pagination",init:function(e){var t=e.helper,n=e.createURL,r=e.instantSearchInstance;this.refine=function(e){t.setPage(e),t.search()},this.createURL=function(t){return function(e){return n(t.setPage(e))}},c({createURL:this.createURL(t.state),currentRefinement:t.state.page||0,nbHits:0,nbPages:0,pages:[],isFirstPage:!0,isLastPage:!0,refine:this.refine,widgetParams:s,instantSearchInstance:r},!0)},getMaxPage:function(e){var t=e.nbPages;return void 0!==n?Math.min(n,t):t},render:function(e){var t=e.results,n=e.state,r=e.instantSearchInstance,i=n.page||0,a=this.getMaxPage(t);o.currentPage=i,o.total=a,c({createURL:this.createURL(n),currentRefinement:i,refine:this.refine,nbHits:t.nbHits,nbPages:a,pages:o.pages(),isFirstPage:o.isFirstPage(),isLastPage:o.isLastPage(),widgetParams:s,instantSearchInstance:r},!1)},dispose:function(e){var t=e.state;return r(),t.setQueryParameter("page",void 0)},getWidgetState:function(e,t){var n=t.searchParameters.page||0;return n?D({},e,{page:n+1}):e},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=n.page?n.page-1:0;return e.setQueryParameter("page",r)}}}}var nr=Ae({name:"range-input",connector:!0},{name:"range-slider",connector:!0}),rr="ais.range";function ir(f){var r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(f,nr()),function(){var c=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},S=c.attribute,P=c.min,_=c.max,e=c.precision,u=void 0===e?0:e,N=xe(P),x=xe(_);if(!S)throw new Error(nr("The `attribute` option is required."));if(N&&x&&_<P)throw new Error(nr("The `max` option can't be lower than `min`."));function F(e){return Number(Number(e).toFixed(u))}function d(e,t,n,r){var i,a,s=e.state,o=t.min,c=t.max,u=Q(s.getNumericRefinement(S,">=")||[],1)[0],l=Q(s.getNumericRefinement(S,"<=")||[],1)[0],h=void 0===n||""===n,f=void 0===r||""===r,d=h?void 0:parseFloat(n),m=f?void 0:parseFloat(r);a=x||c!==m?x&&f?_:m:void 0;var p=void 0===(i=N||o!==d?N&&h?P:d:void 0),v=xe(i),g=xe(o),y=p||v&&(!g||g&&o<=i),b=void 0===a,R=xe(a),w=xe(c);return(u!==i||l!==a)&&y&&(b||R&&(!w||w&&a<=c))?(s=s.removeNumericRefinement(S),v&&(s=s.addNumericRefinement(S,">=",F(i))),R&&(s=s.addNumericRefinement(S,"<=",F(a))),s):null}function m(e,t,n,r){var i=3<arguments.length&&void 0!==r?r:"Filter Applied",a=$e(e,S);a&&0<a.length&&t.sendEventToInsights({insightsMethod:"clickedFilters",widgetType:rr,eventType:"click",payload:{eventName:i,index:n.getIndex(),filters:a}})}function l(l,h,f){return function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(1!==t.length){var r=t[0],i=t[1],a=t[2];if("click"===r){var s=Q(i,2),o=s[0],c=s[1],u=d(h,f,o,c);m(u,l,h,a)}}else l.sendEventToInsights(t[0])}}var h={from:function(e){return e},to:function(e){return F(e).toLocaleString()}};return{$$type:rr,_getCurrentRange:function(e){var t,n,r=Math.pow(10,u);return t=N?P:xe(e.min)?e.min:0,n=x?_:xe(e.max)?e.max:0,{min:Math.floor(t*r)/r,max:Math.ceil(n*r)/r}},_getCurrentRefinement:function(e){var t=Q(e.getNumericRefinement(S,">=")||[],1)[0],n=Q(e.getNumericRefinement(S,"<=")||[],1)[0];return[xe(t)?t:-1/0,xe(n)?n:1/0]},_refine:function(i,a,s){return function(){var e=Q(0<arguments.length&&void 0!==arguments[0]?arguments[0]:[],2),t=e[0],n=e[1],r=d(a,s,t,n);r&&(m(r,i,a),a.setState(r).search())}},init:function(e){var t=e.helper,n=e.instantSearchInstance,r=this._getCurrentRange({}),i=this._getCurrentRefinement(t);f({refine:this._refine(n,t,{}),sendEvent:l(n,t,{}),format:h,range:r,widgetParams:D({},c,{precision:u}),start:i,instantSearchInstance:n},!0)},render:function(e){var t=e.results,n=e.helper,r=e.instantSearchInstance,i=ge(t.disjunctiveFacets||[],function(e){return e.name===S}),a=i&&i.stats||{},s=this._getCurrentRange(a),o=this._getCurrentRefinement(n);f({refine:this._refine(r,n,s),sendEvent:l(r,n,s),format:h,range:s,widgetParams:D({},c,{precision:u}),start:o,instantSearchInstance:r},!1)},dispose:function(e){var t=e.state;r();var n=t.removeDisjunctiveFacet(S);return n.numericRefinements=D({},t.numericRefinements,L({},S,void 0)),n},getWidgetState:function(e,t){var n=t.searchParameters.getNumericRefinements(S),r=n[">="],i=void 0===r?[]:r,a=n["<="],s=void 0===a?[]:a;return 0===i.length&&0===s.length?e:D({},e,{range:D({},e.range,L({},S,"".concat(i,":").concat(s)))})},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=e.addDisjunctiveFacet(S).setQueryParameters({numericRefinements:D({},e.numericRefinements,L({},S,{}))});N&&(r=r.addNumericRefinement(S,">=",P)),x&&(r=r.addNumericRefinement(S,"<=",_));var i=n.range&&n.range[S];if(!i||-1===i.indexOf(":"))return r;var a=Q(i.split(":").map(parseFloat),2),s=a[0],o=a[1];return xe(s)&&(r=r.addNumericRefinement(S,">=",s)),xe(o)&&(r=r.addNumericRefinement(S,"<=",o)),r}}}}var ar=Ae({name:"refinement-list",connector:!0});function sr(x){var c=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(x,ar()),function(){var d=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},m=d.attribute,e=d.operator,h=void 0===e?"or":e,t=d.limit,p=void 0===t?10:t,n=d.showMore,v=void 0!==n&&n,r=d.showMoreLimit,f=void 0===r?20:r,i=d.sortBy,u=void 0===i?["isRefined","count:desc","name:asc"]:i,a=d.escapeFacetValues,l=void 0===a||a,s=d.transformItems,g=void 0===s?function(e){return e}:s;if(!m)throw new Error(ar("The `attribute` option is required."));if(!/^(and|or)$/.test(h))throw new Error(ar('The `operator` must one of: `"and"`, `"or"` (got "'.concat(h,'").')));if(!0===v&&f<=p)throw new Error(ar("`showMoreLimit` should be greater than `limit`."));function y(e){var t=e.name;return D({},A(e,["name"]),{label:t,value:t,highlighted:t})}function b(e){return e?f:p}function R(e){var t=e.items,n=e.state,r=e.createURL,i=e.helperSpecializedSearchFacetValues,a=e.refine,s=e.isFromSearch,o=e.isFirstSearch,c=e.isShowingMore,u=e.toggleShowMore,l=e.instantSearchInstance,h=i&&i(n,r,i,a,l,c),f=c&&_.length>p||v&&!s&&!N;x({createURL:function(e){return r(n.toggleRefinement(m,e))},items:t,refine:a,searchForItems:h,instantSearchInstance:l,isFromSearch:s,canRefine:s||0<t.length,widgetParams:d,isShowingMore:c,canToggleShowMore:f,toggleShowMore:u,hasExhaustiveItems:N},o)}function o(n,u){return function(r,i,a,s,o,c){return function(e){if(""===e&&_)R({items:_,state:r,createURL:i,helperSpecializedSearchFacetValues:a,refine:s,isFromSearch:!1,isFirstSearch:!1,instantSearchInstance:o,toggleShowMore:u,isShowingMore:c});else{var t={highlightPreTag:l?et.highlightPreTag:tt.highlightPreTag,highlightPostTag:l?et.highlightPostTag:tt.highlightPostTag};n.searchForFacetValues(m,e,Math.min(b(c),100),t).then(function(e){var t=l?function(e){return e.map(function(e){return D({},e,{highlighted:nt(e.highlighted)})})}(e.facetHits):e.facetHits,n=g(t.map(function(e){var t=e.value;return D({},A(e,["value"]),{value:t,label:t})}));R({items:n,state:r,createURL:i,helperSpecializedSearchFacetValues:a,refine:s,isFromSearch:!0,isFirstSearch:!1,instantSearchInstance:o,isShowingMore:c})})}}}}var w,S,P,_=[],N=!0;return{$$type:"ais.refinementList",isShowingMore:!1,toggleShowMore:function(){},cachedToggleShowMore:function(){this.toggleShowMore()},createToggleShowMore:function(e){var t=this;return function(){t.isShowingMore=!t.isShowingMore,t.render(e)}},getLimit:function(){return b(this.isShowingMore)},init:function(e){var t=e.helper,n=e.createURL,r=e.instantSearchInstance;this.cachedToggleShowMore=this.cachedToggleShowMore.bind(this),P=qe({instantSearchInstance:r,helper:t,attribute:m,widgetType:this.$$type}),S=function(e){P("click",e),t.toggleRefinement(m,e).search()},w=o(t,this.cachedToggleShowMore),R({items:[],state:t.state,createURL:n,helperSpecializedSearchFacetValues:w,refine:S,isFromSearch:!1,isFirstSearch:!0,instantSearchInstance:r,isShowingMore:this.isShowingMore,toggleShowMore:this.cachedToggleShowMore,sendEvent:P})},render:function(e){var t=e.results,n=e.state,r=e.createURL,i=e.instantSearchInstance,a=t.getFacetValues(m,{sortBy:u})||[],s=g(a.slice(0,this.getLimit()).map(y)),o=n.maxValuesPerFacet,c=this.getLimit();N=c<o?a.length<=c:a.length<c,_=s,this.toggleShowMore=this.createToggleShowMore(e),R({items:s,state:n,createURL:r,helperSpecializedSearchFacetValues:w,refine:S,isFromSearch:!1,isFirstSearch:!1,instantSearchInstance:i,isShowingMore:this.isShowingMore,toggleShowMore:this.cachedToggleShowMore,sendEvent:P})},dispose:function(e){var t=e.state;c();var n=t.setQueryParameter("maxValuesPerFacet",void 0);return"and"===h?n.removeFacet(m):n.removeDisjunctiveFacet(m)},getWidgetState:function(e,t){var n=t.searchParameters,r="or"===h?n.getDisjunctiveRefinements(m):n.getConjunctiveRefinements(m);return r.length?D({},e,{refinementList:D({},e.refinementList,L({},m,r))}):e},getWidgetSearchParameters:function(e,t){var n=t.uiState,r="or"===h,i=n.refinementList&&n.refinementList[m],a=e.clearRefinements(m),s=r?a.addDisjunctiveFacet(m):a.addFacet(m),o=s.maxValuesPerFacet||0,c=Math.max(o,v?f:p),u=s.setQueryParameter("maxValuesPerFacet",c);if(i)return i.reduce(function(e,t){return r?e.addDisjunctiveFacetRefinement(m,t):e.addFacetRefinement(m,t)},u);var l=r?"disjunctiveFacetsRefinements":"facetsRefinements";return u.setQueryParameters(L({},l,D({},u[l],L({},m,[]))))}}}}var or=Ae({name:"search-box",connector:!0});function cr(o){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(o,or()),function(){var i=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},a=i.queryHook;function s(e){return function(){e.setQuery(""),e.search()}}return{$$type:"ais.searchBox",_clear:function(){},_cachedClear:function(){this._clear()},init:function(e){var t=e.helper,n=e.instantSearchInstance;this._cachedClear=this._cachedClear.bind(this),this._clear=s(t);function r(e){e!==t.state.query&&t.setQuery(e).search()}this._refine=function(e){a?a(e,r):r(e)},o({query:t.state.query||"",refine:this._refine,clear:this._cachedClear,widgetParams:i,instantSearchInstance:n},!0)},render:function(e){var t=e.helper,n=e.instantSearchInstance,r=e.searchMetadata;this._clear=s(t),o({query:t.state.query||"",refine:this._refine,clear:this._cachedClear,widgetParams:i,instantSearchInstance:n,isSearchStalled:r.isSearchStalled},!1)},dispose:function(e){var t=e.state;return n(),t.setQueryParameter("query",void 0)},getWidgetState:function(e,t){var n=t.searchParameters.query||"";return""===n||e&&e.query===n?e:D({},e,{query:n})},getWidgetSearchParameters:function(e,t){var n=t.uiState;return e.setQueryParameter("query",n.query||"")}}}}var ur=Ae({name:"sort-by",connector:!0});function lr(c){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(c,ur()),function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},s=a.items,e=a.transformItems,o=void 0===e?function(e){return e}:e;if(!Array.isArray(s))throw new Error(ur("The `items` option expects an array of objects."));return{$$type:"ais.sortBy",init:function(e){var t=e.helper,n=e.instantSearchInstance,r=e.parent,i=t.state.index;ge(s,function(e){return e.value===i});this.initialIndex=r.getIndexName(),this.setIndex=function(e){t.setIndex(e).search()},c({currentRefinement:i,options:o(s),refine:this.setIndex,hasNoResults:!0,widgetParams:a,instantSearchInstance:n},!0)},render:function(e){var t=e.helper,n=e.results,r=e.instantSearchInstance;c({currentRefinement:t.state.index,options:o(s),refine:this.setIndex,hasNoResults:0===n.nbHits,widgetParams:a,instantSearchInstance:r},!1)},dispose:function(e){var t=e.state;return n(),t.setIndex(this.initialIndex)},getWidgetState:function(e,t){var n=t.searchParameters.index;return n===this.initialIndex?e:D({},e,{sortBy:n})},getWidgetSearchParameters:function(e,t){var n=t.uiState;return e.setQueryParameter("index",n.sortBy||this.initialIndex||e.index)}}}}var hr=Ae({name:"rating-menu",connector:!0}),fr="ais.ratingMenu",dr=function(e){var o=e.instantSearchInstance,c=e.helper,u=e.getRefinedStar,l=e.attribute;return function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(1!==t.length){var r=t[0],i=t[1],a=t[2],s=void 0===a?"Filter Applied":a;if("click"===r)u()===Number(i)||o.sendEventToInsights({insightsMethod:"clickedFilters",widgetType:fr,eventType:r,payload:{eventName:s,index:c.getIndex(),filters:["".concat(l,">=").concat(i)]}})}else o.sendEventToInsights(t[0])}};function mr(g){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(g,hr()),function(){var d,m=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},p=m.attribute,e=m.max,v=void 0===e?5:e;if(!p)throw new Error(hr("The `attribute` option is required."));return{$$type:fr,init:function(e){var t=this,n=e.helper,r=e.createURL,i=e.instantSearchInstance;this._toggleRefinement=this._toggleRefinement.bind(this,n),this._createURL=function(t){return function(e){return r(t.toggleRefinement(p,e))}},d=dr({instantSearchInstance:i,helper:n,getRefinedStar:function(){return t._getRefinedStar(n.state)},attribute:p}),g({instantSearchInstance:i,items:[],hasNoResults:!0,refine:this._toggleRefinement,sendEvent:d,createURL:this._createURL(n.state),widgetParams:m},!0)},render:function(e){for(var t=e.helper,n=e.results,r=e.state,i=e.instantSearchInstance,a=[],s={},o=v;0<=o;--o)s[o]=0;(n.getFacetValues(p)||[]).forEach(function(e){var t=Math.round(e.name);if(t&&!(v<t))for(var n=t;1<=n;--n)s[n]+=e.count});for(var c=this._getRefinedStar(t.state),u=v-1;1<=u;--u){var l=s[u];if(!c||u===c||0!==l){for(var h=[],f=1;f<=v;++f)h.push(f<=u);a.push({stars:h,name:String(u),value:String(u),count:l,isRefined:c===u})}}g({instantSearchInstance:i,items:a,hasNoResults:0===n.nbHits,refine:this._toggleRefinement,sendEvent:d,createURL:this._createURL(r),widgetParams:m},!1)},dispose:function(e){var t=e.state;return n(),t.removeDisjunctiveFacet(p)},getWidgetState:function(e,t){var n=t.searchParameters,r=this._getRefinedStar(n);return"number"!=typeof r?e:D({},e,{ratingMenu:D({},e.ratingMenu,L({},p,r))})},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=n.ratingMenu&&n.ratingMenu[p],i=e.clearRefinements(p).addDisjunctiveFacet(p);return r?Ie({start:Number(r),end:v+1}).reduce(function(e,t){return e.addDisjunctiveFacetRefinement(p,t)},i):i.setQueryParameters({disjunctiveFacetsRefinements:D({},i.disjunctiveFacetsRefinements,L({},p,[]))})},_toggleRefinement:function(e,t){d("click",t);var n=this._getRefinedStar(e.state)===Number(t);if(e.removeDisjunctiveFacetRefinement(p),!n)for(var r=Number(t);r<=v;++r)e.addDisjunctiveFacetRefinement(p,r);e.search()},_getRefinedStar:function(e){var t=e.getDisjunctiveRefinements(p);if(t.length)return Math.min.apply(Math,_(t.map(Number)))}}}}var pr=Ae({name:"stats",connector:!0});function vr(i){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(i,pr()),function(){var r=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{$$type:"ais.stats",init:function(e){var t=e.helper,n=e.instantSearchInstance;i({instantSearchInstance:n,hitsPerPage:t.state.hitsPerPage,nbHits:0,nbPages:0,page:t.state.page||0,processingTimeMS:-1,query:t.state.query||"",widgetParams:r},!0)},render:function(e){var t=e.results,n=e.instantSearchInstance;i({instantSearchInstance:n,hitsPerPage:t.hitsPerPage,nbHits:t.nbHits,nbPages:t.nbPages,page:t.page,processingTimeMS:t.processingTimeMS,query:t.query,widgetParams:r},!1)},dispose:function(){e()}}}}var gr=Ae({name:"toggle-refinement",connector:!0}),yr="ais.toggleRefinement",br=function(e){var o=e.instantSearchInstance,c=e.attribute,u=e.on,l=e.helper;return function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(1!==t.length){var r=t[0],i=t[1],a=t[2],s=void 0===a?"Filter Applied":a;"click"===r&&void 0!==u&&(i||o.sendEventToInsights({insightsMethod:"clickedFilters",widgetType:yr,eventType:r,payload:{eventName:s,index:l.getIndex(),filters:u.map(function(e){return"".concat(c,":").concat(JSON.stringify(e))})}}))}else o.sendEventToInsights(t[0])}};function Rr(b){var r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;return Pe(b,gr()),function(){var d=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},m=d.attribute,e=d.on,t=void 0===e||e,n=d.off;if(!m)throw new Error(gr("The `attribute` option is required."));var p,v=void 0!==n,g=void 0!==t?Oe(t).map(Se):void 0,y=v?Oe(n).map(Se):void 0;return{$$type:yr,_toggleRefinement:function(t,e){var n=(1<arguments.length&&void 0!==e?e:{}).isRefined;n?(g.forEach(function(e){return t.removeDisjunctiveFacetRefinement(m,e)}),v&&y.forEach(function(e){return t.addDisjunctiveFacetRefinement(m,e)})):(p("click",n),v&&y.forEach(function(e){return t.removeDisjunctiveFacetRefinement(m,e)}),g.forEach(function(e){return t.addDisjunctiveFacetRefinement(m,e)})),t.search()},init:function(e){var t=this,r=e.state,n=e.helper,i=e.createURL,a=e.instantSearchInstance;p=br({instantSearchInstance:a,attribute:m,on:g,helper:n}),this._createURL=function(n){return function(){var e=n?g:y;e&&e.forEach(function(e){r.removeDisjunctiveFacetRefinement(m,e)});var t=n?y:g;return t&&t.forEach(function(e){r.addDisjunctiveFacetRefinement(m,e)}),i(r)}},this.toggleRefinement=function(e){t._toggleRefinement(n,e)};var s=g&&g.every(function(e){return r.isDisjunctiveFacetRefined(m,e)});if(v&&!s){var o=n.state.page;y&&y.forEach(function(e){return n.addDisjunctiveFacetRefinement(m,e)}),n.setPage(o)}var c={name:m,isRefined:s,count:null,onFacetValue:{isRefined:s,count:0},offFacetValue:{isRefined:v&&!s,count:0}};b({value:c,createURL:this._createURL(c.isRefined),refine:this.toggleRefinement,sendEvent:p,instantSearchInstance:a,widgetParams:d},!0)},render:function(e){var t=e.helper,n=e.results,r=e.state,i=e.instantSearchInstance,a=g&&g.every(function(e){return t.state.isDisjunctiveFacetRefined(m,e)}),s=Oe(void 0!==y&&y),o=n.getFacetValues(m)||[],c=g&&g.map(function(t){return ge(o,function(e){return e.name===ye(t)})}).filter(function(e){return void 0!==e}),u={isRefined:0<c.length&&c.every(function(e){return e.isRefined}),count:0===c.length?null:c.reduce(function(e,t){return e+t.count},0)},l=v?s.map(function(t){return ge(o,function(e){return e.name===ye(t)})}).filter(function(e){return void 0!==e}):[],h={isRefined:0<l.length&&l.every(function(e){return e.isRefined}),count:0===l.length?o.reduce(function(e,t){return e+t.count},0):l.reduce(function(e,t){return e+t.count},0)},f={name:m,isRefined:a,count:(a?h:u).count,onFacetValue:u,offFacetValue:h};b({value:f,state:r,createURL:this._createURL(f.isRefined),refine:this.toggleRefinement,sendEvent:p,helper:t,instantSearchInstance:i,widgetParams:d},!1)},dispose:function(e){var t=e.state;return r(),t.removeDisjunctiveFacet(m)},getWidgetState:function(e,t){var n=t.searchParameters,r=g&&g.every(function(e){return n.isDisjunctiveFacetRefined(m,e)});return r?D({},e,{toggle:D({},e.toggle,L({},m,r))}):e},getWidgetSearchParameters:function(e,t){var n=t.uiState,r=e.clearRefinements(m).addDisjunctiveFacet(m);return Boolean(n.toggle&&n.toggle[m])?(g&&g.forEach(function(e){r=r.addDisjunctiveFacetRefinement(m,e)}),r):v?(y&&y.forEach(function(e){r=r.addDisjunctiveFacetRefinement(m,e)}),r):r.setQueryParameters({disjunctiveFacetsRefinements:D({},e.disjunctiveFacetsRefinements,L({},m,[]))})}}}}function wr(l,e){var h=1<arguments.length&&void 0!==e?e:_e;Pe(l,Sr());var f={};return function(o){var e=o||{},t=e.attributes,n=e.separator,r=void 0===n?" > ":n,i=e.rootPath,a=void 0===i?null:i,s=e.transformItems,c=void 0===s?function(e){return e}:s;if(!t||!Array.isArray(t)||0===t.length)throw new Error(Sr("The `attributes` option expects an array of strings."));var u=Q(t,1)[0];return{$$type:"ais.breadcrumb",init:function(e){var n=e.createURL,r=e.helper,t=e.instantSearchInstance;f.createURL=function(e){if(!e){var t=r.getHierarchicalFacetBreadcrumb(u);if(0<t.length)return n(r.state.toggleFacetRefinement(u,t[0]))}return n(r.state.toggleFacetRefinement(u,e))},f.refine=function(e){if(e)r.toggleRefinement(u,e).search();else{var t=r.getHierarchicalFacetBreadcrumb(u);0<t.length&&r.toggleRefinement(u,t[0]).search()}},l({createURL:f.createURL,canRefine:!1,instantSearchInstance:t,items:[],refine:f.refine,widgetParams:o},!0)},render:function(e){var t=e.instantSearchInstance,n=e.results,r=Q(e.state.hierarchicalFacets,1)[0].name,i=n.getFacetValues(r,{}),a=Array.isArray(i.data)?i.data:[],s=c(function(n){return n.map(function(e,t){return{label:e.label,value:t+1===n.length?null:n[t+1].value}})}(function n(e){return e.reduce(function(e,t){return t.isRefined&&(e.push({label:t.name,value:t.path}),Array.isArray(t.data)&&(e=e.concat(n(t.data)))),e},[])}(a)));l({canRefine:0<s.length,createURL:f.createURL,instantSearchInstance:t,items:s,refine:f.refine,widgetParams:o},!1)},dispose:function(){h()},getWidgetSearchParameters:function(e){if(e.isHierarchicalFacet(u)){e.getHierarchicalFacetByName(u);return e}return e.addHierarchicalFacet({name:u,attributes:t,separator:r,rootPath:a})}}}}var Sr=Ae({name:"breadcrumb",connector:!0});function Pr(_,e){var r=1<arguments.length&&void 0!==e?e:_e;return Pe(_,_r()),function(){function u(e){return e.aroundLatLng&&function(e){var t=e.match(He);if(!t)throw new Error('Invalid value for "aroundLatLng" parameter: "'.concat(e,'"'));return{lat:parseFloat(t[1]),lng:parseFloat(t[2])}}(e.aroundLatLng)}function l(e){return e.insideBoundingBox&&De(e.insideBoundingBox)}function h(i){return function(e){var t=e.northEast,n=e.southWest,r=[t.lat,t.lng,n.lat,n.lng].join();i.setQueryParameter("insideBoundingBox",r).search(),P.hasMapMoveSinceLastRefine=!1,P.lastRefineBoundingBox=r}}function f(e){return function(){e.setQueryParameter("insideBoundingBox",void 0).search()}}function d(e){return function(){return Boolean(e.insideBoundingBox)}}function m(){return P.internalToggleRefineOnMapMove()}function p(e,t){return function(){P.isRefineOnMapMove=!P.isRefineOnMapMove,e(t)}}function v(){return P.isRefineOnMapMove}function g(){return P.internalSetMapMoveSinceLastRefine()}function y(t,n){return function(){var e=!0!==P.hasMapMoveSinceLastRefine;P.hasMapMoveSinceLastRefine=!0,e&&t(n)}}function b(){return P.hasMapMoveSinceLastRefine}var R,w=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=w.enableRefineOnMapMove,t=void 0===e||e,n=w.transformItems,S=void 0===n?function(e){return e}:n,P={isRefineOnMapMove:t,hasMapMoveSinceLastRefine:!1,lastRefinePosition:"",lastRefineBoundingBox:"",internalToggleRefineOnMapMove:_e,internalSetMapMoveSinceLastRefine:_e};return{$$type:Nr,init:function(e){var t=e.state,n=e.helper,r=e.instantSearchInstance;R=Ve({instantSearchInstance:r,index:n.getIndex(),widgetType:Nr}),P.internalToggleRefineOnMapMove=p(_e,e),P.internalSetMapMoveSinceLastRefine=y(_e,e),_({items:[],position:u(t),currentRefinement:l(t),refine:h(n),sendEvent:R,clearMapRefinement:f(n),isRefinedWithMap:d(t),toggleRefineOnMapMove:m,isRefineOnMapMove:v,setMapMoveSinceLastRefine:g,hasMapMoveSinceLastRefine:b,widgetParams:w,instantSearchInstance:r},!0)},render:function e(t){var n=t.results,r=t.helper,i=t.instantSearchInstance,a=r.state,s=Boolean(a.aroundLatLng)&&Boolean(P.lastRefinePosition)&&a.aroundLatLng!==P.lastRefinePosition,o=!a.insideBoundingBox&&Boolean(P.lastRefineBoundingBox)&&a.insideBoundingBox!==P.lastRefineBoundingBox;(s||o)&&(P.hasMapMoveSinceLastRefine=!1),P.lastRefinePosition=a.aroundLatLng||"",P.lastRefineBoundingBox=a.insideBoundingBox||"",P.internalToggleRefineOnMapMove=p(e,t),P.internalSetMapMoveSinceLastRefine=y(e,t);var c=S(n.hits.filter(function(e){return e._geoloc}));R("view",c),_({items:c,position:u(a),currentRefinement:l(a),refine:h(r),sendEvent:R,clearMapRefinement:f(r),isRefinedWithMap:d(a),toggleRefineOnMapMove:m,isRefineOnMapMove:v,setMapMoveSinceLastRefine:g,hasMapMoveSinceLastRefine:b,widgetParams:w,instantSearchInstance:i},!1)},dispose:function(e){var t=e.state;return r(),t.setQueryParameter("insideBoundingBox",void 0)},getWidgetState:function(e,t){var n=t.searchParameters.insideBoundingBox;return!n||e&&e.geoSearch&&e.geoSearch.boundingBox===n?e:D({},e,{geoSearch:{boundingBox:n}})},getWidgetSearchParameters:function(e,t){var n=t.uiState;return n&&n.geoSearch?e.setQueryParameter("insideBoundingBox",n.geoSearch.boundingBox):e.setQueryParameter("insideBoundingBox",void 0)}}}}var _r=Ae({name:"geo-search",connector:!0}),Nr="ais.geoSearch",xr=Ae({name:"powered-by",connector:!0});function Fr(r){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_e;Pe(r,xr());var a="https://www.algolia.com/?utm_source=instantsearch.js&utm_medium=website&"+"utm_content=".concat("undefined"!=typeof window&&window.location?window.location.hostname:"","&")+"utm_campaign=poweredby";return function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.url,n=void 0===t?a:t;return{$$type:"ais.poweredBy",init:function(){r({url:n,widgetParams:e},!0)},render:function(){r({url:n,widgetParams:e},!1)},dispose:function(){i()}}}}var Ir=Ae({name:"configure",connector:!0});function Cr(e,t){return e.setQueryParameters(Object.keys(t.searchParameters).reduce(function(e,t){return D({},e,L({},t,void 0))},{}))}function Tr(e,t){var a=0<arguments.length&&void 0!==e?e:_e,n=1<arguments.length&&void 0!==t?t:_e;return function(i){if(!i||!Fe(i.searchParameters))throw new Error(Ir("The `searchParameters` option expects an object."));var r={};return{$$type:"ais.configure",init:function(e){var t=e.instantSearchInstance,n=e.helper;r.refine=function(r){return function(e){var t=Cr(r.state,i),n=je(t,new ae.SearchParameters(e));r.setState(n).search(),i.searchParameters=e}}(n),a({refine:r.refine,instantSearchInstance:t,widgetParams:i},!0)},render:function(e){var t=e.instantSearchInstance;a({refine:r.refine,instantSearchInstance:t,widgetParams:i},!1)},dispose:function(e){var t=e.state;return n(),Cr(t,i)},getWidgetSearchParameters:function(e,t){var n=t.uiState;return je(e,new ae.SearchParameters(D({},n.configure,{},i.searchParameters)))},getWidgetState:function(e){return D({},e,{configure:D({},e.configure,{},i.searchParameters)})}}}}var Er=Ae({name:"configure-related-items",connector:!0});function kr(e){var t=e.attributeName,n=e.attributeValue,r=e.attributeScore;return"".concat(t,":").concat(n,"<score=").concat(r||1,">")}function Mr(c,u){return function(e){var t=e||{},a=t.hit,s=t.matchingPatterns,n=t.transformSearchParameters,r=void 0===n?function(e){return e}:n;if(!a)throw new Error(Er("The `hit` option is required."));if(!s)throw new Error(Er("The `matchingPatterns` option is required."));var i=Object.keys(s).reduce(function(e,t){var n=s[t],r=Ne(a,t),i=n.score;return Array.isArray(r)?[].concat(_(e),[r.map(function(e){return kr({attributeName:t,attributeValue:e,attributeScore:i})})]):"string"==typeof r?[].concat(_(e),[kr({attributeName:t,attributeValue:r,attributeScore:i})]):e},[]),o=D({},r(new ae.SearchParameters({sumOrFiltersScores:!0,facetFilters:["objectID:-".concat(a.objectID)],optionalFilters:i})));return D({},Tr(c,u)({searchParameters:o}),{$$type:"ais.configureRelatedItems"})}}var Lr=Ae({name:"autocomplete",connector:!0}),jr=Ae({name:"query-rules",connector:!0});function Or(e){var t=this.helper,n=this.initialRuleContexts,r=this.trackedFilters,i=this.transformRuleContexts,a=e.state,s=a.ruleContexts||[],o=function(e){var i=e.helper,a=e.sharedHelperState,s=e.trackedFilters;return Object.keys(s).reduce(function(e,t){var n=Re(i.lastResults||{},a).filter(function(e){return e.attribute===t}).map(function(e){return e.numericValue||e.name}),r=(0,s[t])(n);return[].concat(_(e),_(n.filter(function(e){return r.includes(e)}).map(function(e){return function(e){return e.replace(/[^a-z0-9-_]+/gi,"_")}("ais-".concat(t,"-").concat(e))})))},[])}({helper:t,sharedHelperState:a,trackedFilters:r}),c=i([].concat(_(n),_(o))).slice(0,10);Te(s,c)||t.overrideStateWithoutTriggeringChangeEvent(D({},a,{ruleContexts:c}))}function Ar(h,e){var f=1<arguments.length&&void 0!==e?e:_e;return Pe(h,jr()),function(a){var e=a||{},t=e.trackedFilters,i=void 0===t?{}:t,n=e.transformRuleContexts,s=void 0===n?function(e){return e}:n,r=e.transformItems,o=void 0===r?function(e){return e}:r;Object.keys(i).forEach(function(e){if("function"!=typeof i[e])throw new Error(jr("'The \"".concat(e,'" filter value in the `trackedFilters` option expects a function.')))});var c,u=0<Object.keys(i).length,l=[];return{$$type:"ais.queryRules",init:function(e){var t=e.helper,n=e.state,r=e.instantSearchInstance;l=n.ruleContexts||[],c=Or.bind({helper:t,initialRuleContexts:l,trackedFilters:i,transformRuleContexts:s}),u&&((function(e){return[e.disjunctiveFacetsRefinements,e.facetsRefinements,e.hierarchicalFacetsRefinements,e.numericRefinements].some(function(e){return Boolean(e&&0<Object.keys(e).length)})}(n)||Boolean(a.transformRuleContexts))&&c({state:n}),t.on("change",c)),h({items:[],instantSearchInstance:r,widgetParams:a},!0)},render:function(e){var t=e.results,n=e.instantSearchInstance,r=t.userData,i=o(void 0===r?[]:r);h({items:i,instantSearchInstance:n,widgetParams:a},!1)},dispose:function(e){var t=e.helper,n=e.state;return f(),u?(t.removeListener("change",c),n.setQueryParameter("ruleContexts",l)):n}}}}function Hr(e){function t(e){return{status:e,transcript:"",isSpeechFinal:!1,errorCode:void 0}}function n(e){p=D({},p,{},0<arguments.length&&void 0!==e?e:{}),d()}function r(e){n(t(0<arguments.length&&void 0!==e?e:"initial"))}function i(){n({status:"waiting"})}function a(e){n({status:"error",errorCode:e.error})}function s(e){n({status:"recognizing",transcript:e.results[0]&&e.results[0][0]&&e.results[0][0].transcript||"",isSpeechFinal:e.results[0]&&e.results[0].isFinal}),l&&p.transcript&&f(p.transcript)}function o(){p.errorCode||!p.transcript||l||f(p.transcript),"error"!==p.status&&n({status:"finished"})}function c(){u&&(u.stop(),u.removeEventListener("start",i),u.removeEventListener("error",a),u.removeEventListener("result",s),u.removeEventListener("end",o),u=void 0)}var u,l=e.searchAsYouSpeak,h=e.language,f=e.onQueryChange,d=e.onStateChange,m=window.webkitSpeechRecognition||window.SpeechRecognition,p=t("initial");return{getState:function(){return p},isBrowserSupported:function(){return Boolean(m)},isListening:function(){return"askingPermission"===p.status||"waiting"===p.status||"recognizing"===p.status},startListening:function(){(u=new m)&&(r("askingPermission"),u.interimResults=!0,h&&(u.lang=h),u.addEventListener("start",i),u.addEventListener("error",a),u.addEventListener("result",s),u.addEventListener("end",o),u.start())},stopListening:function(){c(),r("finished")},dispose:c}}function Dr(l,e){var h=1<arguments.length&&void 0!==e?e:_e;return Pe(l,Br()),function(u){function i(e){var t=e.isFirstRendering,n=e.instantSearchInstance,r=e.voiceSearchHelper,i=r.isBrowserSupported,a=r.isListening,s=r.startListening,o=r.stopListening,c=r.getState;l({isBrowserSupported:i(),isListening:a(),toggleListening:function(){i()&&(a()?o():s())},voiceListeningState:c(),widgetParams:u,instantSearchInstance:n},t)}var e=u.searchAsYouSpeak,a=void 0!==e&&e,s=u.language,o=u.additionalQueryParameters,t=u.createVoiceSearchHelper,c=void 0===t?Hr:t;return{$$type:"ais.voiceSearch",init:function(e){var t=this,n=e.helper,r=e.instantSearchInstance;this._refine=function(e){if(e!==n.state.query){var t=s?[s.split("-")[0]]:void 0;n.setQueryParameter("queryLanguages",t),"function"==typeof o&&n.setState(n.state.setQueryParameters(D({ignorePlurals:!0,removeStopWords:!0,optionalWords:e},o({query:e})))),n.setQuery(e).search()}},this._voiceSearchHelper=c({searchAsYouSpeak:a,language:s,onQueryChange:function(e){return t._refine(e)},onStateChange:function(){i({isFirstRendering:!1,instantSearchInstance:r,voiceSearchHelper:t._voiceSearchHelper})}}),i({isFirstRendering:!0,instantSearchInstance:r,voiceSearchHelper:this._voiceSearchHelper})},render:function(e){var t=e.instantSearchInstance;i({isFirstRendering:!1,instantSearchInstance:t,voiceSearchHelper:this._voiceSearchHelper})},dispose:function(e){var t=e.state;this._voiceSearchHelper.dispose(),h();var n=t;if("function"==typeof o){var r=o({query:""}),i=r?Object.keys(r).reduce(function(e,t){return e[t]=void 0,e},{}):{};n=t.setQueryParameters(D({queryLanguages:void 0,ignorePlurals:void 0,removeStopWords:void 0,optionalWords:void 0},i))}return n.setQueryParameter("query",void 0)},getWidgetState:function(e,t){var n=t.searchParameters.query||"";return n?D({},e,{query:n}):e},getWidgetSearchParameters:function(e,t){var n=t.uiState;return e.setQueryParameter("query",n.query||"")}}}}var Br=Ae({name:"voice-search",connector:!0}),Qr=Object.freeze({__proto__:null,connectClearRefinements:Vt,connectCurrentRefinements:zt,connectHierarchicalMenu:en,connectHits:tn,connectHitsWithInsights:Hn,connectHitsPerPage:An,connectInfiniteHits:Un,connectInfiniteHitsWithInsights:Vn,connectMenu:$n,connectNumericMenu:zn,connectPagination:tr,connectRange:ir,connectRefinementList:sr,connectSearchBox:cr,connectSortBy:lr,connectRatingMenu:mr,connectStats:vr,connectToggleRefinement:Rr,connectBreadcrumb:wr,connectGeoSearch:Pr,connectPoweredBy:Fr,connectConfigure:Tr,EXPERIMENTAL_connectConfigureRelatedItems:Mr,connectAutocomplete:function(u,e){var r=1<arguments.length&&void 0!==e?e:_e;return Pe(u,Lr()),function(s){var e=(s||{}).escapeHTML,o=void 0===e||e,c={};return{$$type:"ais.autocomplete",init:function(e){var t=e.instantSearchInstance,n=e.helper;c.refine=function(e){n.setQuery(e).search()},u({widgetParams:s,currentRefinement:n.state.query||"",indices:[],refine:c.refine,instantSearchInstance:t},!0)},render:function(e){var n=this,t=e.helper,r=e.scopedResults,i=e.instantSearchInstance,a=r.map(function(e){e.results.hits=o?it(e.results.hits):e.results.hits;var t=Ve({instantSearchInstance:i,index:e.results.index,widgetType:n.$$type});return t("view",e.results.hits),{indexId:e.indexId,indexName:e.results.index,hits:e.results.hits,results:e.results,sendEvent:t}});u({widgetParams:s,currentRefinement:t.state.query||"",indices:a,refine:c.refine,instantSearchInstance:i},!1)},getWidgetState:function(e,t){var n=t.searchParameters.query||"";return""===n||e&&e.query===n?e:D({},e,{query:n})},getWidgetSearchParameters:function(e,t){var n={query:t.uiState.query||""};return o?e.setQueryParameters(D({},n,{},et)):e.setQueryParameters(n)},dispose:function(e){var t=e.state;r();var n=t.setQueryParameter("query",void 0);return o?n.setQueryParameters(Object.keys(et).reduce(function(e,t){return D({},e,L({},t,void 0))},{})):n}}}},connectQueryRules:Ar,connectVoiceSearch:Dr}),qr=fe(function(e){function s(){for(var e=[],t=0;t<arguments.length;t++){var n=arguments[t];if(n){var r=typeof n;if("string"==r||"number"==r)e.push(n);else if(Array.isArray(n)&&n.length){var i=s.apply(null,n);i&&e.push(i)}else if("object"==r)for(var a in n)o.call(n,a)&&n[a]&&e.push(a)}}return e.join(" ")}var o;o={}.hasOwnProperty,e.exports?(s.default=s,e.exports=s):window.classNames=s}),Ur=function(){function e(){return k(this,e),B(this,O(e).apply(this,arguments))}return j(e,bn),M(e,[{key:"shouldComponentUpdate",value:function(e){return!Te(this.props.data,e.data)||this.props.templateKey!==e.templateKey||!Te(this.props.rootProps,e.rootProps)}},{key:"render",value:function(){var e=this.props.rootTagName,t=this.props.useCustomCompileOptions[this.props.templateKey]?this.props.templatesConfig.compileOptions:{},n=ve({templates:this.props.templates,templateKey:this.props.templateKey,compileOptions:t,helpers:this.props.templatesConfig.helpers,data:this.props.data,bindEvent:this.props.bindEvent});return null===n?null:vn(e,f({},this.props.rootProps,{dangerouslySetInnerHTML:{__html:n}}))}}]),e}();Ur.defaultProps={data:{},rootTagName:"div",useCustomCompileOptions:{},templates:{},templatesConfig:{}};function Vr(e){var t=e.hasRefinements,n=e.refine,r=e.cssClasses,i=e.templateProps;return vn("div",{className:r.root},vn(Ur,f({},i,{templateKey:"resetLabel",rootTagName:"button",rootProps:{className:qr(r.button,L({},r.disabledButton,!t)),onClick:n,disabled:!t},data:{hasRefinements:t}})))}function Wr(e){var t=e.items,n=e.cssClasses;return vn("div",{className:n.root},vn("ul",{className:n.list},t.map(function(t,e){return vn("li",{key:"".concat(t.indexName,"-").concat(t.attribute,"-").concat(e),className:n.item},vn("span",{className:n.label},function(e){return e.toString().charAt(0).toUpperCase()+e.toString().slice(1)}(t.label),":"),t.refinements.map(function(e){return vn("span",{key:function(e){var t=e.attribute,n=e.value;return[t,e.type,n,e.operator].map(function(e){return e}).filter(Boolean).join(":")}(e),className:n.category},vn("span",{className:n.categoryLabel},"query"===e.attribute?vn("q",null,e.label):e.label),vn("button",{className:n.delete,onClick:function(t){return function(e){ue(e)||(e.preventDefault(),t())}}(t.refine.bind(null,e))},"✕"))}))})))}function $r(e,t){var n=e.items,r=e.widgetParams;if(!t){var i=r.container,a=r.cssClasses;Ln(vn(Wr,{cssClasses:a,items:n}),i)}}function zr(e){var t=e.className,n=e.disabled;return vn("button",{className:t,onClick:e.onClick,disabled:n},e.children)}var Kr={resetLabel:"Clear refinements"},Jr=Ae({name:"clear-refinements"}),Yr=at("ClearRefinements"),Gr=Ae({name:"current-refinements"}),Xr=at("CurrentRefinements");zr.defaultProps={disabled:!1};function Zr(e){var t=e.classNameLabel,n=e.classNameInput,r=e.checked,i=e.onToggle,a=e.children;return vn("label",{className:t},vn("input",{className:n,type:"checkbox",checked:r,onChange:i}),a)}function ei(e){var t=e.cssClasses,n=e.enableRefine,r=e.enableRefineControl,i=e.enableClearMapRefinement,a=e.isRefineOnMapMove,s=e.isRefinedWithMap,o=e.hasMapMoveSinceLastRefine,c=e.onRefineToggle,u=e.onRefineClick,l=e.onClearClick,h=e.templateProps;return n&&vn("div",null,r&&vn("div",{className:t.control},a||!o?vn(Zr,{classNameLabel:qr(t.label,L({},t.selectedLabel,a)),classNameInput:t.input,checked:a,onToggle:c},vn(Ur,f({},h,{templateKey:"toggle",rootTagName:"span"}))):vn(zr,{className:t.redo,disabled:!o,onClick:u},vn(Ur,f({},h,{templateKey:"redo",rootTagName:"span"})))),!r&&!a&&vn("div",{className:t.control},vn(zr,{className:qr(t.redo,L({},t.disabledRedo,!o)),disabled:!o,onClick:u},vn(Ur,f({},h,{templateKey:"redo",rootTagName:"span"})))),i&&s&&vn(zr,{className:t.reset,onClick:l},vn(Ur,f({},h,{templateKey:"reset",rootTagName:"span"}))))}function ti(e){var t=e.refine,n=e.mapInstance;return t({northEast:n.getBounds().getNorthEast().toJSON(),southWest:n.getBounds().getSouthWest().toJSON()})}function ni(e,t){e.isUserInteraction=!1,t(),e.isUserInteraction=!0}function ri(e,t){var n=e.items,r=e.position,i=e.currentRefinement,a=e.refine,s=e.clearMapRefinement,o=e.toggleRefineOnMapMove,c=e.isRefineOnMapMove,u=e.setMapMoveSinceLastRefine,l=e.hasMapMoveSinceLastRefine,h=e.isRefinedWithMap,f=e.widgetParams,d=e.instantSearchInstance,m=f.container,p=f.googleReference,v=f.cssClasses,g=f.templates,y=f.initialZoom,b=f.initialPosition,R=f.enableRefine,w=f.enableClearMapRefinement,S=f.enableRefineControl,P=f.mapOptions,_=f.createMarker,N=f.markerOptions,x=f.renderState;if(t){x.isUserInteraction=!0,x.isPendingRefine=!1,x.markers=[];var F=document.createElement("div");F.className=v.root,m.appendChild(F);var I=document.createElement("div");I.className=v.map,F.appendChild(I);var C=document.createElement("div");C.className=v.tree,F.appendChild(C),x.mapInstance=new p.maps.Map(I,D({mapTypeControl:!1,fullscreenControl:!1,streetViewControl:!1,clickableIcons:!1,zoomControlOptions:{position:p.maps.ControlPosition.LEFT_TOP}},P));return p.maps.event.addListenerOnce(x.mapInstance,"idle",function(){function e(){x.isUserInteraction&&R&&(u(),c()&&(x.isPendingRefine=!0))}x.mapInstance.addListener("center_changed",e),x.mapInstance.addListener("zoom_changed",e),x.mapInstance.addListener("dragstart",e),x.mapInstance.addListener("idle",function(){x.isUserInteraction&&x.isPendingRefine&&(x.isPendingRefine=!1,ti({mapInstance:x.mapInstance,refine:a}))})}),void(x.templateProps=he({templatesConfig:d.templatesConfig,templates:g}))}var T=n.map(function(e){return e.objectID}),E=Q(function(e,a){return e.reduce(function(e,t){var n=Q(e,2),r=n[0],i=n[1];return a.includes(t.__id)?[r.concat(t),i]:[r,i.concat(t)]},[[],[]])}(x.markers,T),2),k=E[0],M=E[1],L=k.map(function(e){return e.__id}),j=n.filter(function(e){return!L.includes(e.objectID)});M.forEach(function(e){return e.setMap(null)}),x.markers=k.concat(j.map(function(n){var r=_({map:x.mapInstance,item:n});return Object.keys(N.events).forEach(function(t){r.addListener(t,function(e){N.events[t]({map:x.mapInstance,event:e,item:n,marker:r})})}),r}));var O=!l(),A=i?0:null,H=!i&&Boolean(x.markers.length)?function(e,t){var n=t.reduce(function(e,t){return e.extend(t.getPosition())},new e.maps.LatLngBounds);return{northEast:n.getNorthEast().toJSON(),southWest:n.getSouthWest().toJSON()}}(p,x.markers):i;H&&O?ni(x,function(){x.mapInstance.fitBounds(new p.maps.LatLngBounds(H.southWest,H.northEast),A)}):O&&ni(x,function(){x.mapInstance.setCenter(r||b),x.mapInstance.setZoom(y)}),Ln(vn(ei,{cssClasses:v,enableRefine:R,enableRefineControl:S,enableClearMapRefinement:w,isRefineOnMapMove:c(),isRefinedWithMap:h(),hasMapMoveSinceLastRefine:l(),onRefineToggle:o,onRefineClick:function(){return ti({mapInstance:x.mapInstance,refine:a})},onClearClick:s,templateProps:x.templateProps}),m.querySelector(".".concat(v.tree)))}var ii={HTMLMarker:"<p>Your custom HTML Marker</p>",reset:"Clear the map refinement",toggle:"Search as I move the map",redo:"Redo search here"},ai=Ae({name:"geo-search"}),si=at("GeoSearch");function oi(e){var t=e.className,n=e.handleClick,r=e.facetValueToRefine,i=e.isRefined,a=e.templateProps,s=e.templateKey,o=e.templateData,c=e.subItems;return vn("li",{className:t,onClick:function(e){n({facetValueToRefine:r,isRefined:i,originalEvent:e})}},vn(Ur,f({},a,{templateKey:s,data:o})),c)}var ci=function(){function i(){var e,s;k(this,i);for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return L(H(s=B(this,(e=O(i)).call.apply(e,[this].concat(n)))),"state",{query:s.props.query,focused:!1}),L(H(s),"onInput",function(e){var t=s.props,n=t.searchAsYouType,r=t.refine,i=t.onChange,a=e.target.value;n&&r(a),s.setState({query:a}),i(e)}),L(H(s),"onSubmit",function(e){var t=s.props,n=t.searchAsYouType,r=t.refine,i=t.onSubmit;return e.preventDefault(),e.stopPropagation(),s.input.blur(),n||r(s.state.query),i(e),!1}),L(H(s),"onReset",function(e){var t=s.props,n=t.refine,r=t.onReset;s.input.focus(),n(""),s.setState({query:""}),r(e)}),L(H(s),"onBlur",function(){s.setState({focused:!1})}),L(H(s),"onFocus",function(){s.setState({focused:!0})}),s}return j(i,bn),M(i,[{key:"resetInput",value:function(){this.setState({query:""})}},{key:"componentWillReceiveProps",value:function(e){this.state.focused||e.query===this.state.query||this.setState({query:e.query})}},{key:"render",value:function(){var t=this,e=this.props,n=e.cssClasses,r=e.placeholder,i=e.autofocus,a=e.showSubmit,s=e.showReset,o=e.showLoadingIndicator,c=e.templates,u=e.isSearchStalled;return vn("div",{className:n.root},vn("form",{action:"",role:"search",className:n.form,noValidate:!0,onSubmit:this.onSubmit,onReset:this.onReset},vn("input",{ref:function(e){return t.input=e},value:this.state.query,disabled:this.props.disabled,className:n.input,type:"search",placeholder:r,autoFocus:i,autoComplete:"off",autoCorrect:"off",autoCapitalize:"off",spellCheck:"false",maxLength:512,onInput:this.onInput,onBlur:this.onBlur,onFocus:this.onFocus}),vn(Ur,{templateKey:"submit",rootTagName:"button",rootProps:{className:n.submit,type:"submit",title:"Submit the search query.",hidden:!a},templates:c,data:{cssClasses:n}}),vn(Ur,{templateKey:"reset",rootTagName:"button",rootProps:{className:n.reset,type:"reset",title:"Clear the search query.",hidden:!(s&&this.state.query.trim()&&!u)},templates:c,data:{cssClasses:n}}),o&&vn(Ur,{templateKey:"loadingIndicator",rootTagName:"span",rootProps:{className:n.loadingIndicator,hidden:!u},templates:c,data:{cssClasses:n}})))}}]),i}();L(ci,"defaultProps",{query:"",showSubmit:!0,showReset:!0,showLoadingIndicator:!0,autofocus:!1,searchAsYouType:!0,isSearchStalled:!1,disabled:!1,onChange:_e,onSubmit:_e,onReset:_e,refine:_e});var ui=function(){function c(e){var t;return k(this,c),(t=B(this,O(c).call(this,e))).handleItemClick=t.handleItemClick.bind(H(t)),t}return j(c,bn),M(c,[{key:"shouldComponentUpdate",value:function(e,t){var n=this.state!==t,r=!Te(this.props.facetValues,e.facetValues);return n||r}},{key:"refine",value:function(e,t){this.props.toggleRefinement(e,t)}},{key:"_generateFacetItem",value:function(e){var t,n,r=e.data&&0<e.data.length;if(r){var i=this.props.cssClasses,a=(i.root,A(i,["root"]));n=vn(c,f({},this.props,{cssClasses:a,depth:this.props.depth+1,facetValues:e.data,showMore:!1,className:this.props.cssClasses.childList}))}var s=D({},e,{url:this.props.createURL(e.value),attribute:this.props.attribute,cssClasses:this.props.cssClasses,isFromSearch:this.props.isFromSearch}),o=e.value;return void 0!==e.isRefined&&(o+="/".concat(e.isRefined)),void 0!==e.count&&(o+="/".concat(e.count)),vn(oi,{templateKey:"item",key:o,facetValueToRefine:e.value,handleClick:this.handleItemClick,isRefined:e.isRefined,className:qr(this.props.cssClasses.item,(t={},L(t,this.props.cssClasses.selectedItem,e.isRefined),L(t,this.props.cssClasses.disabledItem,!e.count),L(t,this.props.cssClasses.parentItem,r),t)),subItems:n,templateData:s,templateProps:this.props.templateProps})}},{key:"handleItemClick",value:function(e){var t=e.facetValueToRefine,n=e.originalEvent,r=e.isRefined;if(!(ue(n)||r&&n.target.parentNode.querySelector('input[type="radio"]:checked')))if("INPUT"!==n.target.tagName){for(var i=n.target;i!==n.currentTarget;){if("LABEL"===i.tagName&&(i.querySelector('input[type="checkbox"]')||i.querySelector('input[type="radio"]')))return;"A"===i.tagName&&i.href&&n.preventDefault(),i=i.parentNode}n.stopPropagation(),this.refine(t,r)}else this.refine(t,r)}},{key:"componentWillReceiveProps",value:function(e){this.searchBox&&!e.isFromSearch&&this.searchBox.resetInput()}},{key:"refineFirstValue",value:function(){var e=this.props.facetValues[0];if(e){var t=e.value;this.props.toggleRefinement(t)}}},{key:"render",value:function(){var t=this,e=qr(this.props.cssClasses.list,L({},"".concat(this.props.cssClasses.depth).concat(this.props.depth),this.props.cssClasses.depth)),n=qr(this.props.cssClasses.showMore,L({},this.props.cssClasses.disabledShowMore,!(!0===this.props.showMore&&this.props.canToggleShowMore))),r=!0===this.props.showMore&&vn(Ur,f({},this.props.templateProps,{templateKey:"showMoreText",rootTagName:"button",rootProps:{className:n,disabled:!this.props.canToggleShowMore,onClick:this.props.toggleShowMore},data:{isShowingMore:this.props.isShowingMore}})),i=!0!==this.props.searchIsAlwaysActive&&!(this.props.isFromSearch||!this.props.hasExhaustiveItems),a=this.props.searchFacetValues&&vn("div",{className:this.props.cssClasses.searchBox},vn(ci,{ref:function(e){return t.searchBox=e},placeholder:this.props.searchPlaceholder,disabled:i,cssClasses:this.props.cssClasses.searchable,templates:this.props.templateProps.templates,onChange:function(e){return t.props.searchFacetValues(e.target.value)},onReset:function(){return t.props.searchFacetValues("")},onSubmit:function(){return t.refineFirstValue()},searchAsYouType:!1})),s=this.props.facetValues&&0<this.props.facetValues.length&&vn("ul",{className:e},this.props.facetValues.map(this._generateFacetItem,this)),o=this.props.searchFacetValues&&this.props.isFromSearch&&0===this.props.facetValues.length&&vn(Ur,f({},this.props.templateProps,{templateKey:"searchableNoResults",rootProps:{className:this.props.cssClasses.noResults}}));return vn("div",{className:qr(this.props.cssClasses.root,L({},this.props.cssClasses.noRefinementRoot,!this.props.facetValues||0===this.props.facetValues.length),this.props.className)},this.props.children,a,s,o,r)}}]),c}();ui.defaultProps={cssClasses:{},depth:0};var li={item:'<a class="{{cssClasses.link}}" href="{{url}}"><span class="{{cssClasses.label}}">{{label}}</span><span class="{{cssClasses.count}}">{{#helpers.formatNumber}}{{count}}{{/helpers.formatNumber}}</span></a>',showMoreText:"\n    {{#isShowingMore}}\n      Show less\n    {{/isShowingMore}}\n    {{^isShowingMore}}\n      Show more\n    {{/isShowingMore}}\n  "},hi=Ae({name:"hierarchical-menu"}),fi=at("HierarchicalMenu");function di(e){var t=e.results,n=e.hits,r=e.bindEvent,i=e.cssClasses,a=e.templateProps;return 0===t.hits.length?vn(Ur,f({},a,{templateKey:"empty",rootProps:{className:qr(i.root,i.emptyRoot)},data:t})):vn("div",{className:i.root},vn("ol",{className:i.list},n.map(function(e,t){return vn(Ur,f({},a,{templateKey:"item",rootTagName:"li",rootProps:{className:i.item},key:e.objectID,data:D({},e,{__hitIndex:t}),bindEvent:r}))})))}di.defaultProps={results:{hits:[]},hits:[]};var mi={empty:"No results",item:function(e){return JSON.stringify(e,null,2)}},pi=Ae({name:"hits"}),vi=at("Hits"),gi=On(di);function yi(e){var t=e.currentValue,n=e.options,r=e.cssClasses,i=e.setValue;return vn("select",{className:qr(r.select),onChange:function(e){return i(e.target.value)},value:"".concat(t)},n.map(function(e){return vn("option",{className:qr(r.option),key:e.label+e.value,value:"".concat(e.value)},e.label)}))}var bi=Ae({name:"hits-per-page"}),Ri=at("HitsPerPage"),wi={empty:"No results",showPreviousText:"Show previous results",showMoreText:"Show more results",item:function(e){return JSON.stringify(e,null,2)}},Si=Ae({name:"infinite-hits"}),Pi=at("InfiniteHits"),_i=On(function(e){var t=e.results,n=e.hits,r=e.bindEvent,i=e.hasShowPrevious,a=e.showPrevious,s=e.showMore,o=e.isFirstPage,c=e.isLastPage,u=e.cssClasses,l=e.templateProps;return 0===t.hits.length?vn(Ur,f({},l,{templateKey:"empty",rootProps:{className:qr(u.root,u.emptyRoot)},data:t})):vn("div",{className:u.root},i&&vn(Ur,f({},l,{templateKey:"showPreviousText",rootTagName:"button",rootProps:{className:qr(u.loadPrevious,L({},u.disabledLoadPrevious,o)),disabled:o,onClick:a}})),vn("ol",{className:u.list},n.map(function(e,t){return vn(Ur,f({},l,{templateKey:"item",rootTagName:"li",rootProps:{className:u.item},key:e.objectID,data:D({},e,{__hitIndex:t}),bindEvent:r}))})),vn(Ur,f({},l,{templateKey:"showMoreText",rootTagName:"button",rootProps:{className:qr(u.loadMore,L({},u.disabledLoadMore,c)),disabled:c,onClick:s}})))}),Ni={item:'<a class="{{cssClasses.link}}" href="{{url}}"><span class="{{cssClasses.label}}">{{label}}</span><span class="{{cssClasses.count}}">{{#helpers.formatNumber}}{{count}}{{/helpers.formatNumber}}</span></a>',showMoreText:"\n    {{#isShowingMore}}\n      Show less\n    {{/isShowingMore}}\n    {{^isShowingMore}}\n      Show more\n    {{/isShowingMore}}\n  "},xi=Ae({name:"menu"}),Fi=at("Menu");var Ii={reset:'\n<svg class="{{cssClasses.resetIcon}}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="10" height="10">\n  <path d="M8.114 10L.944 2.83 0 1.885 1.886 0l.943.943L10 8.113l7.17-7.17.944-.943L20 1.886l-.943.943-7.17 7.17 7.17 7.17.943.944L18.114 20l-.943-.943-7.17-7.17-7.17 7.17-.944.943L0 18.114l.943-.943L8.113 10z"></path>\n</svg>\n  ',submit:'\n<svg class="{{cssClasses.submitIcon}}" xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 40 40">\n  <path d="M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z"></path>\n</svg>\n  ',loadingIndicator:'\n<svg class="{{cssClasses.loadingIcon}}" width="16" height="16" viewBox="0 0 38 38" xmlns="http://www.w3.org/2000/svg" stroke="#444">\n  <g fill="none" fillRule="evenodd">\n    <g transform="translate(1 1)" strokeWidth="2">\n      <circle strokeOpacity=".5" cx="18" cy="18" r="18" />\n      <path d="M36 18c0-9.94-8.06-18-18-18">\n        <animateTransform\n          attributeName="transform"\n          type="rotate"\n          from="0 18 18"\n          to="360 18 18"\n          dur="1s"\n          repeatCount="indefinite"\n        />\n      </path>\n    </g>\n  </g>\n</svg>\n  '},Ci={item:'<label class="{{cssClasses.label}}">\n  <input type="checkbox"\n         class="{{cssClasses.checkbox}}"\n         value="{{value}}"\n         {{#isRefined}}checked{{/isRefined}} />\n  <span class="{{cssClasses.labelText}}">{{#isFromSearch}}{{{highlighted}}}{{/isFromSearch}}{{^isFromSearch}}{{highlighted}}{{/isFromSearch}}</span>\n  <span class="{{cssClasses.count}}">{{#helpers.formatNumber}}{{count}}{{/helpers.formatNumber}}</span>\n</label>',showMoreText:"\n    {{#isShowingMore}}\n      Show less\n    {{/isShowingMore}}\n    {{^isShowingMore}}\n      Show more\n    {{/isShowingMore}}\n    ",searchableNoResults:"No results",searchableReset:Ii.reset,searchableSubmit:Ii.submit,searchableLoadingIndicator:Ii.loadingIndicator},Ti=Ae({name:"refinement-list"}),Ei=at("RefinementList"),ki=at("SearchBox");var Mi={item:'<label class="{{cssClasses.label}}">\n  <input type="radio" class="{{cssClasses.radio}}" name="{{attribute}}"{{#isRefined}} checked{{/isRefined}} />\n  <span class="{{cssClasses.labelText}}">{{label}}</span>\n</label>'},Li=Ae({name:"numeric-menu"}),ji=at("NumericMenu");function Oi(e){var t=e.cssClasses,n=e.label,r=e.ariaLabel,i=e.url,a=e.isDisabled,s=e.handleClick,o=e.pageNumber;return vn("li",{className:t.item},a?vn("span",{className:t.link,dangerouslySetInnerHTML:{__html:n}}):vn("a",{className:t.link,"aria-label":r,href:i,onClick:function(e){return s(o,e)},dangerouslySetInnerHTML:{__html:n}}))}var Ai=function(){function a(){var e,n;k(this,a);for(var t=arguments.length,r=new Array(t),i=0;i<t;i++)r[i]=arguments[i];return L(H(n=B(this,(e=O(a)).call.apply(e,[this].concat(r)))),"handleClick",function(e,t){ue(t)||(t.preventDefault(),n.props.setCurrentPage(e))}),n}return j(a,bn),M(a,[{key:"pageLink",value:function(e){var t=e.label,n=e.ariaLabel,r=e.pageNumber,i=e.additionalClassName,a=void 0===i?null:i,s=e.isDisabled,o=void 0!==s&&s,c=e.isSelected,u=void 0!==c&&c,l=e.createURL,h={item:qr(this.props.cssClasses.item,a),link:this.props.cssClasses.link};o?h.item=qr(h.item,this.props.cssClasses.disabledItem):u&&(h.item=qr(h.item,this.props.cssClasses.selectedItem));var f=l&&!o?l(r):"#";return vn(Oi,{ariaLabel:n,cssClasses:h,handleClick:this.handleClick,isDisabled:o,key:t+r+n,label:t,pageNumber:r,url:f})}},{key:"previousPageLink",value:function(e){var t=e.isFirstPage,n=e.currentPage,r=e.createURL;return this.pageLink({ariaLabel:"Previous",additionalClassName:this.props.cssClasses.previousPageItem,isDisabled:t,label:this.props.templates.previous,pageNumber:n-1,createURL:r})}},{key:"nextPageLink",value:function(e){var t=e.isLastPage,n=e.currentPage,r=e.createURL;return this.pageLink({ariaLabel:"Next",additionalClassName:this.props.cssClasses.nextPageItem,isDisabled:t,label:this.props.templates.next,pageNumber:n+1,createURL:r})}},{key:"firstPageLink",value:function(e){var t=e.isFirstPage,n=e.createURL;return this.pageLink({ariaLabel:"First",additionalClassName:this.props.cssClasses.firstPageItem,isDisabled:t,label:this.props.templates.first,pageNumber:0,createURL:n})}},{key:"lastPageLink",value:function(e){var t=e.isLastPage,n=e.nbPages,r=e.createURL;return this.pageLink({ariaLabel:"Last",additionalClassName:this.props.cssClasses.lastPageItem,isDisabled:t,label:this.props.templates.last,pageNumber:n-1,createURL:r})}},{key:"pages",value:function(e){var t=this,n=e.currentPage,r=e.pages,i=e.createURL;return r.map(function(e){return t.pageLink({ariaLabel:e+1,additionalClassName:t.props.cssClasses.pageItem,isSelected:e===n,label:e+1,pageNumber:e,createURL:i})})}},{key:"render",value:function(){return vn("div",{className:qr(this.props.cssClasses.root,L({},this.props.cssClasses.noRefinementRoot,this.props.nbPages<=1))},vn("ul",{className:this.props.cssClasses.list},this.props.showFirst&&this.firstPageLink(this.props),this.props.showPrevious&&this.previousPageLink(this.props),this.pages(this.props),this.props.showNext&&this.nextPageLink(this.props),this.props.showLast&&this.lastPageLink(this.props)))}}]),a}();Ai.defaultProps={nbHits:0,currentPage:0,nbPages:0};var Hi=Ae({name:"pagination"}),Di=at("Pagination"),Bi={previous:"‹",next:"›",first:"«",last:"»"};var Qi=function(){function t(e){var n;return k(this,t),L(H(n=B(this,O(t).call(this,e))),"onInput",function(t){return function(e){n.setState(L({},t,e.currentTarget.value))}}),L(H(n),"onSubmit",function(e){e.preventDefault(),n.props.refine([n.state.min&&Number(n.state.min),n.state.max&&Number(n.state.max)])}),n.state={min:e.values.min,max:e.values.max},n}return j(t,bn),M(t,[{key:"componentWillReceiveProps",value:function(e){this.setState({min:e.values.min,max:e.values.max})}},{key:"render",value:function(){var e=this.state,t=e.min,n=e.max,r=this.props,i=r.min,a=r.max,s=r.step,o=r.cssClasses,c=r.templateProps,u=a<=i,l=Boolean(t||n);return vn("div",{className:qr(o.root,L({},o.noRefinement,!l))},vn("form",{className:o.form,onSubmit:this.onSubmit},vn("label",{className:o.label},vn("input",{className:qr(o.input,o.inputMin),type:"number",min:i,max:a,step:s,value:null!=t?t:"",onInput:this.onInput("min"),placeholder:i,disabled:u})),vn(Ur,f({},c,{templateKey:"separatorText",rootTagName:"span",rootProps:{className:o.separator}})),vn("label",{className:o.label},vn("input",{className:qr(o.input,o.inputMax),type:"number",min:i,max:a,step:s,value:null!=n?n:"",onInput:this.onInput("max"),placeholder:a,disabled:u})),vn(Ur,f({},c,{templateKey:"submitText",rootTagName:"button",rootProps:{type:"submit",className:o.submit,disabled:u}}))))}}]),t}(),qi=Ae({name:"range-input"}),Ui=at("RangeInput");var Vi=Ae({name:"search-box"}),Wi=at("SearchBox");var $i=40,zi=35,Ki=27,Ji=36,Yi=37,Gi=34,Xi=33,Zi=39,ea=38,ta=100;function na(e,t,n){return(e-t)/(n-t)*100}function ra(e,t,n){var r=e/100;return 0===e?t:100===e?n:Math.round((n-t)*r+t)}function ia(e){return["rheostat","vertical"===e.orientation?"rheostat-vertical":"rheostat-horizontal"].concat(e.className.split(" ")).join(" ")}function aa(e){return Number(e.currentTarget.getAttribute("data-handle-key"))}function sa(e){e.stopPropagation(),e.preventDefault()}var oa=function(){function e(){return k(this,e),B(this,O(e).apply(this,arguments))}return j(e,bn),M(e,[{key:"render",value:function(){return vn("button",f({},this.props,{type:"button"}))}}]),e}(),ca=vn("div",{className:"rheostat-background"}),ua=function(){function n(e){var t;return k(this,n),L(H(t=B(this,O(n).call(this,e))),"state",{className:ia(t.props),handlePos:t.props.values.map(function(e){return na(e,t.props.min,t.props.max)}),handleDimensions:0,mousePos:null,sliderBox:{},slidingIndex:null,values:t.props.values}),t.getPublicState=t.getPublicState.bind(H(t)),t.getSliderBoundingBox=t.getSliderBoundingBox.bind(H(t)),t.getProgressStyle=t.getProgressStyle.bind(H(t)),t.getMinValue=t.getMinValue.bind(H(t)),t.getMaxValue=t.getMaxValue.bind(H(t)),t.getHandleDimensions=t.getHandleDimensions.bind(H(t)),t.getClosestSnapPoint=t.getClosestSnapPoint.bind(H(t)),t.getSnapPosition=t.getSnapPosition.bind(H(t)),t.getNextPositionForKey=t.getNextPositionForKey.bind(H(t)),t.getNextState=t.getNextState.bind(H(t)),t.handleClick=t.handleClick.bind(H(t)),t.getClosestHandle=t.getClosestHandle.bind(H(t)),t.setStartSlide=t.setStartSlide.bind(H(t)),t.startMouseSlide=t.startMouseSlide.bind(H(t)),t.startTouchSlide=t.startTouchSlide.bind(H(t)),t.handleMouseSlide=t.handleMouseSlide.bind(H(t)),t.handleTouchSlide=t.handleTouchSlide.bind(H(t)),t.handleSlide=t.handleSlide.bind(H(t)),t.endSlide=t.endSlide.bind(H(t)),t.handleKeydown=t.handleKeydown.bind(H(t)),t.validatePosition=t.validatePosition.bind(H(t)),t.validateValues=t.validateValues.bind(H(t)),t.canMove=t.canMove.bind(H(t)),t.fireChangeEvent=t.fireChangeEvent.bind(H(t)),t.slideTo=t.slideTo.bind(H(t)),t.updateNewValues=t.updateNewValues.bind(H(t)),t}return j(n,bn),M(n,[{key:"componentWillReceiveProps",value:function(n){var e=this.props,t=e.className,r=e.disabled,i=e.min,a=e.max,s=e.orientation,o=this.state,c=o.values,u=o.slidingIndex,l=n.min!==i||n.max!==a,h=c.length!==n.values.length||c.some(function(e,t){return n.values[t]!==e}),f=n.className!==t||n.orientation!==s,d=n.disabled&&!r;f&&this.setState({className:ia(n)}),(l||h)&&this.updateNewValues(n),d&&null!==u&&this.endSlide()}},{key:"getPublicState",value:function(){var e=this.props,t=e.min;return{max:e.max,min:t,values:this.state.values}}},{key:"getSliderBoundingBox",value:function(){var e=this.rheostat.getDOMNode?this.rheostat.getDOMNode():this.rheostat,t=e.getBoundingClientRect();return{height:t.height||e.clientHeight,left:t.left,top:t.top,width:t.width||e.clientWidth}}},{key:"getProgressStyle",value:function(e){var t=this.state.handlePos,n=t[e];if(0===e)return"vertical"===this.props.orientation?{height:"".concat(n,"%"),top:0}:{left:0,width:"".concat(n,"%")};var r=t[e-1],i=n-r;return"vertical"===this.props.orientation?{height:"".concat(i,"%"),top:"".concat(r,"%")}:{left:"".concat(r,"%"),width:"".concat(i,"%")}}},{key:"getMinValue",value:function(e){return this.state.values[e-1]?Math.max(this.props.min,this.state.values[e-1]):this.props.min}},{key:"getMaxValue",value:function(e){return this.state.values[e+1]?Math.min(this.props.max,this.state.values[e+1]):this.props.max}},{key:"getHandleDimensions",value:function(e,t){var n=e.currentTarget||null;return n?"vertical"===this.props.orientation?n.clientHeight/t.height*ta/2:n.clientWidth/t.width*ta/2:0}},{key:"getClosestSnapPoint",value:function(n){return this.props.snapPoints.length?this.props.snapPoints.reduce(function(e,t){return Math.abs(e-n)<Math.abs(t-n)?e:t}):n}},{key:"getSnapPosition",value:function(e){if(!this.props.snap)return e;var t=this.props,n=t.max,r=t.min,i=ra(e,r,n);return na(this.getClosestSnapPoint(i),r,n)}},{key:"getNextPositionForKey",value:function(e,t){var n,r=this.state,i=r.handlePos,a=r.values,s=this.props,o=s.max,c=s.min,u=s.snapPoints,l=this.props.snap,h=a[e],f=i[e],d=f,m=1;100<=o?f=Math.round(f):m=100/(o-c);var p=null;l&&(p=u.indexOf(this.getClosestSnapPoint(a[e])));var v=(L(n={},Yi,function(e){return-1*e}),L(n,Zi,function(e){return e}),L(n,ea,function(e){return e}),L(n,$i,function(e){return-1*e}),L(n,Gi,function(e){return 1<e?-e:-10*e}),L(n,Xi,function(e){return 1<e?e:10*e}),n);if(Object.prototype.hasOwnProperty.call(v,t))f+=v[t](m),l&&(d<f?p<u.length-1&&(h=u[p+1]):0<p&&(h=u[p-1]));else if(t===Ji)f=0,l&&(h=u[0]);else{if(t!==zi)return null;f=ta,l&&(h=u[u.length-1])}return l?na(h,c,o):f}},{key:"getNextState",value:function(n,e){var t=this.state.handlePos,r=this.props,i=r.max,a=r.min,s=this.validatePosition(n,e),o=t.map(function(e,t){return t===n?s:e});return{handlePos:o,values:o.map(function(e){return ra(e,a,i)})}}},{key:"getClosestHandle",value:function(r){var i=this.state.handlePos;return i.reduce(function(e,t,n){return Math.abs(i[n]-r)<Math.abs(i[e]-r)?n:e},0)}},{key:"setStartSlide",value:function(e,t,n){var r=this.getSliderBoundingBox();this.setState({handleDimensions:this.getHandleDimensions(e,r),mousePos:{x:t,y:n},sliderBox:r,slidingIndex:aa(e)})}},{key:"startMouseSlide",value:function(e){this.setStartSlide(e,e.clientX,e.clientY),"function"==typeof document.addEventListener?(document.addEventListener("mousemove",this.handleMouseSlide,!1),document.addEventListener("mouseup",this.endSlide,!1)):(document.attachEvent("onmousemove",this.handleMouseSlide),document.attachEvent("onmouseup",this.endSlide)),sa(e)}},{key:"startTouchSlide",value:function(e){if(!(1<e.changedTouches.length)){var t=e.changedTouches[0];this.setStartSlide(e,t.clientX,t.clientY),document.addEventListener("touchmove",this.handleTouchSlide,!1),document.addEventListener("touchend",this.endSlide,!1),this.props.onSliderDragStart&&this.props.onSliderDragStart(),sa(e)}}},{key:"handleMouseSlide",value:function(e){null!==this.state.slidingIndex&&(this.handleSlide(e.clientX,e.clientY),sa(e))}},{key:"handleTouchSlide",value:function(e){if(null!==this.state.slidingIndex)if(1<e.changedTouches.length)this.endSlide();else{var t=e.changedTouches[0];this.handleSlide(t.clientX,t.clientY),sa(e)}}},{key:"handleSlide",value:function(e,t){var n=this.state,r=n.slidingIndex,i=n.sliderBox,a="vertical"===this.props.orientation?(t-i.top)/i.height*ta:(e-i.left)/i.width*ta;this.slideTo(r,a),this.canMove(r,a)&&(this.setState({x:e,y:t}),this.props.onSliderDragMove&&this.props.onSliderDragMove())}},{key:"endSlide",value:function(){var e=this,t=this.state.slidingIndex;if(this.setState({slidingIndex:null}),"function"==typeof document.removeEventListener?(document.removeEventListener("mouseup",this.endSlide,!1),document.removeEventListener("touchend",this.endSlide,!1),document.removeEventListener("touchmove",this.handleTouchSlide,!1),document.removeEventListener("mousemove",this.handleMouseSlide,!1)):(document.detachEvent("onmousemove",this.handleMouseSlide),document.detachEvent("onmouseup",this.endSlide)),this.props.onSliderDragEnd&&this.props.onSliderDragEnd(),this.props.snap){var n=this.getSnapPosition(this.state.handlePos[t]);this.slideTo(t,n,function(){return e.fireChangeEvent()})}else this.fireChangeEvent()}},{key:"handleClick",value:function(e){var t=this;if(!e.target.getAttribute("data-handle-key")){var n=this.getSliderBoundingBox(),r=("vertical"===this.props.orientation?(e.clientY-n.top)/n.height:(e.clientX-n.left)/n.width)*ta,i=this.getClosestHandle(r),a=this.getSnapPosition(r);this.slideTo(i,a,function(){return t.fireChangeEvent()}),this.props.onClick&&this.props.onClick()}}},{key:"handleKeydown",value:function(e){var t=this,n=aa(e);if(e.keyCode!==Ki){var r=this.getNextPositionForKey(n,e.keyCode);null!==r&&(this.canMove(n,r)&&(this.slideTo(n,r,function(){return t.fireChangeEvent()}),this.props.onKeyPress&&this.props.onKeyPress()),sa(e))}else e.currentTarget.blur()}},{key:"validatePosition",value:function(e,t){var n=this.state,r=n.handlePos,i=n.handleDimensions;return Math.max(Math.min(t,void 0!==r[e+1]?r[e+1]-i:ta),void 0!==r[e-1]?r[e-1]+i:0)}},{key:"validateValues",value:function(e,t){var n=t||this.props,i=n.max,a=n.min;return e.map(function(e,t,n){var r=Math.max(Math.min(e,i),a);return n.length&&r<n[t-1]?n[t-1]:r})}},{key:"canMove",value:function(e,t){var n=this.state,r=n.handlePos,i=n.handleDimensions;return!(t<0)&&(!(ta<t)&&(!((void 0!==r[e+1]?r[e+1]-i:1/0)<t)&&!(t<(void 0!==r[e-1]?r[e-1]+i:-1/0))))}},{key:"fireChangeEvent",value:function(){var e=this.props.onChange;e&&e(this.getPublicState())}},{key:"slideTo",value:function(e,t,n){var r=this,i=this.getNextState(e,t);this.setState(i,function(){var e=r.props.onValuesUpdated;e&&e(r.getPublicState()),n&&n()})}},{key:"updateNewValues",value:function(e){var t=this;if(null===this.state.slidingIndex){var n=e.max,r=e.min,i=e.values,a=this.validateValues(i,e);this.setState({handlePos:a.map(function(e){return na(e,r,n)}),values:a},function(){return t.fireChangeEvent()})}}},{key:"render",value:function(){var r=this,e=this.props,t=e.children,i=e.disabled,a=e.handle,s=e.max,o=e.min,c=e.orientation,u=e.pitComponent,n=e.pitPoints,l=e.progressBar,h=this.state,f=h.className,d=h.handlePos,m=h.values;return vn("div",{className:f,ref:function(e){r.rheostat=e},onClick:!i&&this.handleClick,style:{position:"relative"}},ca,d.map(function(e,t){var n="vertical"===c?{top:"".concat(e,"%"),position:"absolute"}:{left:"".concat(e,"%"),position:"absolute"};return vn(a,{"aria-valuemax":r.getMaxValue(t),"aria-valuemin":r.getMinValue(t),"aria-valuenow":m[t],"aria-disabled":i,"data-handle-key":t,className:"rheostat-handle",key:"handle-".concat(t),onClick:r.killEvent,onKeyDown:!i&&r.handleKeydown,onMouseDown:!i&&r.startMouseSlide,onTouchStart:!i&&r.startTouchSlide,role:"slider",style:n,tabIndex:0})}),d.map(function(e,t,n){return 0===t&&1<n.length?null:vn(l,{className:"rheostat-progress",key:"progress-bar-".concat(t),style:r.getProgressStyle(t)})}),u&&n.map(function(e){var t=na(e,o,s),n="vertical"===c?{top:"".concat(t,"%"),position:"absolute"}:{left:"".concat(t,"%"),position:"absolute"};return vn(u,{key:"pit-".concat(e),style:n},e)}),t)}}]),n}();L(ua,"defaultProps",{className:"",children:null,disabled:!1,handle:oa,max:ta,min:0,onClick:null,onChange:null,onKeyPress:null,onSliderDragEnd:null,onSliderDragMove:null,onSliderDragStart:null,onValuesUpdated:null,orientation:"horizontal",pitComponent:null,pitPoints:[],progressBar:"div",snap:!1,snapPoints:[],values:[0]});function la(e){var t=e.style,n=e.children,r=Math.round(parseFloat(t.left)),i=[0,50,100].includes(r),a=Array.isArray(n)?n[0]:n,s=Math.round(100*parseInt(a,10))/100;return vn("div",{style:D({},t,{marginLeft:100===r?"-2px":0}),className:qr("rheostat-marker","rheostat-marker-horizontal",{"rheostat-marker-large":i})},i&&vn("div",{className:"rheostat-value"},s))}var ha=function(){function a(){var e,n;k(this,a);for(var t=arguments.length,r=new Array(t),i=0;i<t;i++)r[i]=arguments[i];return L(H(n=B(this,(e=O(a)).call.apply(e,[this].concat(r)))),"handleChange",function(e){var t=e.values;n.isDisabled||n.props.refine(t)}),L(H(n),"createHandleComponent",function(r){return function(e){var t=Math.round(100*parseFloat(e["aria-valuenow"]))/100,n=r&&r.format?r.format(t):t;return vn("div",f({},e,{className:qr(e.className,{"rheostat-handle-lower":0===e["data-handle-key"],"rheostat-handle-upper":1===e["data-handle-key"]})}),r&&vn("div",{className:"rheostat-tooltip"},n))}}),n}return j(a,bn),M(a,[{key:"computeDefaultPitPoints",value:function(e){var t=e.min,n=e.max,r=(n-t)/34;return[t].concat(_(Ie({end:33}).map(function(e){return t+r*(e+1)})),[n])}},{key:"computeSnapPoints",value:function(e){var t=e.min,n=e.max,r=e.step;if(r)return[].concat(_(Ie({start:t,end:n,step:r})),[n])}},{key:"render",value:function(){var e=this.props,t=e.tooltips,n=e.step,r=e.pips,i=e.values,a=e.cssClasses,s=this.isDisabled?{min:this.props.min,max:this.props.max+.001}:this.props,o=s.min,c=s.max,u=this.computeSnapPoints({min:o,max:c,step:n}),l=!1===r?[]:this.computeDefaultPitPoints({min:o,max:c});return vn("div",{className:qr(a.root,L({},a.disabledRoot,this.isDisabled))},vn(ua,{handle:this.createHandleComponent(t),onChange:this.handleChange,min:o,max:c,pitComponent:la,pitPoints:l,snap:!0,snapPoints:u,values:this.isDisabled?[o,c]:i,disabled:this.isDisabled}))}},{key:"isDisabled",get:function(){return this.props.min>=this.props.max}}]),a}(),fa=Ae({name:"range-slider"}),da=at("RangeSlider");var ma=Ae({name:"sort-by"}),pa=at("SortBy");var va={item:'{{#count}}<a class="{{cssClasses.link}}" aria-label="{{value}} & up" href="{{href}}">{{/count}}{{^count}}<div class="{{cssClasses.link}}" aria-label="{{value}} & up" disabled>{{/count}}\n  {{#stars}}<svg class="{{cssClasses.starIcon}} {{#.}}{{cssClasses.fullStarIcon}}{{/.}}{{^.}}{{cssClasses.emptyStarIcon}}{{/.}}" aria-hidden="true" width="24" height="24">\n    {{#.}}<use xlink:href="#ais-RatingMenu-starSymbol"></use>{{/.}}{{^.}}<use xlink:href="#ais-RatingMenu-starEmptySymbol"></use>{{/.}}\n  </svg>{{/stars}}\n  <span class="{{cssClasses.label}}">& Up</span>\n  {{#count}}<span class="{{cssClasses.count}}">{{#helpers.formatNumber}}{{count}}{{/helpers.formatNumber}}</span>{{/count}}\n{{#count}}</a>{{/count}}{{^count}}</div>{{/count}}'},ga=Ae({name:"rating-menu"}),ya=at("RatingMenu"),ba=vn("path",{d:"M12 .288l2.833 8.718h9.167l-7.417 5.389 2.833 8.718-7.416-5.388-7.417 5.388 2.833-8.718-7.416-5.389h9.167z"}),Ra=vn("path",{d:"M12 6.76l1.379 4.246h4.465l-3.612 2.625 1.379 4.246-3.611-2.625-3.612 2.625 1.379-4.246-3.612-2.625h4.465l1.38-4.246zm0-6.472l-2.833 8.718h-9.167l7.416 5.389-2.833 8.718 7.417-5.388 7.416 5.388-2.833-8.718 7.417-5.389h-9.167l-2.833-8.718z"});function wa(e){var t=e.nbHits,n=e.hitsPerPage,r=e.nbPages,i=e.page,a=e.processingTimeMS,s=e.query,o=e.templateProps,c=e.cssClasses;return vn("div",{className:c.root},vn(Ur,f({},o,{templateKey:"text",rootTagName:"span",rootProps:{className:c.text},data:{hasManyResults:1<t,hasNoResults:0===t,hasOneResult:1===t,hitsPerPage:n,nbHits:t,nbPages:r,page:i,processingTimeMS:a,query:s,cssClasses:c}})))}var Sa={text:"{{#hasNoResults}}No results{{/hasNoResults}}\n    {{#hasOneResult}}1 result{{/hasOneResult}}\n    {{#hasManyResults}}{{#helpers.formatNumber}}{{nbHits}}{{/helpers.formatNumber}} results{{/hasManyResults}} found in {{processingTimeMS}}ms"},Pa=Ae({name:"stats"}),_a=at("Stats");function Na(e){var t=e.currentRefinement,n=e.refine,r=e.cssClasses,i=e.templateProps;return vn("div",{className:r.root},vn("label",{className:r.label},vn("input",{className:r.checkbox,type:"checkbox",checked:t.isRefined,onChange:function(e){return n(!e.target.checked)}}),vn(Ur,f({},i,{rootTagName:"span",rootProps:{className:r.labelText},templateKey:"labelText",data:t}))))}var xa={labelText:"{{name}}"},Fa=Ae({name:"toggle-refinement"}),Ia=at("ToggleRefinement");function Ca(e){var r=e.items,i=e.cssClasses,a=e.templateProps,s=e.createURL,o=e.refine;return vn("div",{className:qr(i.root,L({},i.noRefinementRoot,0===r.length))},vn("ul",{className:i.list},vn("li",{className:qr(i.item,L({},i.selectedItem,0===r.length))},vn(Ur,f({},a,{templateKey:"home",rootTagName:"a",rootProps:{className:i.link,href:s(void 0),onClick:function(e){e.preventDefault(),o(void 0)}}}))),r.map(function(t,e){var n=e===r.length-1;return vn("li",{key:t.label+e,className:qr(i.item,L({},i.selectedItem,n))},vn(Ur,f({},a,{templateKey:"separator",rootTagName:"span",rootProps:{className:i.separator,"aria-hidden":!0}})),n?t.label:vn("a",{className:i.link,href:s(t.value),onClick:function(e){e.preventDefault(),o(t.value)}},t.label))})))}var Ta=Ae({name:"analytics"}),Ea={home:"Home",separator:">"},ka=Ae({name:"breadcrumb"}),Ma=at("Breadcrumb");function La(e){var t=e.cssClasses,n=e.templateProps,r=e.items,i=e.refine,a=(ge(r,function(e){return e.isRefined})||{value:""}).value;return vn("div",{className:qr(t.root,L({},t.noRefinementRoot,0===r.length))},vn("select",{className:t.select,value:a,onChange:function(e){i(e.target.value)}},vn(Ur,f({},n,{templateKey:"defaultOption",rootTagName:"option",rootProps:{value:"",className:t.option}})),r.map(function(e){return vn(Ur,f({},n,{templateKey:"item",rootTagName:"option",rootProps:{value:e.value,className:t.option},key:e.value,data:e}))})))}var ja={item:"{{label}} ({{#helpers.formatNumber}}{{count}}{{/helpers.formatNumber}})",defaultOption:"See all"},Oa=Ae({name:"menu-select"}),Aa=at("MenuSelect");function Ha(e){var t=e.url,n=e.theme,r=e.cssClasses;return vn("div",{className:r.root},vn("a",{href:t,target:"_blank",className:r.link,"aria-label":"Search by Algolia",rel:"noopener noreferrer"},vn("svg",{height:"1.2em",className:r.logo,viewBox:"0 0 168 24",style:{width:"auto"}},vn("path",{fill:"dark"===n?"#FFF":"#5D6494",d:"M6.97 6.68V8.3a4.47 4.47 0 0 0-2.42-.67 2.2 2.2 0 0 0-1.38.4c-.34.26-.5.6-.5 1.02 0 .43.16.77.49 1.03.33.25.83.53 1.51.83a7.04 7.04 0 0 1 1.9 1.08c.34.24.58.54.73.89.15.34.23.74.23 1.18 0 .95-.33 1.7-1 2.24a4 4 0 0 1-2.6.81 5.71 5.71 0 0 1-2.94-.68v-1.71c.84.63 1.81.94 2.92.94.58 0 1.05-.14 1.39-.4.34-.28.5-.65.5-1.13 0-.29-.1-.55-.3-.8a2.2 2.2 0 0 0-.65-.53 23.03 23.03 0 0 0-1.64-.78 13.67 13.67 0 0 1-1.11-.64c-.12-.1-.28-.22-.46-.4a1.72 1.72 0 0 1-.39-.5 4.46 4.46 0 0 1-.22-.6c-.07-.23-.1-.48-.1-.75 0-.91.33-1.63 1-2.17a4 4 0 0 1 2.57-.8c.97 0 1.8.18 2.47.52zm7.47 5.7v-.3a2.26 2.26 0 0 0-.5-1.44c-.3-.35-.74-.53-1.32-.53-.53 0-.99.2-1.37.58-.38.39-.62.95-.72 1.68h3.91zm1 2.79v1.4c-.6.34-1.38.51-2.36.51a4.02 4.02 0 0 1-3-1.13 4.04 4.04 0 0 1-1.11-2.97c0-1.3.34-2.32 1.02-3.06a3.38 3.38 0 0 1 2.6-1.1c1.03 0 1.85.32 2.46.96.6.64.9 1.57.9 2.78 0 .33-.03.68-.09 1.04h-5.31c.1.7.4 1.24.89 1.61.49.38 1.1.56 1.85.56.86 0 1.58-.2 2.15-.6zm6.61-1.78h-1.21c-.6 0-1.05.12-1.35.36-.3.23-.46.53-.46.89 0 .37.12.66.36.88.23.2.57.32 1.02.32.5 0 .9-.15 1.2-.43.3-.28.44-.65.44-1.1v-.92zm-4.07-2.55V9.33a4.96 4.96 0 0 1 2.5-.55c2.1 0 3.17 1.03 3.17 3.08V17H22.1v-.96c-.42.68-1.15 1.02-2.19 1.02-.76 0-1.38-.22-1.84-.66-.46-.44-.7-1-.7-1.68 0-.78.3-1.38.88-1.81.59-.43 1.4-.65 2.46-.65h1.34v-.46c0-.55-.13-.97-.4-1.25-.26-.29-.7-.43-1.32-.43-.86 0-1.65.24-2.35.72zm9.34-1.93v1.42c.39-1 1.1-1.5 2.12-1.5.15 0 .31.02.5.05v1.53c-.23-.1-.48-.14-.76-.14-.54 0-.99.24-1.34.71a2.8 2.8 0 0 0-.52 1.71V17h-1.57V8.91h1.57zm5 4.09a3 3 0 0 0 .76 2.01c.47.53 1.14.8 2 .8.64 0 1.24-.18 1.8-.53v1.4c-.53.32-1.2.48-2 .48a3.98 3.98 0 0 1-4.17-4.18c0-1.16.38-2.15 1.14-2.98a4 4 0 0 1 3.1-1.23c.7 0 1.34.15 1.92.44v1.44a3.24 3.24 0 0 0-1.77-.5A2.65 2.65 0 0 0 32.33 13zm7.92-7.28v4.58c.46-1 1.3-1.5 2.5-1.5.8 0 1.42.24 1.9.73.48.5.72 1.17.72 2.05V17H43.8v-5.1c0-.56-.14-.99-.43-1.29-.28-.3-.65-.45-1.1-.45-.54 0-1 .2-1.42.6-.4.4-.61 1.02-.61 1.85V17h-1.56V5.72h1.56zM55.2 15.74c.6 0 1.1-.25 1.5-.76.4-.5.6-1.16.6-1.95 0-.92-.2-1.62-.6-2.12-.4-.5-.92-.74-1.55-.74-.56 0-1.05.22-1.5.67-.44.45-.66 1.13-.66 2.06 0 .96.22 1.67.64 2.14.43.47.95.7 1.57.7zM53 5.72v4.42a2.74 2.74 0 0 1 2.43-1.34c1.03 0 1.86.38 2.51 1.15.65.76.97 1.78.97 3.05 0 1.13-.3 2.1-.92 2.9-.62.81-1.47 1.21-2.54 1.21s-1.9-.45-2.46-1.34V17h-1.58V5.72H53zm9.9 11.1l-3.22-7.9h1.74l1 2.62 1.26 3.42c.1-.32.48-1.46 1.15-3.42l.91-2.63h1.66l-2.92 7.87c-.78 2.07-1.96 3.1-3.56 3.1-.28 0-.53-.02-.73-.07v-1.34c.17.04.35.06.54.06 1.03 0 1.76-.57 2.17-1.7z"}),Da,Ba,vn("path",{fill:"dark"===n?"#FFF":"#5468FF",d:"M120.92 18.8c-4.38.02-4.38-3.54-4.38-4.1V1.36l2.67-.42v13.25c0 .32 0 2.36 1.71 2.37v2.24zm-10.84-2.18c.82 0 1.43-.04 1.85-.12v-2.72a5.48 5.48 0 0 0-1.57-.2c-.3 0-.6.02-.9.07-.3.04-.57.12-.81.24-.24.11-.44.28-.58.49a.93.93 0 0 0-.22.65c0 .63.22 1 .61 1.23.4.24.94.36 1.62.36zm-.23-9.7c.88 0 1.62.11 2.23.33.6.22 1.09.53 1.44.92.36.4.61.92.76 1.48.16.56.23 1.17.23 1.85v6.87c-.4.1-1.03.2-1.86.32-.84.12-1.78.18-2.82.18-.69 0-1.32-.07-1.9-.2a4 4 0 0 1-1.46-.63c-.4-.3-.72-.67-.96-1.13a4.3 4.3 0 0 1-.34-1.8c0-.66.13-1.08.39-1.53.26-.45.6-.82 1.04-1.1.45-.3.95-.5 1.54-.62a8.8 8.8 0 0 1 3.79.05v-.44c0-.3-.04-.6-.11-.87a1.78 1.78 0 0 0-1.1-1.22c-.31-.12-.7-.2-1.15-.2a9.75 9.75 0 0 0-2.95.46l-.33-2.19c.34-.12.84-.23 1.48-.35.65-.12 1.34-.18 2.08-.18zm52.84 9.63c.82 0 1.43-.05 1.85-.13V13.7a5.42 5.42 0 0 0-1.57-.2c-.3 0-.6.02-.9.07-.3.04-.57.12-.81.24-.24.12-.44.28-.58.5a.93.93 0 0 0-.22.65c0 .63.22.99.61 1.23.4.24.94.36 1.62.36zm-.23-9.7c.88 0 1.63.11 2.23.33.6.22 1.1.53 1.45.92.35.39.6.92.76 1.48.15.56.23 1.18.23 1.85v6.88c-.41.08-1.03.19-1.87.31-.83.12-1.77.18-2.81.18-.7 0-1.33-.06-1.9-.2a4 4 0 0 1-1.47-.63c-.4-.3-.72-.67-.95-1.13a4.3 4.3 0 0 1-.34-1.8c0-.66.13-1.08.38-1.53.26-.45.61-.82 1.05-1.1.44-.3.95-.5 1.53-.62a8.8 8.8 0 0 1 3.8.05v-.43c0-.31-.04-.6-.12-.88-.07-.28-.2-.52-.38-.73a1.78 1.78 0 0 0-.73-.5c-.3-.1-.68-.2-1.14-.2a9.85 9.85 0 0 0-2.95.47l-.32-2.19a11.63 11.63 0 0 1 3.55-.53zm-8.03-1.27a1.62 1.62 0 0 0 0-3.24 1.62 1.62 0 1 0 0 3.24zm1.35 13.22h-2.7V7.27l2.7-.42V18.8zm-4.72 0c-4.38.02-4.38-3.54-4.38-4.1l-.01-13.34 2.67-.42v13.25c0 .32 0 2.36 1.72 2.37v2.24zm-8.7-5.9a4.7 4.7 0 0 0-.74-2.79 2.4 2.4 0 0 0-2.07-1 2.4 2.4 0 0 0-2.06 1 4.7 4.7 0 0 0-.74 2.8c0 1.16.25 1.94.74 2.62a2.4 2.4 0 0 0 2.07 1.02c.88 0 1.57-.34 2.07-1.02.49-.68.73-1.46.73-2.63zm2.74 0a6.46 6.46 0 0 1-1.52 4.23c-.49.53-1.07.94-1.76 1.22-.68.29-1.73.45-2.26.45-.53 0-1.58-.15-2.25-.45a5.1 5.1 0 0 1-2.88-3.13 7.3 7.3 0 0 1-.01-4.84 5.13 5.13 0 0 1 2.9-3.1 5.67 5.67 0 0 1 2.22-.42c.81 0 1.56.14 2.24.42.69.29 1.28.69 1.75 1.22.49.52.87 1.15 1.14 1.89a7 7 0 0 1 .43 2.5zm-20.14 0c0 1.11.25 2.36.74 2.88.5.52 1.13.78 1.91.78a4.07 4.07 0 0 0 2.12-.6V9.33c-.19-.04-.99-.2-1.76-.23a2.67 2.67 0 0 0-2.23 1 4.73 4.73 0 0 0-.78 2.8zm7.44 5.27c0 1.82-.46 3.16-1.4 4-.94.85-2.37 1.27-4.3 1.27-.7 0-2.17-.13-3.34-.4l.43-2.11c.98.2 2.27.26 2.95.26 1.08 0 1.84-.22 2.3-.66.46-.43.68-1.08.68-1.94v-.44a5.2 5.2 0 0 1-2.54.6 5.6 5.6 0 0 1-2.01-.36 4.2 4.2 0 0 1-2.58-2.71 9.88 9.88 0 0 1 .02-5.35 4.92 4.92 0 0 1 2.93-2.96 6.6 6.6 0 0 1 2.43-.46 19.64 19.64 0 0 1 4.43.66v10.6z"}))))}var Da=vn("path",{fill:"#5468FF",d:"M78.99.94h16.6a2.97 2.97 0 0 1 2.96 2.96v16.6a2.97 2.97 0 0 1-2.97 2.96h-16.6a2.97 2.97 0 0 1-2.96-2.96V3.9A2.96 2.96 0 0 1 79 .94"}),Ba=vn("path",{fill:"#FFF",d:"M89.63 5.97v-.78a.98.98 0 0 0-.98-.97h-2.28a.98.98 0 0 0-.97.97V6c0 .09.08.15.17.13a7.13 7.13 0 0 1 3.9-.02c.08.02.16-.04.16-.13m-6.25 1L83 6.6a.98.98 0 0 0-1.38 0l-.46.46a.97.97 0 0 0 0 1.38l.38.39c.06.06.15.04.2-.02a7.49 7.49 0 0 1 1.63-1.62c.07-.04.08-.14.02-.2m4.16 2.45v3.34c0 .1.1.17.2.12l2.97-1.54c.06-.03.08-.12.05-.18a3.7 3.7 0 0 0-3.08-1.87c-.07 0-.14.06-.14.13m0 8.05a4.49 4.49 0 1 1 0-8.98 4.49 4.49 0 0 1 0 8.98m0-10.85a6.37 6.37 0 1 0 0 12.74 6.37 6.37 0 0 0 0-12.74"}),Qa=at("PoweredBy"),qa=Ae({name:"powered-by"});var Ua,Va,Wa=[],$a=sn.__r;sn.__r=function(e){$a&&$a(e),Ua=0,(Va=e.__c).__H&&(Va.__H.t=ts(Va.__H.t))};var za=sn.diffed;sn.diffed=function(e){za&&za(e);var t=e.__c;if(t){var n=t.__H;n&&(n.u=(n.u.some(function(e){e.ref&&(e.ref.current=e.createHandle())}),[]),n.i=ts(n.i))}};var Ka=sn.unmount;function Ja(e){sn.__h&&sn.__h(Va);var t=Va.__H||(Va.__H={o:[],t:[],i:[],u:[]});return e>=t.o.length&&t.o.push({}),t.o[e]}function Ya(e){return function(n,e,t){var r=Ja(Ua++);return r.__c||(r.__c=Va,r.v=[t?t(e):as(void 0,e),function(e){var t=n(r.v[0],e);r.v[0]!==t&&(r.v[0]=t,r.__c.setState({}))}]),r.v}(as,e)}function Ga(e){return function(e,t){var n=Ja(Ua++);return is(n.m,t)?(n.m=t,n.p=e,n.v=e()):n.v}(function(){return{current:e}},[])}sn.unmount=function(e){Ka&&Ka(e);var t=e.__c;if(t){var n=t.__H;n&&n.o.forEach(function(e){return e.l&&e.l()})}};var Xa=function(){};function Za(){Wa.some(function(e){e.s=!1,e.__P&&(e.__H.t=ts(e.__H.t))}),Wa=[]}if("undefined"!=typeof window){var es=sn.requestAnimationFrame;Xa=function(e){(!e.s&&(e.s=!0)&&1===Wa.push(e)||es!==sn.requestAnimationFrame)&&(es=sn.requestAnimationFrame,(sn.requestAnimationFrame||function(e){function t(){clearTimeout(n),cancelAnimationFrame(r),setTimeout(e)}var n=setTimeout(t,100),r=requestAnimationFrame(t)})(Za))}}function ts(e){return e.forEach(ns),e.forEach(rs),[]}function ns(e){e.l&&e.l()}function rs(e){var t=e.v();"function"==typeof t&&(e.l=t)}function is(n,e){return!n||e.some(function(e,t){return e!==n[t]})}function as(e,t){return"function"==typeof t?t(e):t}function ss(e){var t,n=Q(Ya(e.isCollapsed),2),r=n[0],i=n[1],a=Q(Ya(!1),2),s=a[0],o=a[1],c=Ga(null);return function(e,t){var n=Ja(Ua++);is(n.m,t)&&(n.v=e,n.m=t,Va.__H.t.push(n),Xa(Va))}(function(){if(c.current)return c.current.appendChild(e.bodyElement),function(){c.current.removeChild(e.bodyElement)}},[c,e.bodyElement]),s||e.isCollapsed===r||i(e.isCollapsed),vn("div",{className:qr(e.cssClasses.root,(t={},L(t,e.cssClasses.noRefinementRoot,e.hidden),L(t,e.cssClasses.collapsibleRoot,e.collapsible),L(t,e.cssClasses.collapsedRoot,r),t)),hidden:e.hidden},e.templates.header&&vn("div",{className:e.cssClasses.header},vn(Ur,{templates:e.templates,templateKey:"header",rootTagName:"span",data:e.data}),e.collapsible&&vn("button",{className:e.cssClasses.collapseButton,"aria-expanded":!r,onClick:function(e){e.preventDefault(),o(!0),i(function(e){return!e})}},vn(Ur,{templates:e.templates,templateKey:"collapseButtonText",rootTagName:"span",data:{collapsed:r}}))),vn("div",{className:e.cssClasses.body,ref:c}),e.templates.footer&&vn(Ur,{templates:e.templates,templateKey:"footer",rootProps:{className:e.cssClasses.footer},data:e.data}))}function os(e){var t=e.cssClasses,n=e.isBrowserSupported,r=e.isListening,i=e.toggleListening,a=e.voiceListeningState,s=e.templates,o=a.status,c=a.transcript,u=a.isSpeechFinal,l=a.errorCode;return vn("div",{className:t.root},vn(Ur,{templateKey:"buttonText",rootTagName:"button",rootProps:{className:t.button,type:"button",title:"Search by voice".concat(n?"":" (not supported on this browser)"),onClick:function(e){e.currentTarget.blur(),i()},disabled:!n},data:{status:o,errorCode:l,isListening:r,transcript:c,isSpeechFinal:u,isBrowserSupported:n},templates:s}),vn(Ur,{templateKey:"status",rootProps:{className:t.status},data:{status:o,errorCode:l,isListening:r,transcript:c,isSpeechFinal:u,isBrowserSupported:n},templates:s}))}function cs(e){var t=e.isBrowserSupported,n=e.isListening,r=e.toggleListening,i=e.voiceListeningState,a=e.widgetParams,s=a.container,o=a.cssClasses,c=a.templates;Ln(vn(os,{cssClasses:o,templates:c,isBrowserSupported:t,isListening:n,toggleListening:r,voiceListeningState:i}),s)}function us(e){var t=e.cssClasses,n=e.templates,r=e.items;return vn(Ur,{templateKey:"default",templates:n,rootProps:{className:t.root},data:{items:r}})}function ls(e){var t=e.items,n=e.widgetParams,r=n.container,i=n.cssClasses,a=n.templates;Ln(vn(us,{cssClasses:i,templates:a,items:t}),r)}var hs=Ae({name:"panel"}),fs=at("Panel"),ds={buttonText:function(e){var t=e.status,n=e.errorCode,r=e.isListening;return'<svg\n       xmlns="http://www.w3.org/2000/svg"\n       width="16"\n       height="16"\n       viewBox="0 0 24 24"\n       fill="none"\n       stroke="currentColor"\n       stroke-width="2"\n       stroke-linecap="round"\n       stroke-linejoin="round"\n     >\n       '.concat(function(e,t,n){return"error"===e&&"not-allowed"===t?'<line x1="1" y1="1" x2="23" y2="23"></line>\n            <path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path>\n            <path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path>\n            <line x1="12" y1="19" x2="12" y2="23"></line>\n            <line x1="8" y1="23" x2="16" y2="23"></line>':'<path\n            d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"\n            fill="'.concat(n?"currentColor":"none",'">\n          </path>\n          <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>\n          <line x1="12" y1="19" x2="12" y2="23"></line>\n          <line x1="8" y1="23" x2="16" y2="23"></line>')}(t,n,r),"\n     </svg>")},status:"<p>{{transcript}}</p>"},ms=Ae({name:"voice-search"}),ps=at("VoiceSearch"),vs=Ae({name:"query-rule-custom-data"}),gs=at("QueryRuleCustomData"),ys=Ae({name:"query-rule-context"}),bs=Object.freeze({__proto__:null,clearRefinements:function(e){var t=e||{},n=t.container,r=t.templates,i=void 0===r?Kr:r,a=t.includedAttributes,s=t.excludedAttributes,o=t.transformItems,c=t.cssClasses,u=void 0===c?{}:c;if(!n)throw new Error(Jr("The `container` option is required."));var l=ce(n),h={root:qr(Yr(),u.root),button:qr(Yr({descendantName:"button"}),u.button),disabledButton:qr(Yr({descendantName:"button",modifierName:"disabled"}),u.disabledButton)},f=function(e){var a=e.containerNode,s=e.cssClasses,o=e.renderState,c=e.templates;return function(e,t){var n=e.refine,r=e.hasRefinements,i=e.instantSearchInstance;t?o.templateProps=he({defaultTemplates:Kr,templatesConfig:i.templatesConfig,templates:c}):Ln(vn(Vr,{refine:n,cssClasses:s,hasRefinements:r,templateProps:o.templateProps}),a)}}({containerNode:l,cssClasses:h,renderState:{},templates:i});return Vt(f,function(){return Ln(null,l)})({includedAttributes:a,excludedAttributes:s,transformItems:o})},configure:function(e){return Tr(_e)({searchParameters:e})},EXPERIMENTAL_configureRelatedItems:function(e){return Mr(_e)(e)},currentRefinements:function(e){var t=e||{},n=t.container,r=t.includedAttributes,i=t.excludedAttributes,a=t.cssClasses,s=void 0===a?{}:a,o=t.transformItems;if(!n)throw new Error(Gr("The `container` option is required."));var c=ce(n),u={root:qr(Xr(),s.root),list:qr(Xr({descendantName:"list"}),s.list),item:qr(Xr({descendantName:"item"}),s.item),label:qr(Xr({descendantName:"label"}),s.label),category:qr(Xr({descendantName:"category"}),s.category),categoryLabel:qr(Xr({descendantName:"categoryLabel"}),s.categoryLabel),delete:qr(Xr({descendantName:"delete"}),s.delete)};return zt($r,function(){return Ln(null,c)})({container:c,cssClasses:u,includedAttributes:r,excludedAttributes:i,transformItems:o})},geoSearch:function(e){var t=0<arguments.length&&void 0!==e?e:{},n=t.initialZoom,r=void 0===n?1:n,i=t.initialPosition,a=void 0===i?{lat:0,lng:0}:i,s=t.templates,o=void 0===s?{}:s,c=t.cssClasses,u=void 0===c?{}:c,l=t.builtInMarker,h=void 0===l?{}:l,f=t.customHTMLMarker,d=t.enableRefine,m=void 0===d||d,p=t.enableClearMapRefinement,v=void 0===p||p,g=t.enableRefineControl,y=void 0===g||g,b=t.container,R=t.googleReference,w=A(t,["initialZoom","initialPosition","templates","cssClasses","builtInMarker","customHTMLMarker","enableRefine","enableClearMapRefinement","enableRefineControl","container","googleReference"]),S={createOptions:_e,events:{}},P={createOptions:_e,events:{}};if(!b)throw new Error(ai("The `container` option is required."));if(!R)throw new Error(ai("The `googleReference` option is required."));var _=ce(b),N={root:qr(si(),u.root),tree:si({descendantName:"tree"}),map:qr(si({descendantName:"map"}),u.map),control:qr(si({descendantName:"control"}),u.control),label:qr(si({descendantName:"label"}),u.label),selectedLabel:qr(si({descendantName:"label",modifierName:"selected"}),u.selectedLabel),input:qr(si({descendantName:"input"}),u.input),redo:qr(si({descendantName:"redo"}),u.redo),disabledRedo:qr(si({descendantName:"redo",modifierName:"disabled"}),u.disabledRedo),reset:qr(si({descendantName:"reset"}),u.reset)},x=D({},ii,{},o),F=D({},S,{},h),I=(Boolean(f)||Boolean(o.HTMLMarker))&&D({},P,{},f),C=function(l){return function(){function u(e){var t,n=e.__id,r=e.position,i=e.map,a=e.template,s=e.className,o=e.anchor,c=void 0===o?{x:0,y:0}:o;return k(this,u),L(H(t=B(this,O(u).call(this))),"__id",void 0),L(H(t),"anchor",void 0),L(H(t),"offset",void 0),L(H(t),"listeners",void 0),L(H(t),"latLng",void 0),L(H(t),"element",void 0),t.__id=n,t.anchor=c,t.listeners={},t.latLng=new l.maps.LatLng(r),t.element=document.createElement("div"),t.element.className=s,t.element.style.position="absolute",t.element.innerHTML=a,t.setMap(i),t}return j(u,l.maps.OverlayView),M(u,[{key:"onAdd",value:function(){this.getPanes().overlayMouseTarget.appendChild(this.element);var e=this.element.getBoundingClientRect();this.offset={x:this.anchor.x+e.width/2,y:this.anchor.y+e.height},this.element.style.width="".concat(e.width,"px")}},{key:"draw",value:function(){var e=this.getProjection().fromLatLngToDivPixel(this.latLng);this.element.style.left="".concat(Math.round(e.x-this.offset.x),"px"),this.element.style.top="".concat(Math.round(e.y-this.offset.y),"px"),this.element.style.zIndex=String(parseInt(this.element.style.top,10))}},{key:"onRemove",value:function(){var t=this;this.element&&(this.element.parentNode.removeChild(this.element),Object.keys(this.listeners).forEach(function(e){t.element.removeEventListener(e,t.listeners[e])}),delete this.element,delete this.listeners)}},{key:"addListener",value:function(e,t){this.listeners[e]=t;var n=this.element;return n.addEventListener(e,t),{remove:function(){return n.removeEventListener(e,t)}}}},{key:"getPosition",value:function(){return this.latLng}}]),u}()}(R),T=I?function(e){var t=e.item,n=A(e,["item"]);return new C(D({},I.createOptions(t),{},n,{__id:t.objectID,position:t._geoloc,className:qr(si({descendantName:"marker"})),template:ve({templateKey:"HTMLMarker",templates:x,data:t})}))}:function(e){var t=e.item,n=A(e,["item"]);return new R.maps.Marker(D({},F.createOptions(t),{},n,{__id:t.objectID,position:t._geoloc}))},E=I||F;return Pr(ri,function(){return Ln(null,_)})(D({},w,{renderState:{},container:_,googleReference:R,initialZoom:r,initialPosition:a,templates:x,cssClasses:N,createMarker:T,markerOptions:E,enableRefine:m,enableClearMapRefinement:v,enableRefineControl:y}))},hierarchicalMenu:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.attributes,r=e.separator,i=e.rootPath,a=e.showParentLevel,s=e.limit,o=e.showMore,c=void 0!==o&&o,u=e.showMoreLimit,l=e.sortBy,h=e.transformItems,f=e.templates,d=void 0===f?li:f,m=e.cssClasses,p=void 0===m?{}:m;if(!t)throw new Error(hi("The `container` option is required."));var v=ce(t);return en(function(e){var u=e.cssClasses,l=e.containerNode,h=e.showMore,f=e.templates,d=e.renderState;return function(e,t){var n=e.createURL,r=e.items,i=e.refine,a=e.instantSearchInstance,s=e.isShowingMore,o=e.toggleShowMore,c=e.canToggleShowMore;t?d.templateProps=he({defaultTemplates:li,templatesConfig:a.templatesConfig,templates:f}):Ln(vn(ui,{createURL:n,cssClasses:u,facetValues:r,templateProps:d.templateProps,toggleRefinement:i,showMore:h,toggleShowMore:o,isShowingMore:s,canToggleShowMore:c}),l)}}({cssClasses:{root:qr(fi(),p.root),noRefinementRoot:qr(fi({modifierName:"noRefinement"}),p.noRefinementRoot),list:qr(fi({descendantName:"list"}),p.list),childList:qr(fi({descendantName:"list",modifierName:"child"}),p.childList),item:qr(fi({descendantName:"item"}),p.item),selectedItem:qr(fi({descendantName:"item",modifierName:"selected"}),p.selectedItem),parentItem:qr(fi({descendantName:"item",modifierName:"parent"}),p.parentItem),link:qr(fi({descendantName:"link"}),p.link),label:qr(fi({descendantName:"label"}),p.label),count:qr(fi({descendantName:"count"}),p.count),showMore:qr(fi({descendantName:"showMore"}),p.showMore),disabledShowMore:qr(fi({descendantName:"showMore",modifierName:"disabled"}),p.disabledShowMore)},containerNode:v,templates:d,showMore:c,renderState:{}}),function(){return Ln(null,v)})({attributes:n,separator:r,rootPath:i,showParentLevel:a,limit:s,showMore:c,showMoreLimit:u,sortBy:l,transformItems:h})},hits:function(e){var t=e||{},n=t.container,r=t.escapeHTML,i=t.transformItems,a=t.templates,s=void 0===a?mi:a,o=t.cssClasses,c=void 0===o?{}:o;if(!n)throw new Error(pi("The `container` option is required."));var u=ce(n),l={root:qr(vi(),c.root),emptyRoot:qr(vi({modifierName:"empty"}),c.emptyRoot),list:qr(vi({descendantName:"list"}),c.list),item:qr(vi({descendantName:"item"}),c.item)},h=function(e){var o=e.renderState,c=e.cssClasses,u=e.containerNode,l=e.templates;return function(e,t){var n=e.hits,r=e.results,i=e.instantSearchInstance,a=e.insights,s=e.bindEvent;t?o.templateProps=he({defaultTemplates:mi,templatesConfig:i.templatesConfig,templates:l}):Ln(vn(gi,{cssClasses:c,hits:n,results:r,templateProps:o.templateProps,insights:a,sendEvent:function(e){i.sendEventToInsights(e)},bindEvent:s}),u)}}({containerNode:u,cssClasses:l,renderState:{},templates:s});return an(tn)(h,function(){return Ln(null,u)})({escapeHTML:r,transformItems:i})},hitsPerPage:function(e){var t=e||{},n=t.container,r=t.items,i=t.cssClasses,a=void 0===i?{}:i,s=t.transformItems;if(!n)throw new Error(bi("The `container` option is required."));var o=ce(n),c={root:qr(Ri(),a.root),select:qr(Ri({descendantName:"select"}),a.select),option:qr(Ri({descendantName:"option"}),a.option)},u=function(e){var a=e.containerNode,s=e.cssClasses;return function(e,t){var n=e.items,r=e.refine;if(!t){var i=(ge(n,function(e){return e.isRefined})||{}).value;Ln(vn("div",{className:s.root},vn(yi,{cssClasses:s,currentValue:i,options:n,setValue:r})),a)}}}({containerNode:o,cssClasses:c});return An(u,function(){return Ln(null,o)})({items:r,transformItems:s})},infiniteHits:function(e){var t=0<arguments.length&&void 0!==e?e:{},n=t.container,r=t.escapeHTML,i=t.transformItems,a=t.templates,s=void 0===a?wi:a,o=t.cssClasses,c=void 0===o?{}:o,u=t.showPrevious,l=t.cache;if(!n)throw new Error(Si("The `container` option is required."));var h=ce(n),f={root:qr(Pi(),c.root),emptyRoot:qr(Pi({modifierName:"empty"}),c.emptyRoot),item:qr(Pi({descendantName:"item"}),c.item),list:qr(Pi({descendantName:"list"}),c.list),loadPrevious:qr(Pi({descendantName:"loadPrevious"}),c.loadPrevious),disabledLoadPrevious:qr(Pi({descendantName:"loadPrevious",modifierName:"disabled"}),c.disabledLoadPrevious),loadMore:qr(Pi({descendantName:"loadMore"}),c.loadMore),disabledLoadMore:qr(Pi({descendantName:"loadMore",modifierName:"disabled"}),c.disabledLoadMore)},d=function(e){var h=e.cssClasses,f=e.containerNode,d=e.renderState,m=e.templates,p=e.showPrevious;return function(e,t){var n=e.hits,r=e.results,i=e.showMore,a=e.showPrevious,s=e.isFirstPage,o=e.isLastPage,c=e.instantSearchInstance,u=e.insights,l=e.bindEvent;t?d.templateProps=he({defaultTemplates:wi,templatesConfig:c.templatesConfig,templates:m}):Ln(vn(_i,{cssClasses:h,hits:n,results:r,hasShowPrevious:p,showPrevious:a,showMore:i,templateProps:d.templateProps,isFirstPage:s,isLastPage:o,insights:u,sendEvent:function(e){c.sendEventToInsights(e)},bindEvent:l}),f)}}({containerNode:h,cssClasses:f,templates:s,showPrevious:u,renderState:{}});return an(Un)(d,function(){return Ln(null,h)})({escapeHTML:r,transformItems:i,showPrevious:u,cache:l})},menu:function(e){var t=e.container,n=e.attribute,r=e.sortBy,i=e.limit,a=e.showMore,s=e.showMoreLimit,o=e.cssClasses,c=void 0===o?{}:o,u=e.templates,l=void 0===u?Ni:u,h=e.transformItems;if(!t)throw new Error(xi("The `container` option is required."));var f=ce(t),d={root:qr(Fi(),c.root),noRefinementRoot:qr(Fi({modifierName:"noRefinement"}),c.noRefinementRoot),list:qr(Fi({descendantName:"list"}),c.list),item:qr(Fi({descendantName:"item"}),c.item),selectedItem:qr(Fi({descendantName:"item",modifierName:"selected"}),c.selectedItem),link:qr(Fi({descendantName:"link"}),c.link),label:qr(Fi({descendantName:"label"}),c.label),count:qr(Fi({descendantName:"count"}),c.count),showMore:qr(Fi({descendantName:"showMore"}),c.showMore),disabledShowMore:qr(Fi({descendantName:"showMore",modifierName:"disabled"}),c.disabledShowMore)};return $n(function(e){var l=e.containerNode,h=e.cssClasses,f=e.renderState,d=e.templates,m=e.showMore;return function(e,t){var n=e.refine,r=e.items,i=e.createURL,a=e.instantSearchInstance,s=e.isShowingMore,o=e.toggleShowMore,c=e.canToggleShowMore;if(t)f.templateProps=he({defaultTemplates:Ni,templatesConfig:a.templatesConfig,templates:d});else{var u=r.map(function(e){return D({},e,{url:i(e.name)})});Ln(vn(ui,{createURL:i,cssClasses:h,facetValues:u,showMore:m,templateProps:f.templateProps,toggleRefinement:n,toggleShowMore:o,isShowingMore:s,canToggleShowMore:c}),l)}}}({containerNode:f,cssClasses:d,renderState:{},templates:l,showMore:a}),function(){return Ln(null,f)})({attribute:n,limit:i,showMore:a,showMoreLimit:s,sortBy:r,transformItems:h})},refinementList:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.attribute,r=e.operator,i=e.sortBy,a=e.limit,s=e.showMore,o=e.showMoreLimit,c=e.searchable,u=void 0!==c&&c,l=e.searchablePlaceholder,h=void 0===l?"Search...":l,f=e.searchableEscapeFacetValues,d=void 0===f||f,m=e.searchableIsAlwaysActive,p=void 0===m||m,v=e.cssClasses,g=void 0===v?{}:v,y=e.templates,b=void 0===y?Ci:y,R=e.transformItems;if(!t)throw new Error(Ti("The `container` option is required."));var w=!!u&&Boolean(d),S=ce(t),P=function(e){var t=D({},e,{submit:e.searchableSubmit,reset:e.searchableReset,loadingIndicator:e.searchableLoadingIndicator});return t.searchableReset,t.searchableSubmit,t.searchableLoadingIndicator,A(t,["searchableReset","searchableSubmit","searchableLoadingIndicator"])}(D({},Ci,{},b)),_={root:qr(Ei(),g.root),noRefinementRoot:qr(Ei({modifierName:"noRefinement"}),g.noRefinementRoot),list:qr(Ei({descendantName:"list"}),g.list),item:qr(Ei({descendantName:"item"}),g.item),selectedItem:qr(Ei({descendantName:"item",modifierName:"selected"}),g.selectedItem),searchBox:qr(Ei({descendantName:"searchBox"}),g.searchBox),label:qr(Ei({descendantName:"label"}),g.label),checkbox:qr(Ei({descendantName:"checkbox"}),g.checkbox),labelText:qr(Ei({descendantName:"labelText"}),g.labelText),count:qr(Ei({descendantName:"count"}),g.count),noResults:qr(Ei({descendantName:"noResults"}),g.noResults),showMore:qr(Ei({descendantName:"showMore"}),g.showMore),disabledShowMore:qr(Ei({descendantName:"showMore",modifierName:"disabled"}),g.disabledShowMore),searchable:{root:qr(ki(),g.searchableRoot),form:qr(ki({descendantName:"form"}),g.searchableForm),input:qr(ki({descendantName:"input"}),g.searchableInput),submit:qr(ki({descendantName:"submit"}),g.searchableSubmit),submitIcon:qr(ki({descendantName:"submitIcon"}),g.searchableSubmitIcon),reset:qr(ki({descendantName:"reset"}),g.searchableReset),resetIcon:qr(ki({descendantName:"resetIcon"}),g.searchableResetIcon),loadingIndicator:qr(ki({descendantName:"loadingIndicator"}),g.searchableLoadingIndicator),loadingIcon:qr(ki({descendantName:"loadingIcon"}),g.searchableLoadingIcon)}};return sr(function(e){var f=e.containerNode,d=e.cssClasses,m=e.templates,p=e.renderState,v=e.showMore,g=e.searchable,y=e.searchablePlaceholder,b=e.searchableIsAlwaysActive;return function(e,t){var n=e.refine,r=e.items,i=e.createURL,a=e.searchForItems,s=e.isFromSearch,o=e.instantSearchInstance,c=e.toggleShowMore,u=e.isShowingMore,l=e.hasExhaustiveItems,h=e.canToggleShowMore;t?p.templateProps=he({templatesConfig:o.templatesConfig,templates:m}):Ln(vn(ui,{createURL:i,cssClasses:d,facetValues:r,templateProps:p.templateProps,toggleRefinement:n,searchFacetValues:g?a:void 0,searchPlaceholder:y,searchIsAlwaysActive:b,isFromSearch:s,showMore:v&&!s&&0<r.length,toggleShowMore:c,isShowingMore:u,hasExhaustiveItems:l,canToggleShowMore:h}),f)}}({containerNode:S,cssClasses:_,templates:P,renderState:{},searchable:u,searchablePlaceholder:h,searchableIsAlwaysActive:p,showMore:s}),function(){return Ln(null,S)})({attribute:n,operator:r,limit:a,showMore:s,showMoreLimit:o,sortBy:i,escapeFacetValues:w,transformItems:R})},numericMenu:function(e){var t=e||{},n=t.container,r=t.attribute,i=t.items,a=t.cssClasses,s=void 0===a?{}:a,o=t.templates,c=void 0===o?Mi:o,u=t.transformItems;if(!n)throw new Error(Li("The `container` option is required."));var l=ce(n),h={root:qr(ji(),s.root),noRefinementRoot:qr(ji({modifierName:"noRefinement"}),s.noRefinementRoot),list:qr(ji({descendantName:"list"}),s.list),item:qr(ji({descendantName:"item"}),s.item),selectedItem:qr(ji({descendantName:"item",modifierName:"selected"}),s.selectedItem),label:qr(ji({descendantName:"label"}),s.label),radio:qr(ji({descendantName:"radio"}),s.radio),labelText:qr(ji({descendantName:"labelText"}),s.labelText)},f=function(e){var s=e.containerNode,o=e.attribute,c=e.cssClasses,u=e.renderState,l=e.templates;return function(e,t){var n=e.createURL,r=e.instantSearchInstance,i=e.refine,a=e.items;t?u.templateProps=he({defaultTemplates:Mi,templatesConfig:r.templatesConfig,templates:l}):Ln(vn(ui,{createURL:n,cssClasses:c,facetValues:a,templateProps:u.templateProps,toggleRefinement:i,attribute:o}),s)}}({containerNode:l,attribute:r,cssClasses:h,renderState:{},templates:c});return zn(f,function(){return Ln(null,l)})({attribute:r,items:i,transformItems:u})},pagination:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.templates,r=void 0===n?{}:n,i=e.cssClasses,a=void 0===i?{}:i,s=e.totalPages,o=e.padding,c=e.showFirst,u=void 0===c||c,l=e.showLast,h=void 0===l||l,f=e.showPrevious,d=void 0===f||f,m=e.showNext,p=void 0===m||m,v=e.scrollTo,g=void 0===v?"body":v;if(!t)throw new Error(Hi("The `container` option is required."));var y=ce(t),b=!0===g?"body":g,R=!1!==b&&ce(b),w={root:qr(Di(),a.root),noRefinementRoot:qr(Di({modifierName:"noRefinement"}),a.noRefinementRoot),list:qr(Di({descendantName:"list"}),a.list),item:qr(Di({descendantName:"item"}),a.item),firstPageItem:qr(Di({descendantName:"item",modifierName:"firstPage"}),a.firstPageItem),lastPageItem:qr(Di({descendantName:"item",modifierName:"lastPage"}),a.lastPageItem),previousPageItem:qr(Di({descendantName:"item",modifierName:"previousPage"}),a.previousPageItem),nextPageItem:qr(Di({descendantName:"item",modifierName:"nextPage"}),a.nextPageItem),pageItem:qr(Di({descendantName:"item",modifierName:"page"}),a.pageItem),selectedItem:qr(Di({descendantName:"item",modifierName:"selected"}),a.selectedItem),disabledItem:qr(Di({descendantName:"item",modifierName:"disabled"}),a.disabledItem),link:qr(Di({descendantName:"link"}),a.link)},S=D({},Bi,{},r);return tr(function(e){var l=e.containerNode,h=e.cssClasses,f=e.templates,d=e.totalPages,m=e.showFirst,p=e.showLast,v=e.showPrevious,g=e.showNext,y=e.scrollToNode;return function(e,t){var n=e.createURL,r=e.currentRefinement,i=e.nbHits,a=e.nbPages,s=e.pages,o=e.isFirstPage,c=e.isLastPage,u=e.refine;if(!t){Ln(vn(Ai,{createURL:n,cssClasses:h,currentPage:r,templates:f,nbHits:i,nbPages:a,pages:s,totalPages:d,isFirstPage:o,isLastPage:c,setCurrentPage:function(e){u(e),!1!==y&&y.scrollIntoView()},showFirst:m,showLast:p,showPrevious:v,showNext:g}),l)}}}({containerNode:y,cssClasses:w,templates:S,showFirst:u,showLast:h,showPrevious:d,showNext:p,padding:o,scrollToNode:R}),function(){return Ln(null,y)})({totalPages:s,padding:o})},rangeInput:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.attribute,r=e.min,i=e.max,a=e.precision,s=void 0===a?0:a,o=e.cssClasses,c=void 0===o?{}:o,u=e.templates,l=void 0===u?{}:u;if(!t)throw new Error(qi("The `container` option is required."));var h=ce(t),f=D({separatorText:"to",submitText:"Go"},l),d={root:qr(Ui(),c.root),noRefinement:qr(Ui({modifierName:"noRefinement"})),form:qr(Ui({descendantName:"form"}),c.form),label:qr(Ui({descendantName:"label"}),c.label),input:qr(Ui({descendantName:"input"}),c.input),inputMin:qr(Ui({descendantName:"input",modifierName:"min"}),c.inputMin),inputMax:qr(Ui({descendantName:"input",modifierName:"max"}),c.inputMax),separator:qr(Ui({descendantName:"separator"}),c.separator),submit:qr(Ui({descendantName:"submit"}),c.submit)};return D({},ir(function(e){var d=e.containerNode,m=e.cssClasses,p=e.renderState,v=e.templates;return function(e,t){var n=e.refine,r=e.range,i=e.start,a=e.widgetParams,s=e.instantSearchInstance;if(t)p.templateProps=he({templatesConfig:s.templatesConfig,templates:v});else{var o=r.min,c=r.max,u=Q(i,2),l=u[0],h=u[1],f=1/Math.pow(10,a.precision);Ln(vn(Qi,{min:o,max:c,step:f,values:{min:l!==-1/0&&l!==o?l:void 0,max:h!==1/0&&h!==c?h:void 0},cssClasses:m,refine:n,templateProps:p.templateProps}),d)}}}({containerNode:h,cssClasses:d,templates:f,renderState:{}}),function(){return Ln(null,h)})({attribute:n,min:r,max:i,precision:s}),{$$type:"ais.rangeInput"})},searchBox:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.placeholder,r=void 0===n?"":n,i=e.cssClasses,a=void 0===i?{}:i,s=e.autofocus,o=void 0!==s&&s,c=e.searchAsYouType,u=void 0===c||c,l=e.showReset,h=void 0===l||l,f=e.showSubmit,d=void 0===f||f,m=e.showLoadingIndicator,p=void 0===m||m,v=e.queryHook,g=e.templates;if(!t)throw new Error(Vi("The `container` option is required."));var y=ce(t),b={root:qr(Wi(),a.root),form:qr(Wi({descendantName:"form"}),a.form),input:qr(Wi({descendantName:"input"}),a.input),submit:qr(Wi({descendantName:"submit"}),a.submit),submitIcon:qr(Wi({descendantName:"submitIcon"}),a.submitIcon),reset:qr(Wi({descendantName:"reset"}),a.reset),resetIcon:qr(Wi({descendantName:"resetIcon"}),a.resetIcon),loadingIndicator:qr(Wi({descendantName:"loadingIndicator"}),a.loadingIndicator),loadingIcon:qr(Wi({descendantName:"loadingIcon"}),a.loadingIcon)};return cr(function(e){var i=e.containerNode,a=e.cssClasses,s=e.placeholder,o=e.templates,c=e.autofocus,u=e.searchAsYouType,l=e.showReset,h=e.showSubmit,f=e.showLoadingIndicator;return function(e){var t=e.refine,n=e.query,r=e.isSearchStalled;Ln(vn(ci,{query:n,placeholder:s,autofocus:c,refine:t,searchAsYouType:u,templates:o,showSubmit:h,showReset:l,showLoadingIndicator:f,isSearchStalled:r,cssClasses:a}),i)}}({containerNode:y,cssClasses:b,placeholder:r,templates:D({},Ii,{},g),autofocus:o,searchAsYouType:u,showReset:h,showSubmit:d,showLoadingIndicator:p}),function(){return Ln(null,y)})({queryHook:v})},rangeSlider:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.attribute,r=e.min,i=e.max,a=e.cssClasses,s=void 0===a?{}:a,o=e.step,c=e.pips,u=void 0===c||c,l=e.precision,h=void 0===l?0:l,f=e.tooltips,d=void 0===f||f;if(!t)throw new Error(fa("The `container` option is required."));var m=ce(t),p={root:qr(da(),s.root),disabledRoot:qr(da({modifierName:"disabled"}),s.disabledRoot)};return D({},ir(function(e){var f=e.containerNode,d=e.cssClasses,m=e.pips,p=e.step,v=e.tooltips;return function(e,t){var n=e.refine,r=e.range,i=e.start;if(!t){var a=r.min,s=r.max,o=Q(i,2),c=o[0],u=o[1],l=c===-1/0?a:c,h=u===1/0?s:u;Ln(vn(ha,{cssClasses:d,refine:n,min:a,max:s,values:[s<l?s:l,h<a?a:h],tooltips:v,step:p,pips:m}),f)}}}({containerNode:m,step:o,pips:u,tooltips:d,renderState:{},cssClasses:p}),function(){return Ln(null,m)})({attribute:n,min:r,max:i,precision:h}),{$$type:"ais.rangeSlider"})},sortBy:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.items,r=e.cssClasses,i=void 0===r?{}:r,a=e.transformItems;if(!t)throw new Error(ma("The `container` option is required."));var s=ce(t),o={root:qr(pa(),i.root),select:qr(pa({descendantName:"select"}),i.select),option:qr(pa({descendantName:"option"}),i.option)};return lr(function(e){var a=e.containerNode,s=e.cssClasses;return function(e,t){var n=e.currentRefinement,r=e.options,i=e.refine;t||Ln(vn("div",{className:s.root},vn(yi,{cssClasses:s,currentValue:n,options:r,setValue:i})),a)}}({containerNode:s,cssClasses:o}),function(){return Ln(null,s)})({items:n,transformItems:a})},ratingMenu:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.attribute,r=e.max,i=void 0===r?5:r,a=e.cssClasses,s=void 0===a?{}:a,o=e.templates,c=void 0===o?va:o;if(!t)throw new Error(ga("The `container` option is required."));var u=ce(t),l={root:qr(ya(),s.root),noRefinementRoot:qr(ya({modifierName:"noRefinement"}),s.noRefinementRoot),list:qr(ya({descendantName:"list"}),s.list),item:qr(ya({descendantName:"item"}),s.item),selectedItem:qr(ya({descendantName:"item",modifierName:"selected"}),s.selectedItem),disabledItem:qr(ya({descendantName:"item",modifierName:"disabled"}),s.disabledItem),link:qr(ya({descendantName:"link"}),s.link),starIcon:qr(ya({descendantName:"starIcon"}),s.starIcon),fullStarIcon:qr(ya({descendantName:"starIcon",modifierName:"full"}),s.fullStarIcon),emptyStarIcon:qr(ya({descendantName:"starIcon",modifierName:"empty"}),s.emptyStarIcon),label:qr(ya({descendantName:"label"}),s.label),count:qr(ya({descendantName:"count"}),s.count)};return mr(function(e){var s=e.containerNode,o=e.cssClasses,c=e.templates,u=e.renderState;return function(e,t){var n=e.refine,r=e.items,i=e.createURL,a=e.instantSearchInstance;t?u.templateProps=he({defaultTemplates:va,templatesConfig:a.templatesConfig,templates:c}):Ln(vn(ui,{createURL:i,cssClasses:o,facetValues:r,templateProps:u.templateProps,toggleRefinement:n},vn("svg",{xmlns:"http://www.w3.org/2000/svg",style:"display:none;"},vn("symbol",{id:ya({descendantName:"starSymbol"}),viewBox:"0 0 24 24"},ba),vn("symbol",{id:ya({descendantName:"starEmptySymbol"}),viewBox:"0 0 24 24"},Ra))),s)}}({containerNode:u,cssClasses:l,renderState:{},templates:c}),function(){return Ln(null,u)})({attribute:n,max:i})},stats:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.cssClasses,r=void 0===n?{}:n,i=e.templates,a=void 0===i?Sa:i;if(!t)throw new Error(Pa("The `container` option is required."));var s=ce(t),o={root:qr(_a(),r.root),text:qr(_a({descendantName:"text"}),r.text)};return vr(function(e){var u=e.containerNode,l=e.cssClasses,h=e.renderState,f=e.templates;return function(e,t){var n=e.hitsPerPage,r=e.nbHits,i=e.nbPages,a=e.page,s=e.processingTimeMS,o=e.query,c=e.instantSearchInstance;t?h.templateProps=he({defaultTemplates:Sa,templatesConfig:c.templatesConfig,templates:f}):Ln(vn(wa,{cssClasses:l,hitsPerPage:n,nbHits:r,nbPages:i,page:a,processingTimeMS:s,query:o,templateProps:h.templateProps}),u)}}({containerNode:s,cssClasses:o,renderState:{},templates:a}),function(){return Ln(null,s)})()},toggleRefinement:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.attribute,r=e.cssClasses,i=void 0===r?{}:r,a=e.templates,s=void 0===a?xa:a,o=e.on,c=void 0===o||o,u=e.off;if(!t)throw new Error(Fa("The `container` option is required."));var l=ce(t),h={root:qr(Ia(),i.root),label:qr(Ia({descendantName:"label"}),i.label),checkbox:qr(Ia({descendantName:"checkbox"}),i.checkbox),labelText:qr(Ia({descendantName:"labelText"}),i.labelText)};return Rr(function(e){var s=e.containerNode,o=e.cssClasses,c=e.renderState,u=e.templates;return function(e,t){var n=e.value,r=e.createURL,i=e.refine,a=e.instantSearchInstance;t?c.templateProps=he({defaultTemplates:xa,templatesConfig:a.templatesConfig,templates:u}):Ln(vn(Na,{createURL:r,cssClasses:o,currentRefinement:n,templateProps:c.templateProps,refine:function(e){return i({isRefined:e})}}),s)}}({containerNode:l,cssClasses:h,renderState:{},templates:s}),function(){return Ln(null,l)})({attribute:n,on:c,off:u})},analytics:function(e){var t=e||{},s=t.pushFunction,n=t.delay,r=void 0===n?3e3:n,i=t.triggerOnUIInteraction,a=void 0!==i&&i,o=t.pushInitialSearch,c=void 0===o||o,u=t.pushPagination,l=void 0!==u&&u;if(!s)throw new Error(Ta("The `pushFunction` option is required."));function h(e){if(null!==e){var t=[],n=function(e){var t=[];for(var n in e)if(e.hasOwnProperty(n)){var r=e[n].join("+");t.push("".concat(encodeURIComponent(n),"=").concat(encodeURIComponent(n),"_").concat(encodeURIComponent(r)))}return t.join("&")}(D({},e.state.disjunctiveFacetsRefinements,{},e.state.facetsRefinements,{},e.state.hierarchicalFacetsRefinements)),r=function(e){var t=[];for(var n in e)if(e.hasOwnProperty(n)){var r=e[n];if(r.hasOwnProperty(">=")&&r.hasOwnProperty("<="))r[">="]&&r[">="][0]===r["<="]&&r["<="][0]?t.push("".concat(n,"=").concat(n,"_").concat(r[">="])):t.push("".concat(n,"=").concat(n,"_").concat(r[">="],"to").concat(r["<="]));else if(r.hasOwnProperty(">="))t.push("".concat(n,"=").concat(n,"_from").concat(r[">="]));else if(r.hasOwnProperty("<="))t.push("".concat(n,"=").concat(n,"_to").concat(r["<="]));else if(r.hasOwnProperty("=")){var i=[];for(var a in r["="])r["="].hasOwnProperty(a)&&i.push(r["="][a]);t.push("".concat(n,"=").concat(n,"_").concat(i.join("-")))}}return t.join("&")}(e.state.numericRefinements);""!==n&&t.push(n),""!==r&&t.push(r);var i=t.join("&"),a="Query: ".concat(e.state.query||"",", ").concat(i);!0===l&&(a+=", Page: ".concat(e.state.page||0)),m!==a&&(s(i,e.state,e.results),m=a)}}var f,d=null,m="",p=!0;!0===c&&(p=!1);function v(){h(d)}function g(){h(d)}return{init:function(){!0===a&&(document.addEventListener("click",v),window.addEventListener("beforeunload",g))},render:function(e){var t=e.results,n=e.state;!0!==p?(d={results:t,state:n},f&&clearTimeout(f),f=window.setTimeout(function(){return h(d)},r)):p=!1},dispose:function(){!0===a&&(document.removeEventListener("click",v),window.removeEventListener("beforeunload",g))}}},breadcrumb:function(e){var t=e||{},n=t.container,r=t.attributes,i=t.separator,a=t.rootPath,s=t.transformItems,o=t.templates,c=void 0===o?Ea:o,u=t.cssClasses,l=void 0===u?{}:u;if(!n)throw new Error(ka("The `container` option is required."));var h=ce(n),f={root:qr(Ma(),l.root),noRefinementRoot:qr(Ma({modifierName:"noRefinement"}),l.noRefinementRoot),list:qr(Ma({descendantName:"list"}),l.list),item:qr(Ma({descendantName:"item"}),l.item),selectedItem:qr(Ma({descendantName:"item",modifierName:"selected"}),l.selectedItem),separator:qr(Ma({descendantName:"separator"}),l.separator),link:qr(Ma({descendantName:"link"}),l.link)},d=function(e){var o=e.containerNode,c=e.cssClasses,u=e.renderState,l=e.templates;return function(e,t){var n=e.canRefine,r=e.createURL,i=e.instantSearchInstance,a=e.items,s=e.refine;t?u.templateProps=he({defaultTemplates:Ea,templatesConfig:i.templatesConfig,templates:l}):Ln(vn(Ca,{canRefine:n,cssClasses:c,createURL:r,items:a,refine:s,templateProps:u.templateProps}),o)}}({containerNode:h,cssClasses:f,renderState:{},templates:c});return wr(d,function(){return Ln(null,h)})({attributes:r,separator:i,rootPath:a,transformItems:s})},menuSelect:function(e){var t=e.container,n=e.attribute,r=e.sortBy,i=void 0===r?["name:asc"]:r,a=e.limit,s=void 0===a?10:a,o=e.cssClasses,c=void 0===o?{}:o,u=e.templates,l=void 0===u?ja:u,h=e.transformItems;if(!t)throw new Error(Oa("The `container` option is required."));var f=ce(t),d={root:qr(Aa(),c.root),noRefinementRoot:qr(Aa({modifierName:"noRefinement"}),c.noRefinementRoot),select:qr(Aa({descendantName:"select"}),c.select),option:qr(Aa({descendantName:"option"}),c.option)};return $n(function(e){var s=e.containerNode,o=e.cssClasses,c=e.renderState,u=e.templates;return function(e,t){var n=e.refine,r=e.items,i=e.canRefine,a=e.instantSearchInstance;t?c.templateProps=he({defaultTemplates:ja,templatesConfig:a.templatesConfig,templates:u}):Ln(vn(La,{cssClasses:o,items:r,refine:n,templateProps:c.templateProps,canRefine:i}),s)}}({containerNode:f,cssClasses:d,renderState:{},templates:l}),function(){return Ln(null,f)})({attribute:n,limit:s,sortBy:i,transformItems:h})},poweredBy:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e.container,n=e.cssClasses,r=void 0===n?{}:n,i=e.theme,a=void 0===i?"light":i;if(!t)throw new Error(qa("The `container` option is required."));var s=ce(t),o={root:qr(Qa(),Qa({modifierName:"dark"===a?"dark":"light"}),r.root),link:qr(Qa({descendantName:"link"}),r.link),logo:qr(Qa({descendantName:"logo"}),r.logo)};return Fr(function(e){var a=e.containerNode,s=e.cssClasses;return function(e,t){var n=e.url,r=e.widgetParams;if(t){var i=r.theme;Ln(vn(Ha,{cssClasses:s,url:n,theme:i}),a)}else;}}({containerNode:s,cssClasses:o}),function(){return Ln(null,s)})({theme:a})},panel:function(e){var t=e||{},n=t.templates,r=void 0===n?{}:n,i=t.hidden,o=void 0===i?function(){return!1}:i,a=t.collapsed,s=t.cssClasses,c=void 0===s?{}:s,u=document.createElement("div"),l=Boolean(a),h="function"==typeof a?a:function(){return!1},f={root:qr(fs(),c.root),noRefinementRoot:qr(fs({modifierName:"noRefinement"}),c.noRefinementRoot),collapsibleRoot:qr(fs({modifierName:"collapsible"}),c.collapsibleRoot),collapsedRoot:qr(fs({modifierName:"collapsed"}),c.collapsedRoot),collapseButton:qr(fs({descendantName:"collapseButton"}),c.collapseButton),collapseIcon:qr(fs({descendantName:"collapseIcon"}),c.collapseIcon),body:qr(fs({descendantName:"body"}),c.body),header:qr(fs({descendantName:"header"}),c.header),footer:qr(fs({descendantName:"footer"}),c.footer)};return function(n){return function(e){var i=(e||{}).container;if(!i)throw new Error(hs("The `container` option is required in the widget within the panel."));var t={header:"",footer:"",collapseButtonText:function(e){var t=e.collapsed;return'<svg\n          class="'.concat(f.collapseIcon,'"\n          width="1em"\n          height="1em"\n          viewBox="0 0 500 500"\n        >\n        <path d="').concat(t?"M100 250l300-150v300z":"M250 400l150-300H100z",'" fill="currentColor" />\n        </svg>')}},a=function(e){var a=e.containerNode,s=e.bodyContainerNode,o=e.cssClasses,c=e.templates;return function(e){var t=e.options,n=e.hidden,r=e.collapsible,i=e.collapsed;Ln(vn(ss,{cssClasses:o,hidden:n,collapsible:r,isCollapsed:i,templates:c,data:t,bodyElement:s}),a)}}({containerNode:ce(i),bodyContainerNode:u,cssClasses:f,templates:D({},t,{},r)});a({options:{},hidden:!0,collapsible:l,collapsed:!1});var s=n(D({},e,{container:u}));return D({},s,{dispose:function(){if(Ln(null,ce(i)),"function"==typeof s.dispose){for(var e,t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return(e=s.dispose).call.apply(e,[this].concat(n))}},render:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r,i=t[0];a({options:i,hidden:Boolean(o(i)),collapsible:l,collapsed:Boolean(h(i))}),"function"==typeof s.render&&(r=s.render).call.apply(r,[this].concat(t))}})}}},voiceSearch:function(e){var t=0<arguments.length&&void 0!==e?e:{},n=t.container,r=t.cssClasses,i=void 0===r?{}:r,a=t.templates,s=t.searchAsYouSpeak,o=void 0!==s&&s,c=t.language,u=t.additionalQueryParameters,l=t.createVoiceSearchHelper;if(!n)throw new Error(ms("The `container` option is required."));var h=ce(n),f={root:qr(ps(),i.root),button:qr(ps({descendantName:"button"}),i.button),status:qr(ps({descendantName:"status"}),i.status)};return Dr(cs,function(){return Ln(null,h)})({container:h,cssClasses:f,templates:D({},ds,{},a),searchAsYouSpeak:o,language:c,additionalQueryParameters:u,createVoiceSearchHelper:l})},queryRuleCustomData:function(e){var t=0<arguments.length&&void 0!==e?e:{},n=t.container,r=t.cssClasses,i=void 0===r?{}:r,a=t.templates,s=void 0===a?{}:a,o=t.transformItems,c=void 0===o?function(e){return e}:o;if(!n)throw new Error(vs("The `container` option is required."));var u={root:qr(gs(),i.root)},l=D({},{default:function(e){var t=e.items;return JSON.stringify(t,null,2)}},{},s),h=ce(n);return D({},Ar(ls,function(){Ln(null,h)})({container:h,cssClasses:u,templates:l,transformItems:c}),{$$type:"ais.queryRuleCustomData"})},queryRuleContext:function(e){var t=0<arguments.length&&void 0!==e?e:{},n=t.trackedFilters,r=t.transformRuleContexts;if(!n)throw new Error(ys("The `trackedFilters` option is required."));return D({},Ar(_e)({trackedFilters:n,transformRuleContexts:r}),{$$type:"ais.queryRuleContext"})},index:Ze,places:function(e){var t=e||{},n=t.placesReference,r=void 0===n?void 0:n,i=t.defaultPosition,o=void 0===i?[]:i,a=A(t,["placesReference","defaultPosition"]);if("function"!=typeof r)throw new Error("The `placesReference` option requires a valid Places.js reference.");var c=r(a),u={query:"",initialLatLngViaIP:void 0,isInitialLatLngViaIPSet:!1};return{$$type:"ais.places",init:function(e){var s=e.helper;c.on("change",function(e){var t=e.suggestion,n=t.value,r=t.latlng,i=r.lat,a=r.lng;u.query=n,s.setQueryParameter("insideBoundingBox",void 0).setQueryParameter("aroundLatLngViaIP",!1).setQueryParameter("aroundLatLng","".concat(i,",").concat(a)).search()}),c.on("clear",function(){u.query="",s.setQueryParameter("insideBoundingBox",void 0),1<o.length?s.setQueryParameter("aroundLatLngViaIP",!1).setQueryParameter("aroundLatLng",o.join(",")):s.setQueryParameter("aroundLatLngViaIP",u.initialLatLngViaIP).setQueryParameter("aroundLatLng",void 0),s.search()})},getWidgetState:function(e,t){var n=t.searchParameters.aroundLatLng||o.join(",");if(n!==o.join(",")||u.query)return D({},e,{places:{query:u.query,position:n}});e.places;return A(e,["places"])},getWidgetSearchParameters:function(e,t){var n=t.uiState.places||{},r=n.query,i=void 0===r?"":r,a=n.position,s=void 0===a?o.join(","):a;return u.query=i,u.isInitialLatLngViaIPSet||(u.isInitialLatLngViaIPSet=!0,u.initialLatLngViaIP=e.aroundLatLngViaIP),c.setVal(i),c.close(),e.setQueryParameter("insideBoundingBox",void 0).setQueryParameter("aroundLatLngViaIP",!1).setQueryParameter("aroundLatLng",s||void 0)}}}}),Rs=Object.freeze({__proto__:null,createInsightsMiddleware:function(e){var t=e||{},n=t.insightsClient,r=t.onEvent;if(null!==n&&!n)throw new Error("The `insightsClient` option is required. To disable, set it to `null`.");var s=Boolean(n),o=null===n?_e:n;return function(e){var a=e.instantSearchInstance;return o("_get","_hasCredentials",function(e){if(!e){var t=Q(function(e){if(e.transporter){var t=e.transporter,n=t.headers,r=t.queryParameters,i="x-algolia-application-id",a="x-algolia-api-key";return[n[i]||r[i],n[a]||r[a]]}return[e.applicationID,e.apiKey]}(a.client),2),n=t[0],r=t[1];o("_get","_userToken",function(e){}),o("init",{appId:n,apiKey:r})}}),{onStateChange:function(){},subscribe:function(){function i(e){e&&a.mainIndex.getHelper().setQueryParameter("userToken",e)}a.mainIndex.getHelper().setQueryParameter("clickAnalytics",!0),s&&i(ht()),Array.isArray(o.queue)&&o.queue.forEach(function(e){var t=Q(e,2),n=t[0],r=t[1];"setUserToken"===n&&i(r)}),o("onUserTokenChange",i,{immediate:!0}),a.sendEventToInsights=function(e){r?r(e,n):e.insightsMethod&&o(e.insightsMethod,e.payload)}},unsubscribe:function(){o("onUserTokenChange",void 0),a.sendEventToInsights=_e}}}},createRouterMiddleware:Qt}),ws=Object.freeze({__proto__:null,history:Bt});function Ss(e){e.configure;return A(e,["configure"])}var Ps=Object.freeze({__proto__:null,simple:dt,singleIndex:function(t){return{stateToRoute:function(e){return Ss(e[t]||{})},routeToState:function(e){return L({},t,Ss(0<arguments.length&&void 0!==e?e:{}))}}}});function _s(e){var t=e||{};t.page;return A(t,["page"])}var Ns="ais.infiniteHits";function xs(){return"undefined"!=typeof window&&void 0!==window.sessionStorage}function Fs(e){return new Wt(e)}return Fs.routers=ws,Fs.stateMappings=Ps,Fs.connectors=Qr,Fs.widgets=bs,Fs.version="4.8.3",Fs.createInfiniteHitsSessionStorageCache=function(){return{read:function(e){var t=e.state;if(!xs())return null;try{var n=JSON.parse(window.sessionStorage.getItem(Ns));return n&&Te(n.state,_s(t))?n.hits:null}catch(e){if(e instanceof SyntaxError)try{window.sessionStorage.removeItem(Ns)}catch(e){}return null}},write:function(e){var t=e.state,n=e.hits;if(xs())try{window.sessionStorage.setItem(Ns,JSON.stringify({state:_s(t),hits:n}))}catch(e){}}}},Fs.highlight=ot,Fs.snippet=ut,Fs.insights=lt,Fs.middlewares=Rs,Fs});
/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/@algolia/autocomplete-js@1.6.2/dist/umd/index.production.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*! @algolia/autocomplete-js 1.6.2 | MIT License | © Algolia, Inc. and contributors | https://github.com/algolia/autocomplete */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["@algolia/autocomplete-js"]={})}(this,(function(e){"use strict";function t(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function n(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?t(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):t(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},i.apply(this,arguments)}function u(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}function a(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,o,i=[],u=!0,a=!1;try{for(n=n.call(e);!(u=(r=n.next()).done)&&(i.push(r.value),!t||i.length!==t);u=!0);}catch(e){a=!0,o=e}finally{try{u||null==n.return||n.return()}finally{if(a)throw o}}return i}(e,t)||l(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function c(e){return function(e){if(Array.isArray(e))return s(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||l(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(e,t){if(e){if("string"==typeof e)return s(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?s(e,t):void 0}}function s(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function p(e){return{current:e}}function f(e,t){var n=void 0;return function(){for(var r=arguments.length,o=new Array(r),i=0;i<r;i++)o[i]=arguments[i];n&&clearTimeout(n),n=setTimeout((function(){return e.apply(void 0,o)}),t)}}function d(e){return e.reduce((function(e,t){return e.concat(t)}),[])}var m=0;function v(){return"autocomplete-".concat(m++)}function h(e,t){return t.reduce((function(e,t){return e&&e[t]}),e)}function g(e){return 0===e.collections.length?0:e.collections.reduce((function(e,t){return e+t.items.length}),0)}var y=function(){},b="1.6.2",O=[{segment:"autocomplete-core",version:b}];function _(e,t){var n=t;return{then:function(t,r){return _(e.then(j(t,n,e),j(r,n,e)),n)},catch:function(t){return _(e.catch(j(t,n,e)),n)},finally:function(t){return t&&n.onCancelList.push(t),_(e.finally(j(t&&function(){return n.onCancelList=[],t()},n,e)),n)},cancel:function(){n.isCanceled=!0;var e=n.onCancelList;n.onCancelList=[],e.forEach((function(e){e()}))},isCanceled:function(){return!0===n.isCanceled}}}function P(e){return _(e,{isCanceled:!1,onCancelList:[]})}function j(e,t,n){return e?function(n){return t.isCanceled?n:e(n)}:n}function w(e,t,n,r){if(!n)return null;if(e<0&&(null===t||null!==r&&0===t))return n+e;var o=(null===t?-1:t)+e;return o<=-1||o>=n?null===r?null:0:o}function S(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function I(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function E(e,t){var n=[];return Promise.resolve(e(t)).then((function(e){return Promise.all(e.filter((function(e){return Boolean(e)})).map((function(e){if(e.sourceId,n.includes(e.sourceId))throw new Error("[Autocomplete] The `sourceId` ".concat(JSON.stringify(e.sourceId)," is not unique."));n.push(e.sourceId);var t=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?S(Object(n),!0).forEach((function(t){I(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):S(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({getItemInputValue:function(e){return e.state.query},getItemUrl:function(){},onSelect:function(e){(0,e.setIsOpen)(!1)},onActive:y},e);return Promise.resolve(t)})))}))}function A(e){var t=function(e){var t=e.collections.map((function(e){return e.items.length})).reduce((function(e,t,n){var r=(e[n-1]||0)+t;return e.push(r),e}),[]).reduce((function(t,n){return n<=e.activeItemId?t+1:t}),0);return e.collections[t]}(e);if(!t)return null;var n=t.items[function(e){for(var t=e.state,n=e.collection,r=!1,o=0,i=0;!1===r;){var u=t.collections[o];if(u===n){r=!0;break}i+=u.items.length,o++}return t.activeItemId-i}({state:e,collection:t})],r=t.source;return{item:n,itemInputValue:r.getItemInputValue({item:n,state:e}),itemUrl:r.getItemUrl({item:n,state:e}),source:r}}var C=/((gt|sm)-|galaxy nexus)|samsung[- ]/i;function D(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function k(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?D(Object(n),!0).forEach((function(t){x(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):D(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function x(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function N(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function q(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function R(e,t,n){var r,o=t.initialState;return{getState:function(){return o},dispatch:function(r,i){var u=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?N(Object(n),!0).forEach((function(t){q(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):N(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},o);o=e(o,{type:r,props:t,payload:i}),n({state:o,prevState:u})},pendingRequests:(r=[],{add:function(e){return r.push(e),e.finally((function(){r=r.filter((function(t){return t!==e}))}))},cancelAll:function(){r.forEach((function(e){return e.cancel()}))},isEmpty:function(){return 0===r.length}})}}function L(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function T(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?L(Object(n),!0).forEach((function(t){B(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):L(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function B(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function F(e){return function(e){if(Array.isArray(e))return U(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return U(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return U(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function U(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function M(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function H(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?M(Object(n),!0).forEach((function(t){V(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):M(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function V(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function W(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Q(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?W(Object(n),!0).forEach((function(t){$(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):W(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function $(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function z(e){return function(e){if(Array.isArray(e))return G(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return G(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return G(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function G(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function K(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function J(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?K(Object(n),!0).forEach((function(t){Y(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):K(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Y(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function X(e){return Boolean(e.execute)}function Z(e,t){return n=e,Boolean(null==n?void 0:n.execute)?J(J({},e),{},{requests:e.queries.map((function(n){return{query:n,sourceId:t,transformResponse:e.transformResponse}}))}):{items:e,sourceId:t};var n}function ee(e){var t=e.reduce((function(e,t){if(!X(t))return e.push(t),e;var n=t.searchClient,r=t.execute,o=t.requesterId,i=t.requests,u=e.find((function(e){return X(t)&&X(e)&&e.searchClient===n&&Boolean(o)&&e.requesterId===o}));if(u){var a;(a=u.items).push.apply(a,z(i))}else{var c={execute:r,requesterId:o,items:i,searchClient:n};e.push(c)}return e}),[]).map((function(e){if(!X(e))return Promise.resolve(e);var t=e,n=t.execute,r=t.items;return n({searchClient:t.searchClient,requests:r})}));return Promise.all(t).then((function(e){return d(e)}))}function te(e,t){return t.map((function(t){var n=e.filter((function(e){return e.sourceId===t.sourceId})),r=n.map((function(e){return e.items})),o=n[0].transformResponse,i=o?o(function(e){var t=e.map((function(e){var t;return k(k({},e),{},{hits:null===(t=e.hits)||void 0===t?void 0:t.map((function(t){return k(k({},t),{},{__autocomplete_indexName:e.index,__autocomplete_queryID:e.queryID})}))})}));return{results:t,hits:t.map((function(e){return e.hits})).filter(Boolean),facetHits:t.map((function(e){var t;return null===(t=e.facetHits)||void 0===t?void 0:t.map((function(e){return{label:e.value,count:e.count,_highlightResult:{label:{value:e.highlighted}}}}))})).filter(Boolean)}}(r)):r;return i.every(Boolean),'The `getItems` function from source "'.concat(t.sourceId,'" must return an array of items but returned ').concat(JSON.stringify(void 0),".\n\nDid you forget to return items?\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems"),{source:t,items:i}}))}var ne=["event","nextState","props","query","refresh","store"];function re(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function oe(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?re(Object(n),!0).forEach((function(t){ie(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):re(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ie(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ue(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var ae,ce,le,se=null,pe=(ae=-1,ce=-1,le=void 0,function(e){var t=++ae;return Promise.resolve(e).then((function(e){return le&&t<ce?le:(ce=t,le=e,e)}))});function fe(e){var t=e.event,n=e.nextState,r=void 0===n?{}:n,o=e.props,i=e.query,u=e.refresh,a=e.store,c=ue(e,ne);se&&o.environment.clearTimeout(se);var l=c.setCollections,s=c.setIsOpen,p=c.setQuery,f=c.setActiveItemId,m=c.setStatus;if(p(i),f(o.defaultActiveItemId),!i&&!1===o.openOnFocus){var v,h=a.getState().collections.map((function(e){return oe(oe({},e),{},{items:[]})}));m("idle"),l(h),s(null!==(v=r.isOpen)&&void 0!==v?v:o.shouldPanelOpen({state:a.getState()}));var g=P(pe(h).then((function(){return Promise.resolve()})));return a.pendingRequests.add(g)}m("loading"),se=o.environment.setTimeout((function(){m("stalled")}),o.stallThreshold);var y=P(pe(o.getSources(oe({query:i,refresh:u,state:a.getState()},c)).then((function(e){return Promise.all(e.map((function(e){return Promise.resolve(e.getItems(oe({query:i,refresh:u,state:a.getState()},c))).then((function(t){return Z(t,e.sourceId)}))}))).then(ee).then((function(t){return te(t,e)})).then((function(e){return function(e){var t=e.collections,n=e.props,r=e.state,o=t.reduce((function(e,t){return Q(Q({},e),{},$({},t.source.sourceId,Q(Q({},t.source),{},{getItems:function(){return d(t.items)}})))}),{});return d(n.reshape({sources:Object.values(o),sourcesBySourceId:o,state:r})).filter(Boolean).map((function(e){return{source:e,items:e.getItems()}}))}({collections:e,props:o,state:a.getState()})}))})))).then((function(e){var n;m("idle"),l(e);var p=o.shouldPanelOpen({state:a.getState()});s(null!==(n=r.isOpen)&&void 0!==n?n:o.openOnFocus&&!i&&p||p);var f=A(a.getState());if(null!==a.getState().activeItemId&&f){var d=f.item,v=f.itemInputValue,h=f.itemUrl,g=f.source;g.onActive(oe({event:t,item:d,itemInputValue:v,itemUrl:h,refresh:u,source:g,state:a.getState()},c))}})).finally((function(){m("idle"),se&&o.environment.clearTimeout(se)}));return a.pendingRequests.add(y)}var de=["event","props","refresh","store"];function me(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function ve(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?me(Object(n),!0).forEach((function(t){he(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):me(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function he(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ge(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var ye=["props","refresh","store"],be=["inputElement","formElement","panelElement"],Oe=["inputElement"],_e=["inputElement","maxLength"],Pe=["item","source"];function je(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function we(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?je(Object(n),!0).forEach((function(t){Se(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):je(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Se(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Ie(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}function Ee(e){var t=e.props,n=e.refresh,r=e.store,o=Ie(e,ye);return{getEnvironmentProps:function(e){var n=e.inputElement,o=e.formElement,i=e.panelElement;return we({onTouchStart:function(e){!r.getState().isOpen&&r.pendingRequests.isEmpty()||e.target===n||!1===[o,i].some((function(t){return n=t,r=e.target,n===r||n.contains(r);var n,r}))&&(r.dispatch("blur",null),t.debug||r.pendingRequests.cancelAll())},onTouchMove:function(e){!1!==r.getState().isOpen&&n===t.environment.document.activeElement&&e.target!==n&&n.blur()}},Ie(e,be))},getRootProps:function(e){return we({role:"combobox","aria-expanded":r.getState().isOpen,"aria-haspopup":"listbox","aria-owns":r.getState().isOpen?"".concat(t.id,"-list"):void 0,"aria-labelledby":"".concat(t.id,"-label")},e)},getFormProps:function(e){return e.inputElement,we({action:"",noValidate:!0,role:"search",onSubmit:function(i){var u;i.preventDefault(),t.onSubmit(we({event:i,refresh:n,state:r.getState()},o)),r.dispatch("submit",null),null===(u=e.inputElement)||void 0===u||u.blur()},onReset:function(i){var u;i.preventDefault(),t.onReset(we({event:i,refresh:n,state:r.getState()},o)),r.dispatch("reset",null),null===(u=e.inputElement)||void 0===u||u.focus()}},Ie(e,Oe))},getLabelProps:function(e){return we({htmlFor:"".concat(t.id,"-input"),id:"".concat(t.id,"-label")},e)},getInputProps:function(e){var i;function u(e){(t.openOnFocus||Boolean(r.getState().query))&&fe(we({event:e,props:t,query:r.getState().completion||r.getState().query,refresh:n,store:r},o)),r.dispatch("focus",null)}var a="ontouchstart"in t.environment,c=e||{};c.inputElement;var l=c.maxLength,s=void 0===l?512:l,p=Ie(c,_e),f=A(r.getState()),d=function(e){return Boolean(e&&e.match(C))}(null===(i=t.environment.navigator)||void 0===i?void 0:i.userAgent),m=null!=f&&f.itemUrl&&!d?"go":"search";return we({"aria-autocomplete":"both","aria-activedescendant":r.getState().isOpen&&null!==r.getState().activeItemId?"".concat(t.id,"-item-").concat(r.getState().activeItemId):void 0,"aria-controls":r.getState().isOpen?"".concat(t.id,"-list"):void 0,"aria-labelledby":"".concat(t.id,"-label"),value:r.getState().completion||r.getState().query,id:"".concat(t.id,"-input"),autoComplete:"off",autoCorrect:"off",autoCapitalize:"off",enterKeyHint:m,spellCheck:"false",autoFocus:t.autoFocus,placeholder:t.placeholder,maxLength:s,type:"search",onChange:function(e){fe(we({event:e,props:t,query:e.currentTarget.value.slice(0,s),refresh:n,store:r},o))},onKeyDown:function(e){!function(e){var t=e.event,n=e.props,r=e.refresh,o=e.store,i=ge(e,de);if("ArrowUp"===t.key||"ArrowDown"===t.key){var u=function(){var e=n.environment.document.getElementById("".concat(n.id,"-item-").concat(o.getState().activeItemId));e&&(e.scrollIntoViewIfNeeded?e.scrollIntoViewIfNeeded(!1):e.scrollIntoView(!1))},a=function(){var e=A(o.getState());if(null!==o.getState().activeItemId&&e){var n=e.item,u=e.itemInputValue,a=e.itemUrl,c=e.source;c.onActive(ve({event:t,item:n,itemInputValue:u,itemUrl:a,refresh:r,source:c,state:o.getState()},i))}};t.preventDefault(),!1===o.getState().isOpen&&(n.openOnFocus||Boolean(o.getState().query))?fe(ve({event:t,props:n,query:o.getState().query,refresh:r,store:o},i)).then((function(){o.dispatch(t.key,{nextActiveItemId:n.defaultActiveItemId}),a(),setTimeout(u,0)})):(o.dispatch(t.key,{}),a(),u())}else if("Escape"===t.key)t.preventDefault(),o.dispatch(t.key,null),o.pendingRequests.cancelAll();else if("Enter"===t.key){if(null===o.getState().activeItemId||o.getState().collections.every((function(e){return 0===e.items.length})))return;t.preventDefault();var c=A(o.getState()),l=c.item,s=c.itemInputValue,p=c.itemUrl,f=c.source;if(t.metaKey||t.ctrlKey)void 0!==p&&(f.onSelect(ve({event:t,item:l,itemInputValue:s,itemUrl:p,refresh:r,source:f,state:o.getState()},i)),n.navigator.navigateNewTab({itemUrl:p,item:l,state:o.getState()}));else if(t.shiftKey)void 0!==p&&(f.onSelect(ve({event:t,item:l,itemInputValue:s,itemUrl:p,refresh:r,source:f,state:o.getState()},i)),n.navigator.navigateNewWindow({itemUrl:p,item:l,state:o.getState()}));else if(t.altKey);else{if(void 0!==p)return f.onSelect(ve({event:t,item:l,itemInputValue:s,itemUrl:p,refresh:r,source:f,state:o.getState()},i)),void n.navigator.navigate({itemUrl:p,item:l,state:o.getState()});fe(ve({event:t,nextState:{isOpen:!1},props:n,query:s,refresh:r,store:o},i)).then((function(){f.onSelect(ve({event:t,item:l,itemInputValue:s,itemUrl:p,refresh:r,source:f,state:o.getState()},i))}))}}}(we({event:e,props:t,refresh:n,store:r},o))},onFocus:u,onBlur:function(){a||(r.dispatch("blur",null),t.debug||r.pendingRequests.cancelAll())},onClick:function(n){e.inputElement!==t.environment.document.activeElement||r.getState().isOpen||u(n)}},p)},getPanelProps:function(e){return we({onMouseDown:function(e){e.preventDefault()},onMouseLeave:function(){r.dispatch("mouseleave",null)}},e)},getListProps:function(e){return we({role:"listbox","aria-labelledby":"".concat(t.id,"-label"),id:"".concat(t.id,"-list")},e)},getItemProps:function(e){var i=e.item,u=e.source,a=Ie(e,Pe);return we({id:"".concat(t.id,"-item-").concat(i.__autocomplete_id),role:"option","aria-selected":r.getState().activeItemId===i.__autocomplete_id,onMouseMove:function(e){if(i.__autocomplete_id!==r.getState().activeItemId){r.dispatch("mousemove",i.__autocomplete_id);var t=A(r.getState());if(null!==r.getState().activeItemId&&t){var u=t.item,a=t.itemInputValue,c=t.itemUrl,l=t.source;l.onActive(we({event:e,item:u,itemInputValue:a,itemUrl:c,refresh:n,source:l,state:r.getState()},o))}}},onMouseDown:function(e){e.preventDefault()},onClick:function(e){var a=u.getItemInputValue({item:i,state:r.getState()}),c=u.getItemUrl({item:i,state:r.getState()});(c?Promise.resolve():fe(we({event:e,nextState:{isOpen:!1},props:t,query:a,refresh:n,store:r},o))).then((function(){u.onSelect(we({event:e,item:i,itemInputValue:a,itemUrl:c,refresh:n,source:u,state:r.getState()},o))}))}},a)}}}function Ae(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Ce(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Ae(Object(n),!0).forEach((function(t){De(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Ae(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function De(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ke(e){var t,n,r,o,i=e.plugins,u=e.options,a=null===(t=((null===(n=u.__autocomplete_metadata)||void 0===n?void 0:n.userAgents)||[])[0])||void 0===t?void 0:t.segment,c=a?De({},a,Object.keys((null===(r=u.__autocomplete_metadata)||void 0===r?void 0:r.options)||{})):{};return{plugins:i.map((function(e){return{name:e.name,options:Object.keys(e.__autocomplete_pluginOptions||[])}})),options:Ce({"autocomplete-core":Object.keys(u)},c),ua:O.concat((null===(o=u.__autocomplete_metadata)||void 0===o?void 0:o.userAgents)||[])}}function xe(e){var t,n=e.state;return!1===n.isOpen||null===n.activeItemId?null:(null===(t=A(n))||void 0===t?void 0:t.itemInputValue)||null}function Ne(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function qe(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Ne(Object(n),!0).forEach((function(t){Re(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Ne(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Re(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var Le=function(e,t){switch(t.type){case"setActiveItemId":case"mousemove":return qe(qe({},e),{},{activeItemId:t.payload});case"setQuery":return qe(qe({},e),{},{query:t.payload,completion:null});case"setCollections":return qe(qe({},e),{},{collections:t.payload});case"setIsOpen":return qe(qe({},e),{},{isOpen:t.payload});case"setStatus":return qe(qe({},e),{},{status:t.payload});case"setContext":return qe(qe({},e),{},{context:qe(qe({},e.context),t.payload)});case"ArrowDown":var n=qe(qe({},e),{},{activeItemId:t.payload.hasOwnProperty("nextActiveItemId")?t.payload.nextActiveItemId:w(1,e.activeItemId,g(e),t.props.defaultActiveItemId)});return qe(qe({},n),{},{completion:xe({state:n})});case"ArrowUp":var r=qe(qe({},e),{},{activeItemId:w(-1,e.activeItemId,g(e),t.props.defaultActiveItemId)});return qe(qe({},r),{},{completion:xe({state:r})});case"Escape":return e.isOpen?qe(qe({},e),{},{activeItemId:null,isOpen:!1,completion:null}):qe(qe({},e),{},{activeItemId:null,query:"",status:"idle",collections:[]});case"submit":return qe(qe({},e),{},{activeItemId:null,isOpen:!1,status:"idle"});case"reset":return qe(qe({},e),{},{activeItemId:!0===t.props.openOnFocus?t.props.defaultActiveItemId:null,status:"idle",query:""});case"focus":return qe(qe({},e),{},{activeItemId:t.props.defaultActiveItemId,isOpen:(t.props.openOnFocus||Boolean(e.query))&&t.props.shouldPanelOpen({state:e})});case"blur":return t.props.debug?e:qe(qe({},e),{},{isOpen:!1,activeItemId:null});case"mouseleave":return qe(qe({},e),{},{activeItemId:t.props.defaultActiveItemId});default:return"The reducer action ".concat(JSON.stringify(t.type)," is not supported."),e}};function Te(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Be(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Te(Object(n),!0).forEach((function(t){Fe(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Te(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Fe(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Ue(e){var t=[],n=function(e,t){var n,r="undefined"!=typeof window?window:{},o=e.plugins||[];return H(H({debug:!1,openOnFocus:!1,placeholder:"",autoFocus:!1,defaultActiveItemId:null,stallThreshold:300,environment:r,shouldPanelOpen:function(e){return g(e.state)>0},reshape:function(e){return e.sources}},e),{},{id:null!==(n=e.id)&&void 0!==n?n:v(),plugins:o,initialState:H({activeItemId:null,query:"",completion:null,collections:[],isOpen:!1,status:"idle",context:{}},e.initialState),onStateChange:function(t){var n;null===(n=e.onStateChange)||void 0===n||n.call(e,t),o.forEach((function(e){var n;return null===(n=e.onStateChange)||void 0===n?void 0:n.call(e,t)}))},onSubmit:function(t){var n;null===(n=e.onSubmit)||void 0===n||n.call(e,t),o.forEach((function(e){var n;return null===(n=e.onSubmit)||void 0===n?void 0:n.call(e,t)}))},onReset:function(t){var n;null===(n=e.onReset)||void 0===n||n.call(e,t),o.forEach((function(e){var n;return null===(n=e.onReset)||void 0===n?void 0:n.call(e,t)}))},getSources:function(n){return Promise.all([].concat(F(o.map((function(e){return e.getSources}))),[e.getSources]).filter(Boolean).map((function(e){return E(e,n)}))).then((function(e){return d(e)})).then((function(e){return e.map((function(e){return H(H({},e),{},{onSelect:function(n){e.onSelect(n),t.forEach((function(e){var t;return null===(t=e.onSelect)||void 0===t?void 0:t.call(e,n)}))},onActive:function(n){e.onActive(n),t.forEach((function(e){var t;return null===(t=e.onActive)||void 0===t?void 0:t.call(e,n)}))}})}))}))},navigator:H({navigate:function(e){var t=e.itemUrl;r.location.assign(t)},navigateNewTab:function(e){var t=e.itemUrl,n=r.open(t,"_blank","noopener");null==n||n.focus()},navigateNewWindow:function(e){var t=e.itemUrl;r.open(t,"_blank","noopener")}},e.navigator)})}(e,t),r=R(Le,n,(function(e){var t=e.prevState,r=e.state;n.onStateChange(Be({prevState:t,state:r,refresh:u},o))})),o=function(e){var t=e.store;return{setActiveItemId:function(e){t.dispatch("setActiveItemId",e)},setQuery:function(e){t.dispatch("setQuery",e)},setCollections:function(e){var n=0,r=e.map((function(e){return T(T({},e),{},{items:d(e.items).map((function(e){return T(T({},e),{},{__autocomplete_id:n++})}))})}));t.dispatch("setCollections",r)},setIsOpen:function(e){t.dispatch("setIsOpen",e)},setStatus:function(e){t.dispatch("setStatus",e)},setContext:function(e){t.dispatch("setContext",e)}}}({store:r}),i=Ee(Be({props:n,refresh:u,store:r},o));function u(){return fe(Be({event:new Event("input"),nextState:{isOpen:r.getState().isOpen},props:n,query:r.getState().query,refresh:u,store:r},o))}return n.plugins.forEach((function(e){var n;return null===(n=e.subscribe)||void 0===n?void 0:n.call(e,Be(Be({},o),{},{refresh:u,onSelect:function(e){t.push({onSelect:e})},onActive:function(e){t.push({onActive:e})}}))})),function(e){var t,n=e.metadata,r=e.environment;if(null===(t=r.navigator)||void 0===t?void 0:t.userAgent.includes("Algolia Crawler")){var o=r.document.createElement("meta"),i=r.document.querySelector("head");o.name="algolia:metadata",setTimeout((function(){o.content=JSON.stringify(n),i.appendChild(o)}),0)}}({metadata:ke({plugins:n.plugins,options:e}),environment:n.environment}),Be(Be({refresh:u},i),o)}var Me=function(e,t,n,r){var o;t[0]=0;for(var i=1;i<t.length;i++){var u=t[i++],a=t[i]?(t[0]|=u?1:2,n[t[i++]]):t[++i];3===u?r[0]=a:4===u?r[1]=Object.assign(r[1]||{},a):5===u?(r[1]=r[1]||{})[t[++i]]=a:6===u?r[1][t[++i]]+=a+"":u?(o=e.apply(a,Me(e,a,n,["",null])),r.push(o),a[0]?t[0]|=2:(t[i-2]=0,t[i]=o)):r.push(a)}return r},He=new Map;function Ve(e){var t=He.get(this);return t||(t=new Map,He.set(this,t)),(t=Me(this,t.get(e)||(t.set(e,t=function(e){for(var t,n,r=1,o="",i="",u=[0],a=function(e){1===r&&(e||(o=o.replace(/^\s*\n\s*|\s*\n\s*$/g,"")))?u.push(0,e,o):3===r&&(e||o)?(u.push(3,e,o),r=2):2===r&&"..."===o&&e?u.push(4,e,0):2===r&&o&&!e?u.push(5,0,!0,o):r>=5&&((o||!e&&5===r)&&(u.push(r,0,o,n),r=6),e&&(u.push(r,e,0,n),r=6)),o=""},c=0;c<e.length;c++){c&&(1===r&&a(),a(c));for(var l=0;l<e[c].length;l++)t=e[c][l],1===r?"<"===t?(a(),u=[u],r=3):o+=t:4===r?"--"===o&&">"===t?(r=1,o=""):o=t+o[0]:i?t===i?i="":o+=t:'"'===t||"'"===t?i=t:">"===t?(a(),r=1):r&&("="===t?(r=5,n=o,o=""):"/"===t&&(r<5||">"===e[c][l+1])?(a(),3===r&&(u=u[0]),r=u,(u=u[0]).push(2,0,r),r=0):" "===t||"\t"===t||"\n"===t||"\r"===t?(a(),r=2):o+=t),3===r&&"!--"===o&&(r=4,u=u[0])}return a(),u}(e)),t),arguments,[])).length>1?t:t[0]}var We=function(e){var t=e.environment,n=t.document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttribute("class","aa-ClearIcon"),n.setAttribute("viewBox","0 0 24 24"),n.setAttribute("width","18"),n.setAttribute("height","18"),n.setAttribute("fill","currentColor");var r=t.document.createElementNS("http://www.w3.org/2000/svg","path");return r.setAttribute("d","M5.293 6.707l5.293 5.293-5.293 5.293c-0.391 0.391-0.391 1.024 0 1.414s1.024 0.391 1.414 0l5.293-5.293 5.293 5.293c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414l-5.293-5.293 5.293-5.293c0.391-0.391 0.391-1.024 0-1.414s-1.024-0.391-1.414 0l-5.293 5.293-5.293-5.293c-0.391-0.391-1.024-0.391-1.414 0s-0.391 1.024 0 1.414z"),n.appendChild(r),n};function Qe(e,t){if("string"==typeof t){var n=e.document.querySelector(t);return"The element ".concat(JSON.stringify(t)," is not in the document."),n}return t}function $e(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce((function(e,t){return Object.keys(t).forEach((function(n){var r=e[n],o=t[n];r!==o&&(e[n]=[r,o].filter(Boolean).join(" "))})),e}),{})}var ze=function(e){return e&&"object"===r(e)&&"[object Object]"===Object.prototype.toString.call(e)};function Ge(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce((function(e,t){return Object.keys(t).forEach((function(n){var r=e[n],o=t[n];Array.isArray(r)&&Array.isArray(o)?e[n]=r.concat.apply(r,c(o)):ze(r)&&ze(o)?e[n]=Ge(r,o):e[n]=o})),e}),{})}function Ke(e,t){return Object.entries(e).reduce((function(e,r){var i=a(r,2),u=i[0],c=i[1];return t({key:u,value:c})?n(n({},e),{},o({},u,c)):e}),{})}var Je=["ontouchstart","ontouchend","ontouchmove","ontouchcancel"];function Ye(e,t,n){e[t]=null===n?"":"number"!=typeof n?n:n+"px"}function Xe(e){this._listeners[e.type](e)}function Ze(e,t,n){var r,o,i=e[t];if("style"===t)if("string"==typeof n)e.style=n;else if(null===n)e.style="";else for(t in n)i&&n[t]===i[t]||Ye(e.style,t,n[t]);else"o"===t[0]&&"n"===t[1]?(r=t!==(t=t.replace(/Capture$/,"")),((o=t.toLowerCase())in e||Je.includes(o))&&(t=o),t=t.slice(2),e._listeners||(e._listeners={}),e._listeners[t]=n,n?i||e.addEventListener(t,Xe,r):e.removeEventListener(t,Xe,r)):"list"!==t&&"tagName"!==t&&"form"!==t&&"type"!==t&&"size"!==t&&"download"!==t&&"href"!==t&&t in e?e[t]=null==n?"":n:"function"!=typeof n&&"dangerouslySetInnerHTML"!==t&&(null==n||!1===n&&!/^ar/.test(t)?e.removeAttribute(t):e.setAttribute(t,n))}function et(e){return"onChange"===e?"onInput":e}function tt(e,t){for(var n in t)Ze(e,et(n),t[n])}function nt(e,t){for(var n in t)"o"===n[0]&&"n"===n[1]||Ze(e,et(n),t[n])}var rt=["children"];function ot(e){return function(t,n){var r=n.children,o=void 0===r?[]:r,i=u(n,rt),a=e.document.createElement(t);return tt(a,i),a.append.apply(a,c(o)),a}}var it=["autocompleteScopeApi","environment","classNames","getInputProps","getInputPropsCore","onDetachedEscape","state"],ut=function(e){var t=e.environment.document.createElementNS("http://www.w3.org/2000/svg","svg");return t.setAttribute("class","aa-LoadingIcon"),t.setAttribute("viewBox","0 0 100 100"),t.setAttribute("width","20"),t.setAttribute("height","20"),t.innerHTML='<circle\n  cx="50"\n  cy="50"\n  fill="none"\n  r="35"\n  stroke="currentColor"\n  stroke-dasharray="164.93361431346415 56.97787143782138"\n  stroke-width="6"\n>\n  <animateTransform\n    attributeName="transform"\n    type="rotate"\n    repeatCount="indefinite"\n    dur="1s"\n    values="0 50 50;90 50 50;180 50 50;360 50 50"\n    keyTimes="0;0.40;0.65;1"\n  />\n</circle>',t},at=function(e){var t=e.environment,n=t.document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttribute("class","aa-SubmitIcon"),n.setAttribute("viewBox","0 0 24 24"),n.setAttribute("width","20"),n.setAttribute("height","20"),n.setAttribute("fill","currentColor");var r=t.document.createElementNS("http://www.w3.org/2000/svg","path");return r.setAttribute("d","M16.041 15.856c-0.034 0.026-0.067 0.055-0.099 0.087s-0.060 0.064-0.087 0.099c-1.258 1.213-2.969 1.958-4.855 1.958-1.933 0-3.682-0.782-4.95-2.050s-2.050-3.017-2.050-4.95 0.782-3.682 2.050-4.95 3.017-2.050 4.95-2.050 3.682 0.782 4.95 2.050 2.050 3.017 2.050 4.95c0 1.886-0.745 3.597-1.959 4.856zM21.707 20.293l-3.675-3.675c1.231-1.54 1.968-3.493 1.968-5.618 0-2.485-1.008-4.736-2.636-6.364s-3.879-2.636-6.364-2.636-4.736 1.008-6.364 2.636-2.636 3.879-2.636 6.364 1.008 4.736 2.636 6.364 3.879 2.636 6.364 2.636c2.125 0 4.078-0.737 5.618-1.968l3.675 3.675c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414z"),n.appendChild(r),n};function ct(e){var t=e.autocomplete,r=e.autocompleteScopeApi,o=e.classNames,i=e.environment,a=e.isDetached,c=e.placeholder,l=void 0===c?"Search":c,s=e.propGetters,p=e.setIsModalOpen,f=e.state,d=e.translations,m=ot(i),v=s.getRootProps(n({state:f,props:t.getRootProps({})},r)),h=m("div",n({class:o.root},v)),g=m("div",{class:o.detachedContainer,onMouseDown:function(e){e.stopPropagation()}}),y=m("div",{class:o.detachedOverlay,children:[g],onMouseDown:function(){p(!1),t.setIsOpen(!1)}}),b=s.getLabelProps(n({state:f,props:t.getLabelProps({})},r)),O=m("button",{class:o.submitButton,type:"submit",title:d.submitButtonTitle,children:[at({environment:i})]}),_=m("label",n({class:o.label,children:[O]},b)),P=m("button",{class:o.clearButton,type:"reset",title:d.clearButtonTitle,children:[We({environment:i})]}),j=m("div",{class:o.loadingIndicator,children:[ut({environment:i})]}),w=function(e){var t=e.autocompleteScopeApi,r=e.environment;e.classNames;var o=e.getInputProps,i=e.getInputPropsCore,a=e.onDetachedEscape,c=e.state,l=u(e,it),s=ot(r)("input",l),p=o(n({state:c,props:i({inputElement:s}),inputElement:s},t));return tt(s,n(n({},p),{},{onKeyDown:function(e){if(a&&"Escape"===e.key)return e.preventDefault(),void a();p.onKeyDown(e)}})),s}({class:o.input,environment:i,state:f,getInputProps:s.getInputProps,getInputPropsCore:t.getInputProps,autocompleteScopeApi:r,onDetachedEscape:a?function(){t.setIsOpen(!1),p(!1)}:void 0}),S=m("div",{class:o.inputWrapperPrefix,children:[_,j]}),I=m("div",{class:o.inputWrapperSuffix,children:[P]}),E=m("div",{class:o.inputWrapper,children:[w]}),A=s.getFormProps(n({state:f,props:t.getFormProps({inputElement:w})},r)),C=m("form",n({class:o.form,children:[S,E,I]},A)),D=s.getPanelProps(n({state:f,props:t.getPanelProps({})},r)),k=m("div",n({class:o.panel},D));if(a){var x=m("div",{class:o.detachedSearchButtonIcon,children:[at({environment:i})]}),N=m("div",{class:o.detachedSearchButtonPlaceholder,textContent:l}),q=m("button",{type:"button",class:o.detachedSearchButton,onClick:function(){p(!0)},children:[x,N]}),R=m("button",{type:"button",class:o.detachedCancelButton,textContent:d.detachedCancelButtonText,onTouchStart:function(e){e.stopPropagation()},onClick:function(){t.setIsOpen(!1),p(!1)}}),L=m("div",{class:o.detachedFormContainer,children:[C,R]});g.appendChild(L),h.appendChild(q)}else h.appendChild(C);return{detachedContainer:g,detachedOverlay:y,inputWrapper:E,input:w,root:h,form:C,label:_,submitButton:O,clearButton:P,loadingIndicator:j,panel:k}}var lt,st,pt,ft,dt,mt,vt={},ht=[],gt=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function yt(e,t){for(var n in t)e[n]=t[n];return e}function bt(e){var t=e.parentNode;t&&t.removeChild(e)}function Ot(e,t,n){var r,o,i,u={};for(i in t)"key"==i?r=t[i]:"ref"==i?o=t[i]:u[i]=t[i];if(arguments.length>2&&(u.children=arguments.length>3?lt.call(arguments,2):n),"function"==typeof e&&null!=e.defaultProps)for(i in e.defaultProps)void 0===u[i]&&(u[i]=e.defaultProps[i]);return _t(e,u,r,o,null)}function _t(e,t,n,r,o){var i={type:e,props:t,key:n,ref:r,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++pt:o};return null==o&&null!=st.vnode&&st.vnode(i),i}function Pt(e){return e.children}function jt(e,t){this.props=e,this.context=t}function wt(e,t){if(null==t)return e.__?wt(e.__,e.__.__k.indexOf(e)+1):null;for(var n;t<e.__k.length;t++)if(null!=(n=e.__k[t])&&null!=n.__e)return n.__e;return"function"==typeof e.type?wt(e):null}function St(e){var t,n;if(null!=(e=e.__)&&null!=e.__c){for(e.__e=e.__c.base=null,t=0;t<e.__k.length;t++)if(null!=(n=e.__k[t])&&null!=n.__e){e.__e=e.__c.base=n.__e;break}return St(e)}}function It(e){(!e.__d&&(e.__d=!0)&&ft.push(e)&&!Et.__r++||mt!==st.debounceRendering)&&((mt=st.debounceRendering)||dt)(Et)}function Et(){for(var e;Et.__r=ft.length;)e=ft.sort((function(e,t){return e.__v.__b-t.__v.__b})),ft=[],e.some((function(e){var t,n,r,o,i,u;e.__d&&(i=(o=(t=e).__v).__e,(u=t.__P)&&(n=[],(r=yt({},o)).__v=o.__v+1,Rt(u,o,r,t.__n,void 0!==u.ownerSVGElement,null!=o.__h?[i]:null,n,null==i?wt(o):i,o.__h),Lt(n,o),o.__e!=i&&St(o)))}))}function At(e,t,n,r,o,i,u,a,c,l){var s,p,f,d,m,v,h,g=r&&r.__k||ht,y=g.length;for(n.__k=[],s=0;s<t.length;s++)if(null!=(d=n.__k[s]=null==(d=t[s])||"boolean"==typeof d?null:"string"==typeof d||"number"==typeof d||"bigint"==typeof d?_t(null,d,null,null,d):Array.isArray(d)?_t(Pt,{children:d},null,null,null):d.__b>0?_t(d.type,d.props,d.key,null,d.__v):d)){if(d.__=n,d.__b=n.__b+1,null===(f=g[s])||f&&d.key==f.key&&d.type===f.type)g[s]=void 0;else for(p=0;p<y;p++){if((f=g[p])&&d.key==f.key&&d.type===f.type){g[p]=void 0;break}f=null}Rt(e,d,f=f||vt,o,i,u,a,c,l),m=d.__e,(p=d.ref)&&f.ref!=p&&(h||(h=[]),f.ref&&h.push(f.ref,null,d),h.push(p,d.__c||m,d)),null!=m?(null==v&&(v=m),"function"==typeof d.type&&d.__k===f.__k?d.__d=c=Ct(d,c,e):c=Dt(e,d,f,g,m,c),"function"==typeof n.type&&(n.__d=c)):c&&f.__e==c&&c.parentNode!=e&&(c=wt(f))}for(n.__e=v,s=y;s--;)null!=g[s]&&("function"==typeof n.type&&null!=g[s].__e&&g[s].__e==n.__d&&(n.__d=wt(r,s+1)),Ft(g[s],g[s]));if(h)for(s=0;s<h.length;s++)Bt(h[s],h[++s],h[++s])}function Ct(e,t,n){for(var r,o=e.__k,i=0;o&&i<o.length;i++)(r=o[i])&&(r.__=e,t="function"==typeof r.type?Ct(r,t,n):Dt(n,r,r,o,r.__e,t));return t}function Dt(e,t,n,r,o,i){var u,a,c;if(void 0!==t.__d)u=t.__d,t.__d=void 0;else if(null==n||o!=i||null==o.parentNode)e:if(null==i||i.parentNode!==e)e.appendChild(o),u=null;else{for(a=i,c=0;(a=a.nextSibling)&&c<r.length;c+=2)if(a==o)break e;e.insertBefore(o,i),u=i}return void 0!==u?u:o.nextSibling}function kt(e,t,n){"-"===t[0]?e.setProperty(t,n):e[t]=null==n?"":"number"!=typeof n||gt.test(t)?n:n+"px"}function xt(e,t,n,r,o){var i;e:if("style"===t)if("string"==typeof n)e.style.cssText=n;else{if("string"==typeof r&&(e.style.cssText=r=""),r)for(t in r)n&&t in n||kt(e.style,t,"");if(n)for(t in n)r&&n[t]===r[t]||kt(e.style,t,n[t])}else if("o"===t[0]&&"n"===t[1])i=t!==(t=t.replace(/Capture$/,"")),t=t.toLowerCase()in e?t.toLowerCase().slice(2):t.slice(2),e.l||(e.l={}),e.l[t+i]=n,n?r||e.addEventListener(t,i?qt:Nt,i):e.removeEventListener(t,i?qt:Nt,i);else if("dangerouslySetInnerHTML"!==t){if(o)t=t.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==t&&"list"!==t&&"form"!==t&&"tabIndex"!==t&&"download"!==t&&t in e)try{e[t]=null==n?"":n;break e}catch(e){}"function"==typeof n||(null!=n&&(!1!==n||"a"===t[0]&&"r"===t[1])?e.setAttribute(t,n):e.removeAttribute(t))}}function Nt(e){this.l[e.type+!1](st.event?st.event(e):e)}function qt(e){this.l[e.type+!0](st.event?st.event(e):e)}function Rt(e,t,n,r,o,i,u,a,c){var l,s,p,f,d,m,v,h,g,y,b,O=t.type;if(void 0!==t.constructor)return null;null!=n.__h&&(c=n.__h,a=t.__e=n.__e,t.__h=null,i=[a]),(l=st.__b)&&l(t);try{e:if("function"==typeof O){if(h=t.props,g=(l=O.contextType)&&r[l.__c],y=l?g?g.props.value:l.__:r,n.__c?v=(s=t.__c=n.__c).__=s.__E:("prototype"in O&&O.prototype.render?t.__c=s=new O(h,y):(t.__c=s=new jt(h,y),s.constructor=O,s.render=Ut),g&&g.sub(s),s.props=h,s.state||(s.state={}),s.context=y,s.__n=r,p=s.__d=!0,s.__h=[]),null==s.__s&&(s.__s=s.state),null!=O.getDerivedStateFromProps&&(s.__s==s.state&&(s.__s=yt({},s.__s)),yt(s.__s,O.getDerivedStateFromProps(h,s.__s))),f=s.props,d=s.state,p)null==O.getDerivedStateFromProps&&null!=s.componentWillMount&&s.componentWillMount(),null!=s.componentDidMount&&s.__h.push(s.componentDidMount);else{if(null==O.getDerivedStateFromProps&&h!==f&&null!=s.componentWillReceiveProps&&s.componentWillReceiveProps(h,y),!s.__e&&null!=s.shouldComponentUpdate&&!1===s.shouldComponentUpdate(h,s.__s,y)||t.__v===n.__v){s.props=h,s.state=s.__s,t.__v!==n.__v&&(s.__d=!1),s.__v=t,t.__e=n.__e,t.__k=n.__k,t.__k.forEach((function(e){e&&(e.__=t)})),s.__h.length&&u.push(s);break e}null!=s.componentWillUpdate&&s.componentWillUpdate(h,s.__s,y),null!=s.componentDidUpdate&&s.__h.push((function(){s.componentDidUpdate(f,d,m)}))}s.context=y,s.props=h,s.state=s.__s,(l=st.__r)&&l(t),s.__d=!1,s.__v=t,s.__P=e,l=s.render(s.props,s.state,s.context),s.state=s.__s,null!=s.getChildContext&&(r=yt(yt({},r),s.getChildContext())),p||null==s.getSnapshotBeforeUpdate||(m=s.getSnapshotBeforeUpdate(f,d)),b=null!=l&&l.type===Pt&&null==l.key?l.props.children:l,At(e,Array.isArray(b)?b:[b],t,n,r,o,i,u,a,c),s.base=t.__e,t.__h=null,s.__h.length&&u.push(s),v&&(s.__E=s.__=null),s.__e=!1}else null==i&&t.__v===n.__v?(t.__k=n.__k,t.__e=n.__e):t.__e=Tt(n.__e,t,n,r,o,i,u,c);(l=st.diffed)&&l(t)}catch(e){t.__v=null,(c||null!=i)&&(t.__e=a,t.__h=!!c,i[i.indexOf(a)]=null),st.__e(e,t,n)}}function Lt(e,t){st.__c&&st.__c(t,e),e.some((function(t){try{e=t.__h,t.__h=[],e.some((function(e){e.call(t)}))}catch(e){st.__e(e,t.__v)}}))}function Tt(e,t,n,r,o,i,u,a){var c,l,s,p=n.props,f=t.props,d=t.type,m=0;if("svg"===d&&(o=!0),null!=i)for(;m<i.length;m++)if((c=i[m])&&"setAttribute"in c==!!d&&(d?c.localName===d:3===c.nodeType)){e=c,i[m]=null;break}if(null==e){if(null===d)return document.createTextNode(f);e=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,f.is&&f),i=null,a=!1}if(null===d)p===f||a&&e.data===f||(e.data=f);else{if(i=i&&lt.call(e.childNodes),l=(p=n.props||vt).dangerouslySetInnerHTML,s=f.dangerouslySetInnerHTML,!a){if(null!=i)for(p={},m=0;m<e.attributes.length;m++)p[e.attributes[m].name]=e.attributes[m].value;(s||l)&&(s&&(l&&s.__html==l.__html||s.__html===e.innerHTML)||(e.innerHTML=s&&s.__html||""))}if(function(e,t,n,r,o){var i;for(i in n)"children"===i||"key"===i||i in t||xt(e,i,null,n[i],r);for(i in t)o&&"function"!=typeof t[i]||"children"===i||"key"===i||"value"===i||"checked"===i||n[i]===t[i]||xt(e,i,t[i],n[i],r)}(e,f,p,o,a),s)t.__k=[];else if(m=t.props.children,At(e,Array.isArray(m)?m:[m],t,n,r,o&&"foreignObject"!==d,i,u,i?i[0]:n.__k&&wt(n,0),a),null!=i)for(m=i.length;m--;)null!=i[m]&&bt(i[m]);a||("value"in f&&void 0!==(m=f.value)&&(m!==p.value||m!==e.value||"progress"===d&&!m)&&xt(e,"value",m,p.value,!1),"checked"in f&&void 0!==(m=f.checked)&&m!==e.checked&&xt(e,"checked",m,p.checked,!1))}return e}function Bt(e,t,n){try{"function"==typeof e?e(t):e.current=t}catch(e){st.__e(e,n)}}function Ft(e,t,n){var r,o;if(st.unmount&&st.unmount(e),(r=e.ref)&&(r.current&&r.current!==e.__e||Bt(r,null,t)),null!=(r=e.__c)){if(r.componentWillUnmount)try{r.componentWillUnmount()}catch(e){st.__e(e,t)}r.base=r.__P=null}if(r=e.__k)for(o=0;o<r.length;o++)r[o]&&Ft(r[o],t,"function"!=typeof e.type);n||null==e.__e||bt(e.__e),e.__e=e.__d=void 0}function Ut(e,t,n){return this.constructor(e,n)}lt=ht.slice,st={__e:function(e,t){for(var n,r,o;t=t.__;)if((n=t.__c)&&!n.__)try{if((r=n.constructor)&&null!=r.getDerivedStateFromError&&(n.setState(r.getDerivedStateFromError(e)),o=n.__d),null!=n.componentDidCatch&&(n.componentDidCatch(e),o=n.__d),o)return n.__E=n}catch(t){e=t}throw e}},pt=0,jt.prototype.setState=function(e,t){var n;n=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=yt({},this.state),"function"==typeof e&&(e=e(yt({},n),this.props)),e&&yt(n,e),null!=e&&this.__v&&(t&&this.__h.push(t),It(this))},jt.prototype.forceUpdate=function(e){this.__v&&(this.__e=!0,e&&this.__h.push(e),It(this))},jt.prototype.render=Pt,ft=[],dt="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,Et.__r=0;var Mt="__aa-highlight__",Ht="__/aa-highlight__";function Vt(e){var t=e.highlightedValue.split(Mt),n=t.shift(),r=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return{get:function(){return e},add:function(t){var n=e[e.length-1];(null==n?void 0:n.isHighlighted)===t.isHighlighted?e[e.length-1]={value:n.value+t.value,isHighlighted:n.isHighlighted}:e.push(t)}}}(n?[{value:n,isHighlighted:!1}]:[]);return t.forEach((function(e){var t=e.split(Ht);r.add({value:t[0],isHighlighted:!0}),""!==t[1]&&r.add({value:t[1],isHighlighted:!1})})),r.get()}function Wt(e){return function(e){if(Array.isArray(e))return Qt(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return Qt(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Qt(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Qt(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function $t(e){var t=e.hit,n=e.attribute,r=Array.isArray(n)?n:[n],o=h(t,["_highlightResult"].concat(Wt(r),["value"]));return"string"!=typeof o&&(o=h(t,r)||""),Vt({highlightedValue:o})}var zt={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Gt=new RegExp(/\w/i),Kt=/&(amp|quot|lt|gt|#39);/g,Jt=RegExp(Kt.source);function Yt(e,t){var n,r,o,i=e[t],u=(null===(n=e[t+1])||void 0===n?void 0:n.isHighlighted)||!0,a=(null===(r=e[t-1])||void 0===r?void 0:r.isHighlighted)||!0;return Gt.test((o=i.value)&&Jt.test(o)?o.replace(Kt,(function(e){return zt[e]})):o)||a!==u?i.isHighlighted:a}function Xt(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Zt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Xt(Object(n),!0).forEach((function(t){en(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Xt(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function en(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function tn(e){return e.some((function(e){return e.isHighlighted}))?e.map((function(t,n){return Zt(Zt({},t),{},{isHighlighted:!Yt(e,n)})})):e.map((function(e){return Zt(Zt({},e),{},{isHighlighted:!1})}))}function nn(e){return function(e){if(Array.isArray(e))return rn(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return rn(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return rn(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function rn(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function on(e){var t=e.hit,n=e.attribute,r=Array.isArray(n)?n:[n],o=h(t,["_snippetResult"].concat(nn(r),["value"]));return"string"!=typeof o&&(o=h(t,r)||""),Vt({highlightedValue:o})}function un(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function an(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?un(Object(n),!0).forEach((function(t){cn(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):un(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function cn(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var ln=["params"];function sn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function pn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?sn(Object(n),!0).forEach((function(t){fn(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):sn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function fn(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function dn(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}function mn(e){return function(e){if(Array.isArray(e))return vn(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return vn(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return vn(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function vn(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function hn(e){var t=e.createElement,n=e.Fragment;function r(e){var r=e.hit,o=e.attribute,i=e.tagName,u=void 0===i?"mark":i;return t(n,{},$t({hit:r,attribute:o}).map((function(e,n){return e.isHighlighted?t(u,{key:n},e.value):e.value})))}return r.__autocomplete_componentName="Highlight",r}function gn(e){var t=e.createElement,n=e.Fragment;function r(e){var r,o=e.hit,i=e.attribute,u=e.tagName,a=void 0===u?"mark":u;return t(n,{},(r={hit:o,attribute:i},tn($t(r))).map((function(e,n){return e.isHighlighted?t(a,{key:n},e.value):e.value})))}return r.__autocomplete_componentName="ReverseHighlight",r}function yn(e){var t=e.createElement,n=e.Fragment;function r(e){var r,o=e.hit,i=e.attribute,u=e.tagName,a=void 0===u?"mark":u;return t(n,{},(r={hit:o,attribute:i},tn(on(r))).map((function(e,n){return e.isHighlighted?t(a,{key:n},e.value):e.value})))}return r.__autocomplete_componentName="ReverseSnippet",r}function bn(e){var t=e.createElement,n=e.Fragment;function r(e){var r=e.hit,o=e.attribute,i=e.tagName,u=void 0===i?"mark":i;return t(n,{},on({hit:r,attribute:o}).map((function(e,n){return e.isHighlighted?t(u,{key:n},e.value):e.value})))}return r.__autocomplete_componentName="Snippet",r}var On=["classNames","container","getEnvironmentProps","getFormProps","getInputProps","getItemProps","getLabelProps","getListProps","getPanelProps","getRootProps","panelContainer","panelPlacement","render","renderNoResults","renderer","detachedMediaQuery","components","translations"],_n={clearButton:"aa-ClearButton",detachedCancelButton:"aa-DetachedCancelButton",detachedContainer:"aa-DetachedContainer",detachedFormContainer:"aa-DetachedFormContainer",detachedOverlay:"aa-DetachedOverlay",detachedSearchButton:"aa-DetachedSearchButton",detachedSearchButtonIcon:"aa-DetachedSearchButtonIcon",detachedSearchButtonPlaceholder:"aa-DetachedSearchButtonPlaceholder",form:"aa-Form",input:"aa-Input",inputWrapper:"aa-InputWrapper",inputWrapperPrefix:"aa-InputWrapperPrefix",inputWrapperSuffix:"aa-InputWrapperSuffix",item:"aa-Item",label:"aa-Label",list:"aa-List",loadingIndicator:"aa-LoadingIndicator",panel:"aa-Panel",panelLayout:"aa-PanelLayout aa-Panel--scrollable",root:"aa-Autocomplete",source:"aa-Source",sourceFooter:"aa-SourceFooter",sourceHeader:"aa-SourceHeader",sourceNoResults:"aa-SourceNoResults",submitButton:"aa-SubmitButton"},Pn=function(e,t){var n=e.children;(0,e.render)(n,t)},jn={createElement:Ot,Fragment:Pt,render:function(e,t,n){var r,o,i;st.__&&st.__(e,t),o=(r="function"==typeof n)?null:n&&n.__k||t.__k,i=[],Rt(t,e=(!r&&n||t).__k=Ot(Pt,null,[e]),o||vt,vt,void 0!==t.ownerSVGElement,!r&&n?[n]:o?null:t.firstChild?lt.call(t.childNodes):null,i,!r&&n?n:o?o.__e:t.firstChild,r),Lt(i,e)}};function wn(e){var t=e.panelPlacement,n=e.container,r=e.form,o=e.environment,i=n.getBoundingClientRect(),u=(o.pageYOffset||o.document.documentElement.scrollTop||o.document.body.scrollTop||0)+i.top+i.height;switch(t){case"start":return{top:u,left:i.left};case"end":return{top:u,right:o.document.documentElement.clientWidth-(i.left+i.width)};case"full-width":return{top:u,left:0,right:0,width:"unset",maxWidth:"unset"};case"input-wrapper-width":var a=r.getBoundingClientRect();return{top:u,left:a.left,right:o.document.documentElement.clientWidth-(a.left+a.width),width:"unset",maxWidth:"unset"};default:throw new Error("[Autocomplete] The `panelPlacement` value ".concat(JSON.stringify(t)," is not valid."))}}var Sn=[{segment:"autocomplete-js",version:b}],In=["components"];var En=function(e,t){function n(t){return e({searchClient:t.searchClient,queries:t.requests.map((function(e){return e.query}))}).then((function(e){return e.map((function(e,n){var r=t.requests[n];return{items:e,sourceId:r.sourceId,transformResponse:r.transformResponse}}))}))}return function(e){return function(r){return an(an({requesterId:t,execute:n},e),r)}}}((function(e){return function(e){var t=e.searchClient,n=e.queries,r=e.userAgents,o=void 0===r?[]:r;return"function"==typeof t.addAlgoliaAgent&&[].concat(mn(O),mn(o)).forEach((function(e){var n=e.segment,r=e.version;t.addAlgoliaAgent(n,r)})),t.search(n.map((function(e){var t=e.params;return pn(pn({},dn(e,ln)),{},{params:pn({hitsPerPage:5,highlightPreTag:Mt,highlightPostTag:Ht},t)})}))).then((function(e){return e.results}))}(n(n({},e),{},{userAgents:Sn}))}),"algolia");var An=En({transformResponse:function(e){return e.hits}});e.autocomplete=function(e){var t,r=function(){var e=[],t=[];function n(n){e.push(n);var r=n();t.push(r)}return{runEffect:n,cleanupEffects:function(){var e=t;t=[],e.forEach((function(e){e()}))},runEffects:function(){var t=e;e=[],t.forEach((function(e){n(e)}))}}}(),a=r.runEffect,c=r.cleanupEffects,l=r.runEffects,s=(t=[],{reactive:function(e){var n=e(),r={_fn:e,_ref:{current:n},get value(){return this._ref.current},set value(e){this._ref.current=e}};return t.push(r),r},runReactives:function(){t.forEach((function(e){e._ref.current=e._fn()}))}}),d=s.reactive,m=s.runReactives,h=p(!1),y=p(e),b=p(void 0),O=d((function(){return function(e){var t,r=e.classNames,o=e.container,i=e.getEnvironmentProps,a=e.getFormProps,c=e.getInputProps,l=e.getItemProps,s=e.getLabelProps,p=e.getListProps,f=e.getPanelProps,d=e.getRootProps,m=e.panelContainer,h=e.panelPlacement,g=e.render,y=e.renderNoResults,b=e.renderer,O=e.detachedMediaQuery,_=e.components,P=e.translations,j=u(e,On),w="undefined"!=typeof window?window:{},S=Qe(w,o);S.tagName;var I=n(n({},jn),b),E={Highlight:hn(I),ReverseHighlight:gn(I),ReverseSnippet:yn(I),Snippet:bn(I)};return{renderer:{classNames:$e(_n,null!=r?r:{}),container:S,getEnvironmentProps:null!=i?i:function(e){return e.props},getFormProps:null!=a?a:function(e){return e.props},getInputProps:null!=c?c:function(e){return e.props},getItemProps:null!=l?l:function(e){return e.props},getLabelProps:null!=s?s:function(e){return e.props},getListProps:null!=p?p:function(e){return e.props},getPanelProps:null!=f?f:function(e){return e.props},getRootProps:null!=d?d:function(e){return e.props},panelContainer:m?Qe(w,m):w.document.body,panelPlacement:null!=h?h:"input-wrapper-width",render:null!=g?g:Pn,renderNoResults:y,renderer:I,detachedMediaQuery:null!=O?O:getComputedStyle(w.document.documentElement).getPropertyValue("--aa-detached-media-query"),components:n(n({},E),_),translations:n(n({},{clearButtonTitle:"Clear",detachedCancelButtonText:"Cancel",submitButtonTitle:"Submit"}),P)},core:n(n({},j),{},{id:null!==(t=j.id)&&void 0!==t?t:v(),environment:w})}}(y.current)})),_=d((function(){return O.value.core.environment.matchMedia(O.value.renderer.detachedMediaQuery).matches})),P=d((function(){return Ue(n(n({},O.value.core),{},{onStateChange:function(e){var t,n,r;h.current=e.state.collections.some((function(e){return e.source.templates.noResults})),null===(t=b.current)||void 0===t||t.call(b,e),null===(n=(r=O.value.core).onStateChange)||void 0===n||n.call(r,e)},shouldPanelOpen:y.current.shouldPanelOpen||function(e){var t=e.state;if(_.value)return!0;var n=g(t)>0;if(!O.value.core.openOnFocus&&!t.query)return n;var r=Boolean(h.current||O.value.renderer.renderNoResults);return!n&&r||n},__autocomplete_metadata:{userAgents:Sn,options:e}}))})),j=p(n({collections:[],completion:null,context:{},isOpen:!1,query:"",activeItemId:null,status:"idle"},O.value.core.initialState)),w={getEnvironmentProps:O.value.renderer.getEnvironmentProps,getFormProps:O.value.renderer.getFormProps,getInputProps:O.value.renderer.getInputProps,getItemProps:O.value.renderer.getItemProps,getLabelProps:O.value.renderer.getLabelProps,getListProps:O.value.renderer.getListProps,getPanelProps:O.value.renderer.getPanelProps,getRootProps:O.value.renderer.getRootProps},S={setActiveItemId:P.value.setActiveItemId,setQuery:P.value.setQuery,setCollections:P.value.setCollections,setIsOpen:P.value.setIsOpen,setStatus:P.value.setStatus,setContext:P.value.setContext,refresh:P.value.refresh},I=d((function(){return Ve.bind(O.value.renderer.renderer.createElement)})),E=d((function(){return ct({autocomplete:P.value,autocompleteScopeApi:S,classNames:O.value.renderer.classNames,environment:O.value.core.environment,isDetached:_.value,placeholder:O.value.core.placeholder,propGetters:w,setIsModalOpen:k,state:j.current,translations:O.value.renderer.translations})}));function A(){tt(E.value.panel,{style:_.value?{}:wn({panelPlacement:O.value.renderer.panelPlacement,container:E.value.root,form:E.value.form,environment:O.value.core.environment})})}function C(e){j.current=e;var t={autocomplete:P.value,autocompleteScopeApi:S,classNames:O.value.renderer.classNames,components:O.value.renderer.components,container:O.value.renderer.container,html:I.value,dom:E.value,panelContainer:_.value?E.value.detachedContainer:O.value.renderer.panelContainer,propGetters:w,state:j.current,renderer:O.value.renderer.renderer},r=!g(e)&&!h.current&&O.value.renderer.renderNoResults||O.value.renderer.render;!function(e){var t=e.autocomplete,r=e.autocompleteScopeApi,o=e.dom,i=e.propGetters,u=e.state;nt(o.root,i.getRootProps(n({state:u,props:t.getRootProps({})},r))),nt(o.input,i.getInputProps(n({state:u,props:t.getInputProps({inputElement:o.input}),inputElement:o.input},r))),tt(o.label,{hidden:"stalled"===u.status}),tt(o.loadingIndicator,{hidden:"stalled"!==u.status}),tt(o.clearButton,{hidden:!u.query})}(t),function(e,t){var r=t.autocomplete,o=t.autocompleteScopeApi,u=t.classNames,a=t.html,c=t.dom,l=t.panelContainer,s=t.propGetters,p=t.state,f=t.components,d=t.renderer;if(p.isOpen){l.contains(c.panel)||"loading"===p.status||l.appendChild(c.panel),c.panel.classList.toggle("aa-Panel--stalled","stalled"===p.status);var m=p.collections.filter((function(e){var t=e.source,n=e.items;return t.templates.noResults||n.length>0})).map((function(e,t){var c=e.source,l=e.items;return d.createElement("section",{key:t,className:u.source,"data-autocomplete-source-id":c.sourceId},c.templates.header&&d.createElement("div",{className:u.sourceHeader},c.templates.header({components:f,createElement:d.createElement,Fragment:d.Fragment,items:l,source:c,state:p,html:a})),c.templates.noResults&&0===l.length?d.createElement("div",{className:u.sourceNoResults},c.templates.noResults({components:f,createElement:d.createElement,Fragment:d.Fragment,source:c,state:p,html:a})):d.createElement("ul",i({className:u.list},s.getListProps(n({state:p,props:r.getListProps({})},o))),l.map((function(e){var t=r.getItemProps({item:e,source:c});return d.createElement("li",i({key:t.id,className:u.item},s.getItemProps(n({state:p,props:t},o))),c.templates.item({components:f,createElement:d.createElement,Fragment:d.Fragment,item:e,state:p,html:a}))}))),c.templates.footer&&d.createElement("div",{className:u.sourceFooter},c.templates.footer({components:f,createElement:d.createElement,Fragment:d.Fragment,items:l,source:c,state:p,html:a})))})),v=d.createElement(d.Fragment,null,d.createElement("div",{className:u.panelLayout},m),d.createElement("div",{className:"aa-GradientBottom"})),h=m.reduce((function(e,t){return e[t.props["data-autocomplete-source-id"]]=t,e}),{});e(n(n({children:v,state:p,sections:m,elements:h},d),{},{components:f,html:a},o),c.panel)}else l.contains(c.panel)&&l.removeChild(c.panel)}(r,t)}function D(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};c();var t=O.value.renderer,n=t.components,r=u(t,In);y.current=Ge(r,O.value.core,{components:Ke(n,(function(e){return!e.value.hasOwnProperty("__autocomplete_componentName")})),initialState:j.current},e),m(),l(),P.value.refresh().then((function(){C(j.current)}))}function k(e){requestAnimationFrame((function(){var t=O.value.core.environment.document.body.contains(E.value.detachedOverlay);e!==t&&(e?(O.value.core.environment.document.body.appendChild(E.value.detachedOverlay),O.value.core.environment.document.body.classList.add("aa-Detached"),E.value.input.focus()):(O.value.core.environment.document.body.removeChild(E.value.detachedOverlay),O.value.core.environment.document.body.classList.remove("aa-Detached"),P.value.setQuery(""),P.value.refresh()))}))}return a((function(){var e=P.value.getEnvironmentProps({formElement:E.value.form,panelElement:E.value.panel,inputElement:E.value.input});return tt(O.value.core.environment,e),function(){tt(O.value.core.environment,Object.keys(e).reduce((function(e,t){return n(n({},e),{},o({},t,void 0))}),{}))}})),a((function(){var e=_.value?O.value.core.environment.document.body:O.value.renderer.panelContainer,t=_.value?E.value.detachedOverlay:E.value.panel;return _.value&&j.current.isOpen&&k(!0),C(j.current),function(){e.contains(t)&&e.removeChild(t)}})),a((function(){var e=O.value.renderer.container;return e.appendChild(E.value.root),function(){e.removeChild(E.value.root)}})),a((function(){var e=f((function(e){C(e.state)}),0);return b.current=function(t){var n=t.state,r=t.prevState;(_.value&&r.isOpen!==n.isOpen&&k(n.isOpen),_.value||!n.isOpen||r.isOpen||A(),n.query!==r.query)&&O.value.core.environment.document.querySelectorAll(".aa-Panel--scrollable").forEach((function(e){0!==e.scrollTop&&(e.scrollTop=0)}));e({state:n})},function(){b.current=void 0}})),a((function(){var e=f((function(){var e=_.value;_.value=O.value.core.environment.matchMedia(O.value.renderer.detachedMediaQuery).matches,e!==_.value?D({}):requestAnimationFrame(A)}),20);return O.value.core.environment.addEventListener("resize",e),function(){O.value.core.environment.removeEventListener("resize",e)}})),a((function(){if(!_.value)return function(){};function e(e){E.value.detachedContainer.classList.toggle("aa-DetachedContainer--modal",e)}function t(t){e(t.matches)}var n=O.value.core.environment.matchMedia(getComputedStyle(O.value.core.environment.document.documentElement).getPropertyValue("--aa-detached-modal-media-query"));e(n.matches);var r=Boolean(n.addEventListener);return r?n.addEventListener("change",t):n.addListener(t),function(){r?n.removeEventListener("change",t):n.removeListener(t)}})),a((function(){return requestAnimationFrame(A),function(){}})),n(n({},S),{},{update:D,destroy:function(){c()}})},e.getAlgoliaFacets=function(e){var t=En({transformResponse:function(e){return e.facetHits}}),r=e.queries.map((function(e){return n(n({},e),{},{type:"facet"})}));return t(n(n({},e),{},{queries:r}))},e.getAlgoliaResults=An,Object.defineProperty(e,"__esModule",{value:!0})}));
/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/@algolia/autocomplete-plugin-query-suggestions@1.6.2/dist/umd/index.production.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*! @algolia/autocomplete-plugin-query-suggestions 1.6.2 | MIT License | © Algolia, Inc. and contributors | https://github.com/algolia/autocomplete */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["@algolia/autocomplete-plugin-query-suggestions"]={})}(this,(function(e){"use strict";function t(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function r(e){for(var r=1;r<arguments.length;r++){var o=null!=arguments[r]?arguments[r]:{};r%2?t(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):t(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function a(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return o(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?o(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,a=function(){};return{s:a,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,u=!0,c=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return u=e.done,e},e:function(e){c=!0,i=e},f:function(){try{u||null==r.return||r.return()}finally{if(c)throw i}}}}var i="1.6.2",u=[{segment:"autocomplete-core",version:i}];function c(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?c(Object(r),!0).forEach((function(t){l(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var f=["params"];function p(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function y(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?p(Object(r),!0).forEach((function(t){m(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):p(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function m(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function b(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}function g(e){return function(e){if(Array.isArray(e))return O(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return O(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return O(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function O(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var h=[{segment:"autocomplete-js",version:i}];function v(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function d(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?v(Object(r),!0).forEach((function(t){j(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):v(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function j(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var P=function(e,t){function r(t){return e({searchClient:t.searchClient,queries:t.requests.map((function(e){return e.query}))}).then((function(e){return e.map((function(e,r){var n=t.requests[r];return{items:e,sourceId:n.sourceId,transformResponse:n.transformResponse}}))}))}return function(e){return function(n){return s(s({requesterId:t,execute:r},e),n)}}}((function(e){return function(e){var t=e.searchClient,r=e.queries,n=e.userAgents,o=void 0===n?[]:n;return"function"==typeof t.addAlgoliaAgent&&[].concat(g(u),g(o)).forEach((function(e){var r=e.segment,n=e.version;t.addAlgoliaAgent(r,n)})),t.search(r.map((function(e){var t=e.params;return y(y({},b(e,f)),{},{params:y({hitsPerPage:5,highlightPreTag:"__aa-highlight__",highlightPostTag:"__/aa-highlight__"},t)})}))).then((function(e){return e.results}))}(d(d({},e),{},{userAgents:h}))}),"algolia"),w=P({transformResponse:function(e){return e.hits}});function I(e){var t=e.onTapAhead;return{item:function(e){var r=e.item,n=e.createElement,o=e.components;return r.__autocomplete_qsCategory?n("div",{className:"aa-ItemWrapper"},n("div",{className:"aa-ItemContent aa-ItemContent--indented"},n("div",{className:"aa-ItemContentSubtitle aa-ItemContentSubtitle--standalone"},n("span",{className:"aa-ItemContentSubtitleIcon"}),n("span",null,"in"," ",n("span",{className:"aa-ItemContentSubtitleCategory"},r.__autocomplete_qsCategory))))):n("div",{className:"aa-ItemWrapper"},n("div",{className:"aa-ItemContent"},n("div",{className:"aa-ItemIcon aa-ItemIcon--noBorder"},n("svg",{viewBox:"0 0 24 24",fill:"currentColor"},n("path",{d:"M16.041 15.856c-0.034 0.026-0.067 0.055-0.099 0.087s-0.060 0.064-0.087 0.099c-1.258 1.213-2.969 1.958-4.855 1.958-1.933 0-3.682-0.782-4.95-2.050s-2.050-3.017-2.050-4.95 0.782-3.682 2.050-4.95 3.017-2.050 4.95-2.050 3.682 0.782 4.95 2.050 2.050 3.017 2.050 4.95c0 1.886-0.745 3.597-1.959 4.856zM21.707 20.293l-3.675-3.675c1.231-1.54 1.968-3.493 1.968-5.618 0-2.485-1.008-4.736-2.636-6.364s-3.879-2.636-6.364-2.636-4.736 1.008-6.364 2.636-2.636 3.879-2.636 6.364 1.008 4.736 2.636 6.364 3.879 2.636 6.364 2.636c2.125 0 4.078-0.737 5.618-1.968l3.675 3.675c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414z"}))),n("div",{className:"aa-ItemContentBody"},n("div",{className:"aa-ItemContentTitle"},n(o.ReverseHighlight,{hit:r,attribute:"query"})))),n("div",{className:"aa-ItemActions"},n("button",{className:"aa-ItemActionButton",title:'Fill query with "'.concat(r.query,'"'),onClick:function(e){e.preventDefault(),e.stopPropagation(),t(r)}},n("svg",{viewBox:"0 0 24 24",fill:"currentColor"},n("path",{d:"M8 17v-7.586l8.293 8.293c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414l-8.293-8.293h7.586c0.552 0 1-0.448 1-1s-0.448-1-1-1h-10c-0.552 0-1 0.448-1 1v10c0 0.552 0.448 1 1 1s1-0.448 1-1z"})))))}}}e.createQuerySuggestionsPlugin=function(e){var t=function(e){return r({getSearchParams:function(){return{}},transformSource:function(e){return e.source},itemsWithCategories:1,categoriesPerItem:1},e)}(e),n=t.searchClient,o=t.indexName,i=t.getSearchParams,u=t.transformSource,c=t.categoryAttribute,s=t.itemsWithCategories,l=t.categoriesPerItem;return{name:"aa.querySuggestionsPlugin",getSources:function(e){var t=e.query,f=e.setQuery,p=e.refresh,y=e.state;function m(e){f("".concat(e.query," ")),p()}return[u({source:{sourceId:"querySuggestionsPlugin",getItemInputValue:function(e){return e.item.query},getItems:function(){return w({searchClient:n,queries:[{indexName:o,query:t,params:i({state:y})}],transformResponse:function(e){var n=e.hits[0];return t&&c?n.reduce((function(e,t,n){var o,i,u=[t];if(n<=s-1){var f,p=(o=t,i=Array.isArray(c)?c:[c],i.reduce((function(e,t){return e&&e[t]}),o)).map((function(e){return e.value})).slice(0,l),y=a(p);try{for(y.s();!(f=y.n()).done;){var m=f.value;u.push(r({__autocomplete_qsCategory:m},t))}}catch(e){y.e(e)}finally{y.f()}}return e.push.apply(e,u),e}),[]):n}})},templates:I({onTapAhead:m})},onTapAhead:m,state:y})]},__autocomplete_pluginOptions:e}},e.getTemplates=I,Object.defineProperty(e,"__esModule",{value:!0})}));
$(document).ready(function () {
    var isTouch = window.matchMedia("(pointer: coarse)").matches || 'ontouchstart' in window || navigator.msMaxTouchPoints;
    var isLocalHost = location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.hostname === '' || location.hostname === 'caa';
    var lightMode = Cookies.get('lightMode') ? Cookies.get('lightMode') : 'light';
    var lang = $('body').data('lang');
    var topbarH = 152;
    var popupNlIsOpen = false;
    var aIndex = isLocalHost ? 'CAA-test' : lang == 'en' ? 'climat_action_accelerator_en' : 'climat_action_accelerator_fr';
    var aIndexQuerySug = isLocalHost ? 'CAA-test_query_suggestions' : lang == 'en' ? 'climat_action_accelerator_en_query_suggestions' : 'climat_action_accelerator_fr_query_suggestions';
    var algoliaAppID = isLocalHost ? 'B98TMUO56H' : 'H4335KHPRJ';
    var algoliaSearchApiKey = isLocalHost ? '8b48aaf35c4ae7c58ad17cf8f9ea5d9d' : 'afed438caf6adb03b3cc1d6846418938';
    //var isOnce = true;
    //var navIsOpen = false;
    

    

    // if(isLightMode != 'true'){
    //     console.log('DARK');
    //     $('body').addClass('dark-mode');
    //     $('.color-mode__button').removeClass('color-mode__button--light').addClass('color-mode__button--dark');
    // } else {
    //     console.log('LIGHT');
    //     $('body').removeClass('dark-mode');
    //     $('.color-mode__button').addClass('color-mode__button--light').removeClass('color-mode__button--dark');
    // }

    const searchClient = algoliasearch(
        algoliaAppID,
        algoliaSearchApiKey
    );

    if ($('.home-search-bar').length) {
        var theTextQuery = '';

        const { autocomplete } = window['@algolia/autocomplete-js'];
        const { createQuerySuggestionsPlugin } = window['@algolia/autocomplete-plugin-query-suggestions'];

        const querySuggestionsPlugin = createQuerySuggestionsPlugin({
            searchClient,
            indexName: aIndexQuerySug,
            onSelect: (query) => { console.log(query) },
            getSearchParams() {
                return {
                    hitsPerPage: 10,
                };
            },
        });

        const autocompleteSearch = autocomplete({
            container: '.home-search-bar__input',
            placeholder: 'Search',
            openOnFocus: false,
            plugins: [querySuggestionsPlugin],
            onStateChange({ state }) {
                theTextQuery = state.query;
            },
        });

        $('.home-search-bar__submit').on('click', function (e) {
            e.preventDefault();
            var baseUrl = $(this).attr('href');
            var endUrl = baseUrl + theTextQuery;

            if (theTextQuery != '') {
                console.log(endUrl);
                window.location = endUrl;
            }
        });

        $('body').find('.home-search-bar__input input').keypress(function (e) {

            if (e.originalEvent.key == 'Enter') {
                $('.home-search-bar__submit').trigger('click');
            }
        });
    }

    if ($('.ressources-search-bar').length) {

        const search = instantsearch({
            indexName: aIndex,
            searchClient,
            routing: true
        });

        const config = instantsearch.widgets.configure({
            hitsPerPage: 10,
            enablePersonalization: false
        });

        const searchBox = instantsearch.widgets.searchBox({
            container: '#ressources-search-bar',
            placeholder: 'Search for products',
            searchAsYouType: true,
            showReset: true,
            showLoadingIndicator: true,
        })

        search.on('render', function () {
            console.log('COOL');
            setTimeout(() => {
                ScrollTrigger.refresh();
            }, 500);
        });

        // Create the render function
        const renderInfiniteHits = (renderOptions, isFirstRender) => {
            const {
                hits,
                widgetParams,
                showPrevious,
                isFirstPage,
                showMore,
                isLastPage,
            } = renderOptions;

            if (isFirstRender) {
                const list = document.createElement('div');
                list.className = 'card-grid';

                const moreButton = document.createElement('button');
                const moreButtonContainer = document.createElement('div');
                moreButton.className = 'more-button';
                moreButton.textContent = 'Show more';
                moreButtonContainer.className = 'ressources-results__show-more';

                moreButton.addEventListener('click', () => {
                    showMore();
                });

                widgetParams.container.appendChild(list);
                moreButtonContainer.appendChild(moreButton)
                widgetParams.container.appendChild(moreButtonContainer);

                return;
            }

            widgetParams.container.querySelector('.more-button').disabled = isLastPage;

            widgetParams.container.querySelector('.card-grid').innerHTML = `
            ${hits
                    .map(
                        hit => {
                            if (hit.postType === 'solutions') {
                                return `
                            <div class="card card--rounded card--solution card--${hit.bgColor}">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span>${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">${hit.postType}</span>
                                        </span>
                                    </header>
                                    <div class="card__main">
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                        </div>
                                    </div>
                                    <footer class="card__footer">
                                        <ul class="card__tags">
                                            ${hit.areas.map(area => `<li class="card__tag-item">${area}</li>`).join("")}
                                        </ul>
                                    </footer>
                                </div>
                            </div>
                            `
                            } else if (hit.postType === 'page') {
                                return `
                            <div class="card">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span>${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">${hit.postType}</span>
                                        </span>
                                    </header>
                                    <div class="card__main">
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                        </div>
                                    </div>
                                    <footer class="card__footer">
                                        <ul class="card__tags">
                                            ${hit.areas.map(area => `<li class="card__tag-item">${area}</li>`).join("")}
                                        </ul>
                                    </footer>
                                </div>
                            </div>
                            `
                            } else if (hit.postType === 'experiences') {
                                return `
                            <div class="card">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span>${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">${hit.postType}</span>
                                        </span>
                                    </header>
                                    <div class="card__main">
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                        </div>
                                    </div>
                                    <footer class="card__footer">
                                        <ul class="card__tags">
                                            ${hit.areas.map(area => `<li class="card__tag-item">${area}</li>`).join("")}
                                        </ul>
                                    </footer>
                                </div>
                            </div>
                            `

                            } else if (hit.postType === 'experts') {

                                return `
                            <div class="card card--expert">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span>${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">${hit.postType}</span>
                                        </span>
                                    </header>
                                    <div class="card__main">
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                            <p class="card__sub-title">Fondateur de projet Drawdown</p>
                                        </div>
                                        <div class="card__media">
                                            <div class="card__img">
                                                <img src="${hit.mainImage}" alt="">
                                                <div class="img-cover" style="background-image: url(${hit.mainImage})"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <footer class="card__footer">
                                        <ul class="card__tags">
                                            ${hit.tags.map(tag => `<li class="card__tag-item">${tag}</li>`).join("")}
                                        </ul>
                                    </footer>
                                </div>
                            </div>`
                            } else if (hit.postType === 'areas') {
                                return `
                            <div class="card card--field">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span><${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">${hit.postType}</span>
                                        </span>
                                    </header>
                                    <div class="card__main">
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                        </div>
                                    </div>

                                </div>
                            </div>
                            `
                            } else if (hit.postType === 'post') {
                                return `
                            <div class="card card--news">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span>${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">actualites</span>
                                        </span>
                                        <span class="card__time">${hit.date}</span>
                                    </header>
                                    <div class="card__main">
                        
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                            <span class="card__read-more">Lire plus</span>
                                        </div>
                        
                                    </div>
                                    <footer class="card__footer">
                                        <ul class="card__tags">
                                            ${hit.areas.map(area => `<li class="card__tag-item">${area}</li>`).join("")}
                                        </ul>
                                    </footer>
                                </div>
                            </div>`
                            } else if (hit.postType === 'events') {
                                return `
                            <div class="card card--news">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span>${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">${hit.postType}</span>
                                        </span>
                                        ${hit.date ? `<span class="card__time">${hit.date}</span>` : ''}
                                    </header>
                                    <div class="card__main">
                        
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                            <span class="card__read-more">Lire plus</span>
                                        </div>
                        
                                    </div>
                                    <footer class="card__footer">
                                        <ul class="card__tags">
                                            ${hit.areas.map(area => `<li class="card__tag-item">${area}</li>`).join("")}
                                        </ul>
                                    </footer>
                                </div>
                            </div>`
                            } else if (hit.postType === 'partners') {
                                return `
                            <div class="card card--partner">
                                <a href="${hit.url}" class="card__link" title="${hit.title}"><span>${hit.title}</span></a>
                                <div class="card-in">
                                    <header class="card__header">
                                        <span class="card__type">
                                            <span class="card__type__icon"></span>
                                            <span class="card__type__name">${hit.postType}</span>
                                        </span>
                                    </header>
                                    <div class="card__main">
                                        <div class="card__main__top">
                                            <h2 class="card__title">${hit.title}</h2>
                                            <p class="card__sub-title">On the ground in over 90 countries - neutral, impartial, and independent - we are the International Committee of the Red Cross.</p>
                                        </div>
                                        <div class="card__media">
                                            <div class="card--partner__logo">
                                                <img src="${hit.partnerInfo.logoUrl}" alt="${hit.title}">
                                            </div>
                                            <div class="card__img">
                                                <img src="${hit.mainImage}" alt="">
                                                <div class="img-cover" style="background-image: url(${hit.mainImage})"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <footer class="card__footer">
                                        <ul class="card__tags">
                                            ${hit.sectors.map(sector => `<li class="card__tag-item">${sector}</li>`).join("")}
                                        </ul>
                                    </footer>
                                </div>
                            </div>`
                            } else {
                                return `<h3>${hit.postType} : ${hit.title}</h3>`
                            }

                        }

                    )
                    .join('')}
            `;
        };

        // Create the custom widget
        const customInfiniteHits = instantsearch.connectors.connectInfiniteHits(
            renderInfiniteHits
        );

        const refListAreas = instantsearch.widgets.refinementList({
            container: '.ref-list__list--areas',
            attribute: 'areas',
            sortBy: ['name:asc'],
            //searchable: true,
            limit: 1000
        });

        const refListSectors = instantsearch.widgets.refinementList({
            container: '.ref-list__list--sectors',
            attribute: 'sectors',
            sortBy: ['name:asc'],
            //searchable: true,
            limit: 1000
        });

        const refListPostType = instantsearch.widgets.refinementList({
            container: '.ref-list__list--post-type',
            attribute: 'postType',
            sortBy: ['name:asc'],
            limit: 1000
        });

        const currentFilters = instantsearch.widgets.currentRefinements({
            container: '.current-filters',
        });

        const clearRef = instantsearch.widgets.clearRefinements({
            container: '.clear-all',
            templates: {
                resetLabel: 'Remove all',
            },
        });

        // Instantiate the custom widget
        search.addWidgets([config, searchBox, refListAreas, refListSectors, refListPostType, currentFilters, clearRef,
            customInfiniteHits({
                container: document.querySelector('.ressources-results')
            })
        ]);

        search.start();

    }

    // TOPBAR
    // var topBarTransitionDuration = $('.top-bar').css('transition-duration').replace('s', '') * 1000;

    var setTopBarHVarDebounce = debounce(function () {
        var $topBar = $('.top-bar');
        topBarH = $topBar.outerHeight(true) + $topBar.position().top;
        document.documentElement.style.setProperty('--top-bar-h', topBarH + 'px');
    }, 350);

    setTopBarHVarDebounce();

    ScrollTrigger.create({
        trigger: '.header',
        // start: 'top -40%',
        start: 'top -50px',
        end: 99999,
        // onUpdate: (self) => {
        //     if(self.direction === -1){
        //         $('.top-bar').removeClass('top-bar--small');
        //     } else {
        //         $('.top-bar').addClass('top-bar--small');
        //     }
        // },
        onEnter: (self) => {
            $('.top-bar').addClass('top-bar--small');
            setTopBarHVarDebounce();
        },
        onLeaveBack: (self) => {
            $('.top-bar').removeClass('top-bar--small');
            setTopBarHVarDebounce();
        },
    });

    if ($('.top-bar__sub').length) {
        ScrollTrigger.create({
            trigger: '.header',
            //start: 'bottom top',
            start: () => { return 'bottom ' + topbarH + 'px' },
            end: 99999,
            // onUpdate: (self) => {
            //     if(self.direction === -1){
            //         $('.top-bar').removeClass('top-bar--small');
            //     } else {
            //         $('.top-bar').addClass('top-bar--small');
            //     }
            // },
            onEnter: (self) => {
                $('.top-bar__sub').addClass('top-bar__sub--is-visible');
                setTopBarHVarDebounce();
            },
            onLeaveBack: (self) => {
                $('.top-bar__sub').removeClass('top-bar__sub--is-visible');
                setTopBarHVarDebounce();
            },
        });
    }
    
    $('.color-mode__button').on('click', function (e) {
        e.preventDefault();

        if (lightMode == 'light') {
            $('body').addClass('dark-mode');
            $(this).removeClass('color-mode__button--light').addClass('color-mode__button--dark');
            Cookies.set('lightMode', 'dark');
            lightMode = 'dark';
        } else {
            $('body').removeClass('dark-mode');
            $(this).removeClass('color-mode__button--dark').addClass('color-mode__button--light');
            Cookies.set('lightMode', 'light');
            lightMode = 'light';
        }

    });

    $('.color-mode__button').on('mouseover', function(){
        $('body').addClass('no-transition');
    });

    $('.color-mode__button').on('mouseleave', function(){
        $('body').removeClass('no-transition');
    });

    Marquee3k.init({
        selector: 'news-bar__marquee'
    });
    Marquee3k.refreshAll();


    $('.nl-sub').on('click', function (e) {
        e.preventDefault();
        if (!popupNlIsOpen) {
            gsap.to($('.popup--newsletter'), { autoAlpha: 1, display: 'flex', onComplete: function () { popupNlIsOpen == true } });
        } else {
            gsap.to($('.popup--newsletter'), { autoAlpha: 0, display: 'none', onComplete: function () { popupNlIsOpen == false } });
        }
    });

    $('.popup--newsletter .close-popup').on('click', function (e) {
        gsap.to($('.popup--newsletter'), { autoAlpha: 0, display: 'none', onComplete: function () { popupNlIsOpen == false } });
    });

    //// TOPBAR

    // HEADER HOME
    if ($('.header--home').length) {
        var el = $('.header__front li');
        gsap.set(el.not(':first'), { autoAlpha: 0, yPercent: 100, scale: .95 });
        var animHeader = new TimelineMax({ repeat: 0, delay: 10, repeatDelay: 0, onComplete: () => { animHeader.restart(true) } });

        for (var i = 0; i < el.length; i++) {
            var E = el[i];
            var nextE = el[i + 1];
            // tl.to(E, 0.5, {yPercent: 0, autoAlpha:1, duration: .25, ease: Power2.easeOut})
            //   .to(E, 0.5, {yPercent: -100, autoAlpha:0, duration: .25, ease:Power2.easeOut},'+=2.5')

            if (nextE) {
                animHeader.to(E, { scale: .95, yPercent: -100, autoAlpha: 0, duration: 1.25, ease: Circ.easeInOut }, 'sameTime+=' + 10 * i)
                    .to(nextE, { scale: 1, yPercent: 0, autoAlpha: 1, duration: 1.25, ease: Circ.easeInOut }, 'sameTime+=' + 10 * i)
            }


        };
    }

    //// HEADER HOME

    // DROP CARDS
    if ($('.card-drop-list').length) {

        var rotationX = [];
        var rotationY = [];
        var duration = [];

        initDrag();

        let dropCard = gsap.timeline({
            scrollTrigger: {
                trigger: '.section--drop-cards',
                pin: true,   // pin the trigger element while active
                start: "top top", // when the top of the trigger hits the top of the viewport
                end: () => { return "+=" + window.innerHeight * 3 }, // end after scrolling 500px beyond the start
                scrub: 0,
                onLeave: function (self) {
                    let start = self.start;
                    self.scroll(self.start);
                    self.disable();
                    self.animation.progress(1, true);
                    ScrollTrigger.refresh();
                    window.scrollTo(0, start);
                }
            }
        });

        $('.card-drop-list .card').each(function (i) {
            //var xPos = (100 / $('.card-drop-list .card').length) * i;
            var xPos = randomNumBetween(1, 80);
            var yPos = randomNumBetween(10, 60);
            var rotation = randomNumBetween(-25, 25);

            rotationX.push(randomNumBetween(-80, 80))
            rotationY.push(randomNumBetween(-80, 80))
            duration.push(randomNumBetween(.5, 1.5))

            gsap.set($(this), { left: xPos + '%', top: yPos + 'vh', rotate: rotation });
        });

        dropCard.from('.card-drop-list .card', { scale: 2, 'border-width': '0.05vw', rotateX: (i) => rotationX[i], rotateY: (i) => rotationY[i], duration: 1, ease: Power3.easeIn, stagger: .4 }, 'start')
            .from('.card-drop-list .card', { autoAlpha: 0, duration: .5, ease: Power3.easeIn, stagger: .4 }, 'start')
            .from('.card-drop-list .card', { filter: 'blur(10px)', duration: 1, ease: Power3.easeIn, stagger: .4 }, 'start');

        function initDrag() {
            Draggable.create('.section--drop-cards .card', { type: 'x,y', edgeResistance: 0.65, bounds: '.section--drop-cards', inertia: true })
        };
    }
    //// DROP CARDS
    // HOME HOW

    if ($('.how-list').length) {
        let howToAnim = gsap.timeline({
            scrollTrigger: {
                trigger: '.section--how',
                start: 'top top',
                //markers: true
            }
        });

        howToAnim.from('.how-list__item', { autoAlpha: 0, stagger: .4, duration: .5, ease: Power3.easeInOut }, 'how-to')
            .from('.how-list__arrow path', { autoAlpha: 0, '--offset': 813, stagger: .4, duration: .5, ease: Power3.easeInOut }, 'how-to+=.1');
    }

    //// HOME HOW
    // CARD

    $('body').on('mouseenter', '.card__link', function () {
        var thisCard = $(this).parent('.card');
        // console.log(thisCard);
        thisCard.addClass('card--hover');
    });

    $('body').on('mouseleave', '.card__link', function () {
        var thisCard = $(this).parent('.card');
        thisCard.removeClass('card--hover');
    });

    //// CARD

    // SIDE NAV

    $('.side-nav a').on('click', function (e) {
        e.preventDefault();
        var thisHash = $(this).attr('href');
        //gsap.to(window, {duration: 1, scrollTo: thisHash});
        gsap.to(window, { duration: 1, scrollTo: { y: thisHash, offsetY: topbarH - 2 }, ease: Power3.easeOut });
    });

    $('.article .block[id]').each(function () {
        var thisId = $(this).attr('id')
        var $thisRelatedNavItem = $('.side-nav__link[href="#' + thisId + '"]');

        ScrollTrigger.create({
            trigger: $(this),
            // start: 'top 40px',
            start: () => { return 'top ' + topbarH + 'px' },
            end: '1000000px',
            toggleClass: { targets: $thisRelatedNavItem, className: 'side-nav__link--is-active' },
            onEnter: function () {
                //console.log($thisRelatedNavItem.parent('li').length)
                if ($thisRelatedNavItem.parent('li').length) {
                    var h = $thisRelatedNavItem.parent('li').position().top + $thisRelatedNavItem.parent('li').outerHeight(true);
                    gsap.to('.side-nav__list', { '--h': h + 'px', duration: .5 });
                }

            },
            onLeaveBack: function () {
                //console.log($thisRelatedNavItem.parent('li').length)
                if ($thisRelatedNavItem.parent('li').length) {
                    var h = $thisRelatedNavItem.parent('li').position().top;
                    gsap.to('.side-nav__list', { '--h': h + 'px', duration: .5 });
                }
            }
        });
    });

    //// SIDE NAV

    // SLIDERS

    // SLIDER LAST NEWS

    var lastNewsSlider = $('.slider--last-news').flickity({
        // options
        cellAlign: 'left',
        contain: true,
        prevNextButtons: false,
        pageDots: true
    });

    // SLIDER PARTNERS

    var partnersSlider = $('.slider--partners').flickity({
        // options
        cellAlign: 'left',
        contain: true,
        prevNextButtons: false,
        pageDots: true
    });

    // SLIDER STAT

    $('.stats-slider').each(function () {
        var statSlide = $(this).flickity({
            // options
            cellAlign: 'left',
            contain: true,
            prevNextButtons: false,
            pageDots: false
        });
    });



    // SLIDER TIMELINE  
    var timeLineSlider = $('.timeline-slider').flickity({
        // options
        cellAlign: 'left',
        contain: true,
        prevNextButtons: false,
        pageDots: false,
        freeScroll: true
    });

    timeLineSlider.on('scroll.flickity', function (event, progress) {
        //progress = Math.max( 0, Math.min( 1, progress ) );
        //$progressBar.width( progress * 100 + '%' );
        progress = gsap.utils.clamp(0, 1, progress)
        console.log(progress * 100);
        gsap.set('.timeline-slider', { '--position': progress * 100 + '%' });
    });

    //// SLIDERS

    // DROPDOWNS

    $('.dropdown__trigger').on('click', function () {
        var thisDropdown = $(this).parents('.dropdown');
        var isClosed = thisDropdown.hasClass('dropdown--is-closed');
        var thisDropdownContent = thisDropdown.find('.dropdown__content');
        var dropDownH = thisDropdownContent.find('>div').outerHeight(true);

        if (isClosed) {
            $('.dropdown').removeClass('dropdown--is-open').addClass('dropdown--is-closed');
            gsap.to($('.dropdown__content'), 1, { height: 0, ease: Expo.easeInOut });
            gsap.to(thisDropdownContent, 1, {
                height: dropDownH + 'px', ease: Expo.easeInOut, onComplete: function () {
                    gsap.set(thisDropdownContent, { height: 'auto' });
                    ScrollTrigger.refresh();
                }
            });


            $(this).parents('.dropdown').removeClass('dropdown--is-closed').addClass('dropdown--is-open');

        } else {
            gsap.to(thisDropdownContent, 1, {
                height: 0, ease: Expo.easeInOut, onComplete: function () {
                    ScrollTrigger.refresh();
                }
            });
            $(this).parents('.dropdown').removeClass('dropdown--is-open').addClass('dropdown--is-closed');
        };
    });

    // VIDEOS

    const players = Array.from(document.querySelectorAll('.block--video__video')).map((p) => new Plyr(p));

    $('.block--video__video button').on('click', function (e) {
        e.preventDefault();
        var vidId = $(this).data('video-id');

        var youtubeIframe = `<iframe class="block--video__iframe" type="text/html" width="720" height="405"
        src="https://www.youtube.com/embed/${vidId}?modestbranding=1&playsinline=1&autoplay=1&color=white&iv_load_policy=3"
        frameborder="0" allowfullscreen>`;

        $(this).parent('.block--video__video').append(youtubeIframe);

        $(this).remove();
    });

    // LAZY LOAD IMAGE

    var lazyLoadInstance = new LazyLoad({
        // Your custom settings go here
    });

    // FEATURED BLOCK / DRAGGABLE
    $('.block--featured').each(function () {
        var thisFeaturedBlock = $(this);
        var thisCards = thisFeaturedBlock.find('.card');

        thisCards.each(function () {
            var rotation = randomNumBetween(-10, 10);
            $(this).css('transform', 'rotate(' + rotation + 'deg)');
        });
    });

    Draggable.create('.block--featured .card', { type: 'x,y', edgeResistance: 0.65, bounds: '.block--featured', inertia: true, zIndexBoost: true });

    //// FEATURED BLOCK / DRAGGABLE

    // FOOTER

    gsap.from('.footer__contact', {
        yPercent: 100,
        scale: .95,
        scrollTrigger: {
            //markers: true,
            trigger: '.footer',
            start: 'top bottom',
            end: 'bottom bottom',
            scrub: .1,
            // onEnter: () => {console.log('enter')},
            // onLeave: () => {console.log('leave')},
            // onUpdate: self => {
            // 	console.log("progress:", self.progress.toFixed(3), "direction:", self.direction, "velocity", self.getVelocity());
            // },
            immediateRender: false
            //invalidateOnRefresh: true
        },
    });

    //// FOOTER

    ScrollTrigger.refresh();


    function killAllScrollTrigger() {
        // let Alltrigger = ScrollTrigger.getAll();

        // for (let i = 0; i < Alltrigger.length; i++) {
        //     Alltrigger[i].kill(true)
        // };
        ScrollTrigger.getAll().forEach(t => t.kill(false));
        ScrollTrigger.refresh();
        //window.dispatchEvent(new Event("resize"));
    };

    function preventSamePageReload() {
        var links = document.querySelectorAll('a[href]');
        var cbk = function (e) {
            if (e.currentTarget.href === window.location.href) {
                e.preventDefault();
                e.stopPropagation();
            }
        };

        for (var i = 0; i < links.length; i++) {
            links[i].addEventListener('click', cbk);
        }
    };

    function randomNumBetween(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function debounce(func, wait, immediate) {
        var timeout;

        return function executedFunction() {
            var context = this;
            var args = arguments;

            var later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };

            var callNow = immediate && !timeout;

            clearTimeout(timeout);

            timeout = setTimeout(later, wait);

            if (callNow) func.apply(context, args);
        };
    };

});